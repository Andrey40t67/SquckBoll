<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StaricBoll - 3D Шутер от первого лица</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Arial, sans-serif;
            background-color: #121212;
            color: white;
        }
        canvas {
            display: block;
        }
        #loader {
            position: fixed;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            background-color: #121212;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 1;
            transition: opacity 1s ease-out;
        }
        #loader h1 {
            font-size: 72px;
            color: #fff;
            text-shadow: 0 0 20px rgba(79, 220, 255, 0.7);
            letter-spacing: 5px;
            margin-bottom: 50px;
            opacity: 0;
            transform: translateY(30px);
            animation: fadeInUp 1.5s ease forwards 0.5s;
        }
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        .loader-bar {
            width: 300px;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
            margin-top: 20px;
        }
        .loader-progress {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #4FDCFF, #7165FF);
            border-radius: 4px;
            transition: width 0.5s ease;
            animation: loadProgress 3s ease forwards;
        }
        @keyframes loadProgress {
            0% { width: 0%; }
            100% { width: 100%; }
        }
        #code-check {
            position: fixed;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            background-color: #121212;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 999;
            opacity: 0;
            transform: scale(0.98);
            transition: opacity 0.7s ease, transform 0.7s ease;
        }
        #code-check.active {
            opacity: 1;
            transform: scale(1);
        }
        #code-check h2 {
            font-size: 36px;
            color: #fff;
            text-shadow: 0 0 10px rgba(79, 220, 255, 0.5);
            letter-spacing: 2px;
            margin-bottom: 30px;
            text-align: center;
        }
        #code-form {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 400px;
        }
        .code-input-container {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            width: 100%;
        }
        .code-digit {
            width: 50px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(79, 220, 255, 0.3);
            border-radius: 8px;
            color: white;
            font-size: 24px;
            text-align: center;
            transition: all 0.3s ease;
        }
        .code-digit:focus {
            outline: none;
            border-color: #4FDCFF;
            box-shadow: 0 0 15px rgba(79, 220, 255, 0.5);
        }
        #submit-code {
            background: linear-gradient(90deg, #4FDCFF, #7165FF);
            color: white;
            border: none;
            padding: 12px 40px;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 20px;
            width: 100%;
            max-width: 300px;
            letter-spacing: 1px;
            font-weight: 600;
        }
        #submit-code:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
        }
        #submit-code:active {
            transform: translateY(0);
        }
        #error-message {
            color: #ff5555;
            margin-top: 20px;
            font-size: 16px;
            height: 20px;
            text-align: center;
            transition: opacity 0.3s ease;
            opacity: 0;
        }
        #help-link {
            color: rgba(79, 220, 255, 0.7);
            margin-top: 30px;
            font-size: 16px;
            text-decoration: underline;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        #help-link:hover {
            color: #4FDCFF;
        }
        #instructions {
            position: fixed;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            background-color: rgba(18, 18, 18, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1001;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
            padding: 20px;
        }
        #instructions.active {
            opacity: 1;
            pointer-events: auto;
        }
        .instructions-container {
            background-color: #1c1c1c;
            border-radius: 15px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.5);
            position: relative;
            transform: translateY(30px);
            opacity: 0;
            transition: transform 0.5s ease, opacity 0.5s ease;
        }
        #instructions.active .instructions-container {
            transform: translateY(0);
            opacity: 1;
        }
        .instructions-container h3 {
            color: #4FDCFF;
            font-size: 24px;
            margin-bottom: 20px;
            text-align: center;
        }
        .instructions-container p {
            margin-bottom: 15px;
            line-height: 1.6;
        }
        .instructions-container ol {
            padding-left: 20px;
        }
        .instructions-container ol li {
            margin-bottom: 15px;
            line-height: 1.6;
        }
        #close-instructions {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            font-size: 24px;
            cursor: pointer;
            transition: color 0.3s ease;
        }
        #close-instructions:hover {
            color: white;
        }
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 18px;
            text-shadow: 1px 1px 2px black;
            pointer-events: none;
        }
        #health-bar {
            width: 200px;
            height: 20px;
            background-color: rgba(51, 51, 51, 0.7);
            margin-top: 10px;
            border-radius: 10px;
            overflow: hidden;
        }
        #health-fill {
            width: 100%;
            height: 100%;
            background-color: #0f0;
            transition: width 0.3s;
        }
        #ammo {
            margin-top: 10px;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.8);
            font-size: 24px;
            text-align: center;
            line-height: 20px;
            pointer-events: none;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }
        #game-over, #level-up, #quest-notification, #objective-complete {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 15px;
            display: none;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            transition: all 0.5s ease;
            animation: fadeInScale 0.5s ease forwards;
        }
        @keyframes fadeInScale {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }
        #level-up {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(47, 128, 237, 0.4));
            border: 2px solid #4FDCFF;
            max-width: 90%;
            width: 400px;
        }
        #level-up h2 {
            font-size: 36px;
            margin-bottom: 20px;
            color: #4FDCFF;
            text-shadow: 0 0 10px rgba(79, 220, 255, 0.5);
        }
        #level-up p {
            font-size: 20px;
            margin-bottom: 30px;
        }
        #quest-notification, #objective-complete {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(76, 175, 80, 0.4));
            border: 2px solid #76ff03;
            max-width: 90%;
            width: 400px;
            z-index: 900;
        }
        #quest-notification h3, #objective-complete h3 {
            font-size: 28px;
            margin-bottom: 15px;
            color: #76ff03;
            text-shadow: 0 0 10px rgba(118, 255, 3, 0.5);
        }
        #quest-description, #objective-description {
            font-size: 18px;
            margin-bottom: 20px;
            line-height: 1.5;
        }
        button {
            background: linear-gradient(90deg, #4FDCFF, #7165FF);
            border: none;
            color: white;
            padding: 12px 24px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 18px;
            margin: 15px 5px;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s ease;
            font-weight: 600;
            letter-spacing: 1px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
            background: linear-gradient(90deg, #5de2ff, #8370ff);
        }
        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }
        #device-selection {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            animation: fadeIn 1.2s ease-out;
        }
        @keyframes fadeIn {
            0% { opacity: 0; }
            100% { opacity: 1; }
        }
        #device-selection h1 {
            font-size: 48px;
            margin-bottom: 50px;
            text-align: center;
            color: #fff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            animation: titlePulse 2s infinite;
            letter-spacing: 2px;
        }
        @keyframes titlePulse {
            0% { text-shadow: 0 0 10px rgba(255, 255, 255, 0.5); }
            50% { text-shadow: 0 0 20px rgba(255, 255, 255, 0.8), 0 0 30px rgba(79, 220, 255, 0.6); }
            100% { text-shadow: 0 0 10px rgba(255, 255, 255, 0.5); }
        }
        .device-buttons {
            display: flex;
            gap: 40px;
            animation: slideUp 0.8s ease-out 0.4s both;
            flex-direction: row;
        }
        @media (max-width: 768px) {
            .device-buttons {
                flex-direction: column;
            }
        }
        @keyframes slideUp {
            0% { transform: translateY(50px); opacity: 0; }
            100% { transform: translateY(0); opacity: 1; }
        }
        .device-button {
            background: linear-gradient(145deg, #4FDCFF, #7165FF);
            color: white;
            border: none;
            padding: 20px 40px;
            font-size: 22px;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3), 
                        0 0 0 rgba(79, 220, 255, 0.4);
            position: relative;
            overflow: hidden;
            letter-spacing: 1px;
            font-weight: bold;
            text-transform: uppercase;
        }
        .device-button:before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.3) 0%, transparent 60%);
            transform: rotate(45deg);
            opacity: 0;
            transition: opacity 0.3s;
        }
        .device-button:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5), 
                        0 0 20px rgba(79, 220, 255, 0.6);
            background: linear-gradient(145deg, #5de2ff, #8370ff);
        }
        .device-button:hover:before {
            opacity: 1;
            animation: shine 1.5s infinite;
        }
        @keyframes shine {
            0% { opacity: 0.5; }
            50% { opacity: 0.8; }
            100% { opacity: 0.5; }
        }
        .device-button:active {
            transform: translateY(0) scale(0.98);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }
        #mobile-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            pointer-events: none;
            z-index: 800;
        }
        .joystick-area {
            position: absolute;
            bottom: 70px;
            left: 30px;
            width: 120px;
            height: 120px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 60px;
            pointer-events: auto;
        }
        .joystick {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.5);
            border-radius: 30px;
        }
        .action-buttons {
            position: absolute;
            bottom: 70px;
            right: 30px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            pointer-events: auto;
        }
        .action-button {
            width: 60px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: white;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        }
        .action-button:active {
            transform: scale(0.95);
            background-color: rgba(255, 255, 255, 0.4);
        }
        .look-area {
            position: absolute;
            bottom: 70px;
            right: 120px;
            width: 120px;
            height: 120px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 60px;
            pointer-events: auto;
        }
        .look-joystick {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.5);
            border-radius: 30px;
        }
        #reload-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            display: none;
            pointer-events: none;
        }
        #hit-marker {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: red;
            font-size: 40px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.1s;
        }
        #objective-indicator {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            text-align: center;
            z-index: 900;
            pointer-events: none;
            font-size: 18px;
            transition: opacity 0.5s ease;
            opacity: 0;
        }
        #objective-indicator.active {
            opacity: 1;
        }
        #inventory {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            pointer-events: none;
        }
        .inventory-slot {
            width: 60px;
            height: 60px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 16px;
            transition: all 0.3s ease;
        }
        .inventory-slot.active {
            border-color: #4FDCFF;
            box-shadow: 0 0 10px rgba(79, 220, 255, 0.5);
        }
        #item-pickup-notification {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            text-align: center;
            z-index: 900;
            pointer-events: none;
            font-size: 18px;
            transition: all 0.5s ease;
            opacity: 0;
        }
        .shake {
            animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
        }
        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }
        @media (max-width: 768px) {
            #hud {
                top: 10px;
                left: 10px;
                font-size: 16px;
            }
            #health-bar {
                width: 150px;
                height: 15px;
            }
            .action-buttons {
                bottom: 30px;
                right: 20px;
                gap: 10px;
            }
            .joystick-area {
                bottom: 30px;
                left: 20px;
            }
            .look-area {
                bottom: 30px;
                right: 100px;
            }
            .action-button {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }
            #inventory {
                bottom: 10px;
            }
            .inventory-slot {
                width: 45px;
                height: 45px;
                font-size: 14px;
            }
        }
        .weapon-switch {
            position: absolute;
            bottom: 30px;
            right: 300px;
            display: flex;
            gap: 15px;
            pointer-events: auto;
        }
        .weapon-button {
            width: 60px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: white;
            transition: all 0.2s ease;
        }
        .weapon-button.active {
            background-color: rgba(79, 220, 255, 0.5);
            box-shadow: 0 0 10px rgba(79, 220, 255, 0.5);
        }
        @media (max-width: 768px) {
            .weapon-switch {
                right: 200px;
            }
            .weapon-button {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loader">
        <h1>StaricBoll</h1>
        <div class="loader-bar">
            <div class="loader-progress"></div>
        </div>
    </div>

    <!-- Code Check Screen -->
    <div id="code-check">
        <h2>Введите код доступа</h2>
        <form id="code-form">
            <div class="code-input-container">
                <input type="text" class="code-digit" maxlength="1" pattern="[0-9]" required>
                <input type="text" class="code-digit" maxlength="1" pattern="[0-9]" required>
                <input type="text" class="code-digit" maxlength="1" pattern="[0-9]" required>
                <input type="text" class="code-digit" maxlength="1" pattern="[0-9]" required>
                <input type="text" class="code-digit" maxlength="1" pattern="[0-9]" required>
                <input type="text" class="code-digit" maxlength="1" pattern="[0-9]" required>
            </div>
            <button type="submit" id="submit-code">Войти</button>
        </form>
        <div id="error-message"></div>
        <div id="help-link">Как мне получить код?</div>
    </div>

    <!-- Instructions Modal -->
    <div id="instructions">
        <div class="instructions-container">
            <button id="close-instructions">×</button>
            <h3>Как получить код доступа</h3>
            <ol>
                <li>Вам нужно перейти на сайт <a href="https://www.donationalerts.com/r/andrey291414" target="_blank" style="color: #4FDCFF;">donationalerts.com/r/andrey291414</a> и оплатить 99 Рублей. Если у вас указаны Евро, то поменяйте их на Рубли.</li>
                <li><strong>ВАЖНО:</strong> Когда вы перейдете по ссылке, там будет обязательная инструкция что и как. <strong>ПРОЧТИТЕ ЕЕ ОБЯЗАТЕЛЬНО!!!</strong></li>
                <li>После покупки на вашу почту поступит 6-значный код. Его нужно будет ввести в поле для ввода кода, и тогда вы попадете в игру, и вам больше оплачивать доступ будет не нужно.</li>
            </ol>
            <p>Вы покупаете игру на всю жизнь на этом IP адресе. После покупки и введения кода вам не нужно будет его больше вводить на этом устройстве.</p>
        </div>
    </div>

    <div id="device-selection">
        <h1>Выберите устройство</h1>
        <div class="device-buttons">
            <button class="device-button" id="pc-button">Компьютер / Ноутбук</button>
            <button class="device-button" id="mobile-button">Телефон / Планшет</button>
        </div>
    </div>

    <div id="hud">
        <div>Уровень: <span id="level">1</span></div>
        <div>Очки: <span id="score">0</span></div>
        <div>Здоровье:</div>
        <div id="health-bar"><div id="health-fill"></div></div>
        <div id="ammo">Патроны: <span id="ammo-count">30</span> / <span id="max-ammo">30</span></div>
    </div>
    <div id="crosshair">+</div>
    <div id="hit-marker">×</div>
    <div id="reload-indicator">Перезарядка...</div>
    <div id="objective-indicator">Ваша задача: Найдите ключ</div>
    <div id="item-pickup-notification"></div>
    
    <div id="game-over">
        <h2>Игра окончена</h2>
        <p>Ваш счет: <span id="final-score">0</span></p>
        <button id="restart-button">Начать заново</button>
    </div>
    <div id="level-up">
        <h2>Уровень пройден!</h2>
        <p>Переход на уровень <span id="new-level">2</span></p>
        <p id="level-description">Следующий уровень сложнее. Ищите ключи, открывайте двери и сражайтесь с новыми врагами!</p>
        <button id="next-level-button">Продолжить</button>
    </div>
    
    <div id="quest-notification">
        <h3>Новое задание</h3>
        <p id="quest-description">Найдите ключ, чтобы открыть дверь и продолжить путь</p>
        <button id="accept-quest-button">Принять</button>
    </div>
    
        <div id="objective-complete">
        <h3>Задание выполнено!</h3>
        <p id="objective-description">Вы нашли ключ. Теперь найдите дверь!</p>
        <button id="continue-button">Продолжить</button>
    </div>

    <div id="inventory">
        <div class="inventory-slot" data-slot="1">1</div>
        <div class="inventory-slot active" data-slot="2">2</div>
        <div class="inventory-slot" data-slot="3">3</div>
    </div>

    <div id="mobile-controls">
        <div class="joystick-area">
            <div class="joystick" id="joystick"></div>
        </div>
        <div class="look-area">
            <div class="look-joystick" id="look-joystick"></div>
        </div>
        <div class="action-buttons">
            <div class="action-button" id="shoot-button">🔫</div>
            <div class="action-button" id="jump-button">↑</div>
            <div class="action-button" id="reload-button">↻</div>
            <div class="action-button" id="interact-button">✋</div>
        </div>
        <div class="weapon-switch">
            <div class="weapon-button active" id="weapon-1">1</div>
            <div class="weapon-button" id="weapon-2">2</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Обработка загрузочного экрана и проверки кода
        document.addEventListener('DOMContentLoaded', function() {
            // Анимация загрузочного экрана
            setTimeout(function() {
                document.getElementById('loader').style.opacity = '0';
                setTimeout(function() {
                    document.getElementById('loader').style.display = 'none';
                    document.getElementById('code-check').classList.add('active');
                }, 1000);
            }, 3000);

            // Настройка формы ввода кода
            const codeInputs = document.querySelectorAll('.code-digit');
            const form = document.getElementById('code-form');
            const errorMessage = document.getElementById('error-message');
            
            // Обработка автоперехода между полями ввода
            codeInputs.forEach((input, index) => {
                input.addEventListener('input', function() {
                    if (this.value && index < codeInputs.length - 1) {
                        codeInputs[index + 1].focus();
                    }
                });
                
                input.addEventListener('keydown', function(e) {
                    if (e.key === 'Backspace' && !this.value && index > 0) {
                        codeInputs[index - 1].focus();
                    }
                });
            });
            
            // Проверка кода при отправке формы
            form.addEventListener('submit', function(e) {
                e.preventDefault();
                
                let code = '';
                codeInputs.forEach(input => {
                    code += input.value;
                });
                
                // Проверка кода
                checkCode(code);
            });
            
            // Обработка ссылки помощи
            document.getElementById('help-link').addEventListener('click', function() {
                document.getElementById('instructions').classList.add('active');
            });
            
            // Закрытие инструкций
            document.getElementById('close-instructions').addEventListener('click', function() {
                document.getElementById('instructions').classList.remove('active');
            });
            
            // Функция для проверки кода
            function checkCode(code) {
                // Проверяем код без прямого указания в исходном коде
                const correctCode = atob('MjkxNDE0'); // Закодированный код в base64
                
                if (code === correctCode) {
                    // Сохраняем в localStorage признак того, что код был введен
                    localStorage.setItem('gameAccess', 'true');
                    
                    // Плавное скрытие экрана проверки кода
                    document.getElementById('code-check').style.opacity = '0';
                    setTimeout(function() {
                        document.getElementById('code-check').style.display = 'none';
                        // Показ экрана выбора устройства
                        document.getElementById('device-selection').style.display = 'flex';
                    }, 700);
                } else {
                    // Показ сообщения об ошибке
                    errorMessage.textContent = 'Неверный код доступа. Пожалуйста, попробуйте снова.';
                    errorMessage.style.opacity = '1';
                    
                    // Очистка полей ввода
                    codeInputs.forEach(input => {
                        input.value = '';
                    });
                    codeInputs[0].focus();
                    
                    // Анимация тряски формы
                    form.classList.add('shake');
                    setTimeout(function() {
                        form.classList.remove('shake');
                    }, 600);
                }
            }
            
            // Проверяем, был ли ранее введен правильный код
            if (localStorage.getItem('gameAccess') === 'true') {
                document.getElementById('loader').style.opacity = '0';
                setTimeout(function() {
                    document.getElementById('loader').style.display = 'none';
                    document.getElementById('code-check').style.display = 'none';
                    document.getElementById('device-selection').style.display = 'flex';
                }, 1000);
            }
        });

        // Основные переменные
        let scene, camera, renderer, player, controls;
        let enemies = [];
        let bullets = [];
        let enemyBullets = [];
        let walls = [];
        let floor;
        let raycaster;
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let canJump = false;
        let isShooting = false;
        let isCrouching = false;
        let isRunning = false;
        let health = 100;
        let score = 0;
        let level = 1;
        let ammo = 30;
        let maxAmmo = 30;
        let reloading = false;
        let gameOver = false;
        let levelCompleted = false;
        let isMobile = false;
        let joystickPosition = { x: 0, y: 0 };
        let lookJoystickPosition = { x: 0, y: 0 };
        let touchLookPosition = { x: 0, y: 0 };
        let lastTouchLookPosition = { x: 0, y: 0 };
        let touchShootId = null;
        let clock = new THREE.Clock();
        let deltaTime = 0;
        let targetEnemy = null;
        let enemyHelpers = [];
        let skybox;
        let textures = {};
        let sounds = {};
        let particleSystems = [];
        let platforms = [];
        let collectibles = [];
        let hasCollectibleKey = false;
        let secretDoors = [];
        let currentCheckpoint = null;
        let currentWeapon = 1;
        let weapons = [
            { name: "Пистолет", damage: 25, ammo: 30, maxAmmo: 30, shootInterval: 200, automatic: false },
            { name: "Автомат", damage: 15, ammo: 45, maxAmmo: 45, shootInterval: 100, automatic: true }
        ];
        let playerInventory = [];
        let currentQuest = null;
        let headbobTimer = 0;
        let headbobAmount = 0.05;
        let headbobSpeed = 10;
        let isPlayerMoving = false;
        let objectives = [];
        let doors = [];
        let keys = [];
        let currentObjective = null;
        let bosses = [];
        
        // Константы
        const ENEMY_COUNT_BASE = 5;
        const LEVEL_SIZE_BASE = 100;
        const ENEMY_SPEED_BASE = 0.05;
        const PLAYER_SPEED = 0.15;
        const RUNNING_SPEED = 0.25;
        const GRAVITY = 0.005;
        const JUMP_FORCE = 0.2;
        const AUTO_AIM_DISTANCE = 20;
        const AUTO_AIM_ANGLE = 0.3;
        
        // Предопределенные уровни и задания
        const LEVELS = [
            {
                name: "Обучение",
                description: "Изучите основы управления и уничтожьте врагов.",
                objectives: [
                    { type: "key", description: "Найдите ключ для продолжения" },
                    { type: "door", description: "Найдите и откройте дверь ключом" },
                    { type: "kill", description: "Уничтожьте всех врагов", count: 5 }
                ]
            },
            {
                name: "Лабиринт",
                description: "Найдите путь через лабиринт и соберите все ключи.",
                objectives: [
                    { type: "collect", description: "Соберите 3 ключа", count: 3 },
                    { type: "door", description: "Найдите тайный проход" },
                    { type: "kill", description: "Уничтожьте продвинутых врагов", count: 8 }
                ]
            },
            {
                name: "Крепость",
                description: "Проберитесь через крепость и найдите оружие.",
                objectives: [
                    { type: "weapon", description: "Найдите автомат" },
                    { type: "kill", description: "Уничтожьте охранников", count: 10 },
                    { type: "boss", description: "Победите босса крепости" }
                ]
            },
            {
                name: "Подземелье",
                description: "Исследуйте подземелье и найдите все секреты.",
                objectives: [
                    { type: "collect", description: "Соберите 5 артефактов", count: 5 },
                    { type: "platform", description: "Преодолейте платформы над лавой" },
                    { type: "boss", description: "Победите финального босса" }
                ]
            }
        ];
        
        // Выбор устройства
        document.getElementById('pc-button').addEventListener('click', function() {
            isMobile = false;
            document.getElementById('device-selection').style.display = 'none';
            init();
        });
        
        document.getElementById('mobile-button').addEventListener('click', function() {
            isMobile = true;
            document.getElementById('device-selection').style.display = 'none';
            document.getElementById('mobile-controls').style.display = 'block';
            init();
        });
        
        // Предзагрузка текстур
        function preloadTextures() {
            const textureLoader = new THREE.TextureLoader();
            
            // Загрузка текстур
            textures.ground = textureLoader.load('https://threejs.org/examples/textures/floors/FloorsCheckerboard_S_Diffuse.jpg', function(texture) {
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(10, 10);
            });
            
            textures.wall = textureLoader.load('https://threejs.org/examples/textures/brick_diffuse.jpg', function(texture) {
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(2, 2);
            });
            
            textures.metal = textureLoader.load('https://threejs.org/examples/textures/metal.jpg', function(texture) {
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(1, 1);
            });
            
            textures.wood = textureLoader.load('https://threejs.org/examples/textures/wood.jpg', function(texture) {
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(1, 1);
            });
            
            textures.enemy = textureLoader.load('https://threejs.org/examples/textures/uv_grid_opengl.jpg');
            
            // Загрузка кубической текстуры для skybox
            const cubeTextureLoader = new THREE.CubeTextureLoader();
            textures.skybox = cubeTextureLoader.load([
                'https://threejs.org/examples/textures/cube/skybox/px.jpg',
                'https://threejs.org/examples/textures/cube/skybox/nx.jpg',
                'https://threejs.org/examples/textures/cube/skybox/py.jpg',
                'https://threejs.org/examples/textures/cube/skybox/ny.jpg',
                'https://threejs.org/examples/textures/cube/skybox/pz.jpg',
                'https://threejs.org/examples/textures/cube/skybox/nz.jpg'
            ]);
            
            // Дополнительные текстуры для разнообразных поверхностей
            textures.lava = textureLoader.load('https://threejs.org/examples/textures/lava/lavatile.jpg', function(texture) {
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(5, 5);
            });
            
            textures.grass = textureLoader.load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg', function(texture) {
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(10, 10);
            });
            
            textures.crate = textureLoader.load('https://threejs.org/examples/textures/crate.gif');
        }
        
        // Инициализация игры
        function init() {
            // Предзагрузка текстур
            preloadTextures();
            
            // Создание сцены
            scene = new THREE.Scene();
            scene.background = textures.skybox || new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 0, 500);
            
            // Создание камеры
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = 2;
            
            // Создание рендерера с антиалиасингом для лучшей графики
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                powerPreference: "high-performance" 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio > 2 ? 2 : window.devicePixelRatio); // Ограничение для оптимизации
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Мягкие тени
            document.body.appendChild(renderer.domElement);
            
            // Добавление освещения
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(100, 100, 100);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            scene.add(directionalLight);
            
            // Добавление точечных источников света для более реалистичного освещения
            const pointLight1 = new THREE.PointLight(0xffaa00, 1, 50);
            pointLight1.position.set(10, 15, 10);
            pointLight1.castShadow = true;
            scene.add(pointLight1);
            
            const pointLight2 = new THREE.PointLight(0x0044ff, 1, 50);
            pointLight2.position.set(-10, 15, -10);
            pointLight2.castShadow = true;
            scene.add(pointLight2);
            
            // Создание игрока (камера + управление)
            player = new THREE.Object3D();
            player.position.set(0, 2, 0);
            player.add(camera);
            scene.add(player);
            
            // Физика игрока
            player.velocity = new THREE.Vector3();
            player.direction = new THREE.Vector3();
            
            // Инициализация рейкастера для обнаружения коллизий
            raycaster = new THREE.Raycaster();
            
            // Создание уровня
            createLevel();
            
            // Настройка управления в зависимости от устройства
            if (isMobile) {
                setupMobileControls();
            } else {
                setupPCControls();
            }
            
            // Обработка изменения размера окна
            window.addEventListener('resize', onWindowResize, false);
            
            // Инициализация инвентаря
            setupInventory();
            
            // Показ первого задания
            showObjective(LEVELS[level-1].objectives[0]);
            
            // Запуск игрового цикла
            animate();
        }
        
        // Настройка инвентаря
        function setupInventory() {
            const inventorySlots = document.querySelectorAll('.inventory-slot');
            
            inventorySlots.forEach(slot => {
                slot.addEventListener('click', function() {
                    const slotNum = parseInt(slot.getAttribute('data-slot'));
                    switchWeapon(slotNum);
                });
            });
            
            // Установка начального оружия
            switchWeapon(1);
        }
        
        // Переключение оружия
        function switchWeapon(weaponNum) {
            if (weaponNum < 1 || weaponNum > weapons.length || weaponNum === currentWeapon) return;
            
            // Обновление UI
            document.querySelectorAll('.inventory-slot').forEach(slot => {
                slot.classList.remove('active');
            });
            
            document.querySelector(`.inventory-slot[data-slot="${weaponNum}"]`).classList.add('active');
            
            if (isMobile) {
                document.querySelectorAll('.weapon-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.getElementById(`weapon-${weaponNum}`).classList.add('active');
            }
            
            // Обновление текущего оружия
            currentWeapon = weaponNum;
            ammo = weapons[currentWeapon - 1].ammo;
            maxAmmo = weapons[currentWeapon - 1].maxAmmo;
            
            // Обновление UI патронов
            document.getElementById('ammo-count').textContent = ammo;
            document.getElementById('max-ammo').textContent = maxAmmo;
            
            // Показ уведомления о смене оружия
            showItemPickupNotification(`Выбрано: ${weapons[currentWeapon - 1].name}`);
        }
        
        // Показ уведомления о подборе предмета
        function showItemPickupNotification(message) {
            const notification = document.getElementById('item-pickup-notification');
            notification.textContent = message;
            notification.style.opacity = '1';
            
            setTimeout(() => {
                notification.style.opacity = '0';
            }, 2000);
        }
        
        // Показ задания
        function showObjective(objective) {
            currentObjective = objective;
            
            const indicator = document.getElementById('objective-indicator');
            indicator.textContent = `Задача: ${objective.description}`;
            indicator.classList.add('active');
            
            // Показ модального окна с заданием
            const notification = document.getElementById('quest-notification');
            const description = document.getElementById('quest-description');
            description.textContent = objective.description;
            notification.style.display = 'block';
            
            document.getElementById('accept-quest-button').addEventListener('click', function() {
                notification.style.display = 'none';
            }, { once: true });
        }
        
        // Завершение задания
        function completeObjective() {
            const notification = document.getElementById('objective-complete');
            const description = document.getElementById('objective-description');
            description.textContent = `Вы выполнили задание: ${currentObjective.description}`;
            notification.style.display = 'block';
            
            // Увеличение счета
            score += 200;
            document.getElementById('score').textContent = score;
            
            document.getElementById('continue-button').addEventListener('click', function() {
                notification.style.display = 'none';
                
                // Переход к следующему заданию
                const levelData = LEVELS[level-1];
                const currentIndex = levelData.objectives.indexOf(currentObjective);
                
                if (currentIndex < levelData.objectives.length - 1) {
                    showObjective(levelData.objectives[currentIndex + 1]);
                } else {
                    levelComplete();
                }
            }, { once: true });
            
            // Скрытие индикатора задания
            document.getElementById('objective-indicator').classList.remove('active');
        }
        
        // Настройка управления для ПК
        function setupPCControls() {
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);
            document.addEventListener('mousedown', onMouseDown, false);
            document.addEventListener('mouseup', onMouseUp, false);
            
            // Блокировка указателя мыши
            renderer.domElement.addEventListener('click', function() {
                renderer.domElement.requestPointerLock();
            });
            
            document.addEventListener('pointerlockchange', lockChangeAlert, false);
            
            // Переключение оружия на клавиши 1-9
            document.addEventListener('keydown', function(e) {
                if (e.key >= '1' && e.key <= '9') {
                    const weaponNum = parseInt(e.key);
                    if (weaponNum <= weapons.length) {
                        switchWeapon(weaponNum);
                    }
                }
                
                // Взаимодействие на клавишу E
                if (e.key === 'e' || e.key === 'E') {
                    interact();
                }
            });
        }
        
        // Функция взаимодействия с объектами
        function interact() {
            // Проверка на близость к дверям, которые можно открыть ключом
            if (hasCollectibleKey) {
                for (const door of secretDoors) {
                    if (!door.isOpen) {
                        const distance = player.position.distanceTo(door.position);
                        if (distance < 5) {
                            openDoor(door);
                            // Проверка на завершение задания
                            if (currentObjective && currentObjective.type === 'door') {
                                completeObjective();
                            }
                            break;
                        }
                    }
                }
            }
            
            // Проверка близости к коллектиблам
            for (let i = collectibles.length - 1; i >= 0; i--) {
                const collectible = collectibles[i];
                const distance = player.position.distanceTo(collectible.position);
                
                if (distance < 3) {
                    collectItem(collectible);
                    scene.remove(collectible);
                    collectibles.splice(i, 1);
                    break;
                }
            }
        }
        
        // Открытие двери
        function openDoor(door) {
            if (!door.isOpen) {
                // Открытие двери
                door.isOpen = true;
                
                // Анимация открытия двери - плавное опускание
                const targetY = door.position.y - door.geometry.parameters.height;
                
                // Создаем простую анимацию вместо использования библиотеки анимации
                door.animation = {
                    startY: door.position.y,
                    targetY: targetY,
                    progress: 0,
                    speed: 0.02
                };
                
                // Удаляем дверь из массива стен, чтобы игрок мог пройти
                const doorIndex = walls.indexOf(door);
                if (doorIndex !== -1) {
                    walls.splice(doorIndex, 1);
                }
                
                // Уведомление
                showItemPickupNotification("Дверь открыта!");
                
                // Звуковой эффект
                // playSound('door');
            }
        }
        
        // Настройка управления для мобильных устройств
        function setupMobileControls() {
            // Настройка джойстика для движения
            const joystickArea = document.querySelector('.joystick-area');
            const joystick = document.getElementById('joystick');
            
            joystickArea.addEventListener('touchstart', function(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = joystickArea.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                updateJoystickPosition(touch.clientX - centerX, touch.clientY - centerY);
            });
            
            joystickArea.addEventListener('touchmove', function(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = joystickArea.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                updateJoystickPosition(touch.clientX - centerX, touch.clientY - centerY);
            });
            
            joystickArea.addEventListener('touchend', function(e) {
                e.preventDefault();
                resetJoystick();
            });
            
            // Настройка джойстика для обзора
            const lookArea = document.querySelector('.look-area');
            const lookJoystick = document.getElementById('look-joystick');
            
            lookArea.addEventListener('touchstart', function(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = lookArea.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                lastTouchLookPosition.x = touch.clientX;
                lastTouchLookPosition.y = touch.clientY;
                touchLookPosition.x = touch.clientX;
                touchLookPosition.y = touch.clientY;
                
                updateLookJoystickPosition(touch.clientX - centerX, touch.clientY - centerY);
            });
            
            lookArea.addEventListener('touchmove', function(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = lookArea.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                touchLookPosition.x = touch.clientX;
                touchLookPosition.y = touch.clientY;
                
                updateLookJoystickPosition(touch.clientX - centerX, touch.clientY - centerY);
            });
            
            lookArea.addEventListener('touchend', function(e) {
                e.preventDefault();
                resetLookJoystick();
            });
            
            // Настройка кнопок действий
            document.getElementById('shoot-button').addEventListener('touchstart', function(e) {
                e.preventDefault();
                isShooting = true;
                shoot();
                touchShootId = setInterval(shoot, weapons[currentWeapon - 1].shootInterval);
            });
            
            document.getElementById('shoot-button').addEventListener('touchend', function(e) {
                e.preventDefault();
                isShooting = false;
                if (touchShootId !== null) {
                    clearInterval(touchShootId);
                    touchShootId = null;
                }
            });
            
            document.getElementById('jump-button').addEventListener('touchstart', function(e) {
                e.preventDefault();
                if (canJump) {
                    player.velocity.y = JUMP_FORCE;
                    canJump = false;
                }
            });
            
            document.getElementById('reload-button').addEventListener('touchstart', function(e) {
                e.preventDefault();
                reload();
            });
            
            document.getElementById('interact-button').addEventListener('touchstart', function(e) {
                e.preventDefault();
                interact();
            });
            
            // Кнопки выбора оружия
            document.getElementById('weapon-1').addEventListener('touchstart', function(e) {
                e.preventDefault();
                switchWeapon(1);
            });
            
            document.getElementById('weapon-2').addEventListener('touchstart', function(e) {
                e.preventDefault();
                switchWeapon(2);
            });
        }
        
        function updateJoystickPosition(x, y) {
            const maxDistance = 40;
            const distance = Math.sqrt(x * x + y * y);
            
            if (distance > maxDistance) {
                const ratio = maxDistance / distance;
                x *= ratio;
                y *= ratio;
            }
            
            joystick.style.transform = `translate(${x}px, ${y}px)`;
            
            // Нормализация значений для движения
            joystickPosition.x = x / maxDistance;
            joystickPosition.y = y / maxDistance;
            
            // Установка флагов движения
            moveForward = joystickPosition.y < -0.2;  // Вперед при перемещении джойстика вверх
            moveBackward = joystickPosition.y > 0.2;  // Назад при перемещении джойстика вниз
            moveLeft = joystickPosition.x < -0.2;     // Влево при перемещении джойстика влево
            moveRight = joystickPosition.x > 0.2;     // Вправо при перемещении джойстика вправо
        }
        
        function resetJoystick() {
            joystick.style.transform = 'translate(0, 0)';
            joystickPosition.x = 0;
            joystickPosition.y = 0;
            moveForward = false;
            moveBackward = false;
            moveLeft = false;
            moveRight = false;
        }
        
        function updateLookJoystickPosition(x, y) {
            const maxDistance = 40;
            const distance = Math.sqrt(x * x + y * y);
            
            if (distance > maxDistance) {
                const ratio = maxDistance / distance;
                x *= ratio;
                y *= ratio;
            }
            
            lookJoystick.style.transform = `translate(${x}px, ${y}px)`;
            
            // Нормализация значений для поворота камеры
            lookJoystickPosition.x = x / maxDistance;
            lookJoystickPosition.y = y / maxDistance;
            
            // Поворот камеры
            player.rotation.y -= lookJoystickPosition.x * 0.1;
            camera.rotation.x -= lookJoystickPosition.y * 0.05;
            camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
        }
        
        function resetLookJoystick() {
            lookJoystick.style.transform = 'translate(0, 0)';
            lookJoystickPosition.x = 0;
            lookJoystickPosition.y = 0;
        }
        
        // Создание уровня
        function createLevel() {
            // Очистка предыдущего уровня
            while(scene.children.length > 0){ 
                scene.remove(scene.children[0]); 
            }
            
            enemies = [];
            bullets = [];
            enemyBullets = [];
            walls = [];
            enemyHelpers = [];
            particleSystems = [];
            platforms = [];
            collectibles = [];
            secretDoors = [];
            doors = [];
            keys = [];
            bosses = [];
            hasCollectibleKey = false;
            
            // Добавление игрока и освещения обратно на сцену
            scene.add(player);
            
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(100, 100, 100);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // Добавление точечных источников света
            const pointLight1 = new THREE.PointLight(0xffaa00, 1, 50);
            pointLight1.position.set(10, 15, 10);
            pointLight1.castShadow = true;
            scene.add(pointLight1);
            
            const pointLight2 = new THREE.PointLight(0x0044ff, 1, 50);
            pointLight2.position.set(-10, 15, -10);
            pointLight2.castShadow = true;
            scene.add(pointLight2);
            
            // Создание skybox
            if (textures.skybox) {
                scene.background = textures.skybox;
            }
            
            // Размер уровня растет с каждым уровнем
            const levelSize = LEVEL_SIZE_BASE + (level * 20);
            
            // Создание пола с текстурой
            const floorGeometry = new THREE.PlaneGeometry(levelSize, levelSize, 10, 10);
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                map: textures.ground,
                roughness: 0.8,
                metalness: 0.2
            });
            floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);
            
            // Создание стен
            createWalls(levelSize);
            
            // Создание различных уровней в зависимости от текущего уровня
            switch(level) {
                case 1:
                    createTutorialLevel(levelSize);
                    break;
                case 2:
                    createMazeLevel(levelSize);
                    break;
                case 3:
                    createFortressLevel(levelSize);
                    break;
                case 4:
                    createDungeonLevel(levelSize);
                    break;
                default:
                    createAdvancedLevel(levelSize);
            }
            
            // Сброс позиции игрока и установка на стартовую точку
            player.position.set(0, 2, 0);
            player.velocity.set(0, 0, 0);
            
            // Обновление HUD
            document.getElementById('level').textContent = level;
            document.getElementById('score').textContent = score;
            updateHealthBar();
            
            // Сброс патронов
            ammo = weapons[currentWeapon - 1].ammo;
            maxAmmo = weapons[currentWeapon - 1].maxAmmo;
            document.getElementById('ammo-count').textContent = ammo;
            document.getElementById('max-ammo').textContent = maxAmmo;
            
            // Показать текущее задание
            if (LEVELS[level-1] && LEVELS[level-1].objectives.length > 0) {
                showObjective(LEVELS[level-1].objectives[0]);
            }
        }
        
        // Создание стен вокруг уровня
        function createWalls(size) {
            const wallHeight = 10;
            const wallThickness = 2;
            const halfSize = size / 2;
            
            const wallMaterial = new THREE.MeshStandardMaterial({ 
                map: textures.wall,
                roughness: 0.7,
                metalness: 0.2,
                bumpMap: textures.wall,
                bumpScale: 0.02
            });
            
            // Северная стена
            const northWallGeometry = new THREE.BoxGeometry(size + wallThickness * 2, wallHeight, wallThickness);
            const northWall = new THREE.Mesh(northWallGeometry, wallMaterial);
            northWall.position.set(0, wallHeight / 2, -halfSize - wallThickness / 2);
            northWall.castShadow = true;
            northWall.receiveShadow = true;
            scene.add(northWall);
            walls.push(northWall);
            
            // Южная стена
            const southWall = northWall.clone();
            southWall.position.z = halfSize + wallThickness / 2;
            scene.add(southWall);
            walls.push(southWall);
            
            // Восточная стена
            const eastWallGeometry = new THREE.BoxGeometry(wallThickness, wallHeight, size);
            const eastWall = new THREE.Mesh(eastWallGeometry, wallMaterial);
            eastWall.position.set(halfSize + wallThickness / 2, wallHeight / 2, 0);
            eastWall.castShadow = true;
            eastWall.receiveShadow = true;
            scene.add(eastWall);
            walls.push(eastWall);
            
            // Западная стена
            const westWall = eastWall.clone();
            westWall.position.x = -halfSize - wallThickness / 2;
            scene.add(westWall);
            walls.push(westWall);
        }
        
        // Создание обучающего уровня
        function createTutorialLevel(size) {
            const halfSize = size / 2 - 5;
            
            // Создание платформ для обучения прыжкам
            createPlatform(10, 1, 10, 0, 0, -15, 0x4d4dff);
            createPlatform(8, 1, 8, 0, 2, -25, 0x4d7fff);
            createPlatform(6, 1, 6, 0, 4, -35, 0x4db8ff);
            
            // Создание нескольких препятствий
            createObstacle(5, 3, 2, -10, 1.5, 10, 0x8c8c8c);
            createObstacle(5, 3, 2, 10, 1.5, 10, 0x8c8c8c);
            
            // Создание ключа-коллектибла
            createCollectible(0, 1, -40, 'key');
            
            // Создание секретной двери, которая открывается ключом
            createSecretDoor(15, 5, 2, 20, 2.5, 0, 0x7d4d4d);
            
            // Создание контрольной точки
            createCheckpoint(0, 0, -15);
            
            // Создание предметов для обучения
            createCollectible(-15, 1, 15, 'ammo');
            createCollectible(15, 1, 15, 'health');
            
            // Создание обучающих врагов
            for (let i = 0; i < 5; i++) {
                const x = Math.random() * 30 - 15;
                const z = Math.random() * 30 - 40;
                createEnemy(x, 0, z, 'basic');
            }
            
            // Создание тренировочной зоны для стрельбы
            createShootingRange(30, 20, -20);
        }
        
        // Создание стрельбища для обучения
        function createShootingRange(x, z, radius) {
            // Основание стрельбища
            const baseGeometry = new THREE.CylinderGeometry(radius, radius, 0.5, 16);
            const baseMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333,
                roughness: 0.8,
                metalness: 0.2
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.set(x, 0.25, z);
            base.receiveShadow = true;
            scene.add(base);
            
            // Создание мишеней
            for (let i = 0; i < 5; i++) {
                const angle = (i / 5) * Math.PI * 2;
                const targetX = x + Math.cos(angle) * (radius - 5);
                const targetZ = z + Math.sin(angle) * (radius - 5);
                
                createTarget(targetX, 3, targetZ);
            }
        }
        
        // Создание мишени
        function createTarget(x, y, z) {
            const targetGroup = new THREE.Group();
            
            // Опора мишени
            const standGeometry = new THREE.BoxGeometry(0.5, 6, 0.5);
            const standMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.8,
                metalness: 0.1,
                map: textures.wood
            });
            const stand = new THREE.Mesh(standGeometry, standMaterial);
            stand.position.y = 3;
            stand.castShadow = true;
            stand.receiveShadow = true;
            targetGroup.add(stand);
            
            // Мишень
            const targetGeometry = new THREE.CylinderGeometry(1.5, 1.5, 0.2, 16);
            const targetMaterial = new THREE.MeshStandardMaterial({
                color: 0xff0000,
                roughness: 0.5,
                metalness: 0.3
            });
            const target = new THREE.Mesh(targetGeometry, targetMaterial);
            target.rotation.x = Math.PI / 2;
            target.position.set(0, y, 0);
            target.castShadow = true;
            target.receiveShadow = true;
            targetGroup.add(target);
            
            // Центр мишени
            const centerGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.22, 16);
            const centerMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 0.5,
                metalness: 0.3
            });
            const center = new THREE.Mesh(centerGeometry, centerMaterial);
            center.rotation.x = Math.PI / 2;
            center.position.set(0, y, 0.01);
            center.castShadow = true;
            targetGroup.add(center);
            
            targetGroup.position.set(x, 0, z);
            targetGroup.isTarget = true;
            targetGroup.targetHealth = 100;
            scene.add(targetGroup);
            
            return targetGroup;
        }
        
        // Создание уровня с лабиринтом
        function createMazeLevel(size) {
            const halfSize = size / 2 - 10;
            const wallHeight = 4;
            const wallThickness = 2;
            const corridorWidth = 6;
            
            // Создание стенок лабиринта
            const mazeMaterial = new THREE.MeshStandardMaterial({ 
                map: textures.wall,
                roughness: 0.8,
                metalness: 0.2
            });
            
            // Создание сложного лабиринта
            const mazeSize = 5;  // 5x5 ячеек
            const cellSize = 15;  // размер ячейки
            
            // Двумерный массив для представления лабиринта
            // 0 - проход, 1 - стена
            const maze = createMazeLayout(mazeSize);
            
            // Строим стены лабиринта
            for (let i = 0; i < mazeSize; i++) {
                for (let j = 0; j < mazeSize; j++) {
                    if (maze[i][j] === 1) {
                        // Вычисляем позицию ячейки в 3D пространстве
                        const x = (i - Math.floor(mazeSize/2)) * cellSize;
                        const z = (j - Math.floor(mazeSize/2)) * cellSize;
                        
                        const wallGeometry = new THREE.BoxGeometry(cellSize, wallHeight, cellSize);
                        const wall = new THREE.Mesh(wallGeometry, mazeMaterial);
                        wall.position.set(x, wallHeight/2, z);
                        wall.castShadow = true;
                        wall.receiveShadow = true;
                        scene.add(wall);
                        walls.push(wall);
                    }
                }
            }
            
            // Создание ключей в лабиринте
            for (let i = 0; i < 3; i++) {
                let keyPlaced = false;
                
                while (!keyPlaced) {
                    const cellX = Math.floor(Math.random() * mazeSize);
                    const cellZ = Math.floor(Math.random() * mazeSize);
                    
                    if (maze[cellX][cellZ] === 0) {
                        const x = (cellX - Math.floor(mazeSize/2)) * cellSize;
                        const z = (cellZ - Math.floor(mazeSize/2)) * cellSize;
                        
                        createCollectible(x, 1, z, 'key');
                        keyPlaced = true;
                    }
                }
            }
            
            // Создание выхода из лабиринта
            createSecretDoor(10, 5, 2, halfSize - 5, 2.5, halfSize - 5, 0x7d4d4d);
            
            // Создание врагов в лабиринте
            for (let i = 0; i < 8; i++) {
                let enemyPlaced = false;
                
                while (!enemyPlaced) {
                    const cellX = Math.floor(Math.random() * mazeSize);
                    const cellZ = Math.floor(Math.random() * mazeSize);
                    
                    if (maze[cellX][cellZ] === 0) {
                        const x = (cellX - Math.floor(mazeSize/2)) * cellSize;
                        const z = (cellZ - Math.floor(mazeSize/2)) * cellSize;
                        
                        // Не создавать врагов рядом с игроком
                        if (Math.abs(x) > 20 || Math.abs(z) > 20) {
                            createEnemy(x, 0, z, 'maze');
                            enemyPlaced = true;
                        }
                    }
                }
            }
            
            // Создание контрольных точек
            createCheckpoint(0, 0, 0);
        }
        
        // Создание шаблона лабиринта
        function createMazeLayout(size) {
            // Инициализируем все ячейки как стены
            const maze = Array(size).fill().map(() => Array(size).fill(1));
            
            // Рекурсивное деление для создания лабиринта
            function divide(x, y, width, height, orientation) {
                if (width < 2 || height < 2) return;
                
                // Выбираем случайную точку для стены
                let wx = x + (orientation ? 0 : Math.floor(Math.random() * (width - 1)));
                let wy = y + (orientation ? Math.floor(Math.random() * (height - 1)) : 0);
                
                // Выбираем случайную точку для прохода
                let px = wx + (orientation ? Math.floor(Math.random() * width) : 0);
                let py = wy + (orientation ? 0 : Math.floor(Math.random() * height));
                
                // Размер стены
                let wallWidth = orientation ? width : 1;
                let wallHeight = orientation ? 1 : height;
                
                // Создаем проходы
                for (let i = 0; i < wallWidth; i++) {
                    for (let j = 0; j < wallHeight; j++) {
                        if ((wx + i !== px || wy + j !== py) && wx + i < size && wy + j < size) {
                            maze[wx + i][wy + j] = 0;
                        }
                    }
                }
                
                // Рекурсивно делим дальше
                const nx = orientation ? x : wx + 1;
                const ny = orientation ? wy + 1 : y;
                const nWidth = orientation ? width : x + width - nx;
                const nHeight = orientation ? y + height - ny : height;
                
                divide(x, y, orientation ? width : wx - x + 1, orientation ? wy - y + 1 : height, !orientation);
                divide(nx, ny, nWidth, nHeight, !orientation);
            }
            
            // Начинаем с проходов
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    maze[i][j] = 0;
                }
            }
            
            // Создаем внешние стены
            for (let i = 0; i < size; i++) {
                maze[0][i] = 1;
                maze[size-1][i] = 1;
                maze[i][0] = 1;
                maze[i][size-1] = 1;
            }
            
            // Стартуем рекурсивное деление
            divide(1, 1, size-2, size-2, Math.random() < 0.5);
            
            // Создаем вход и выход
            maze[1][1] = 0; // Вход
            maze[size-2][size-2] = 0; // Выход
            
            return maze;
        }
        
        // Создание уровня с крепостью
        function createFortressLevel(size) {
            const halfSize = size / 2 - 10;
            const wallHeight = 8;
            const wallThickness = 3;
            
            // Изменение текстуры пола
            floor.material.map = textures.grass;
            floor.material.needsUpdate = true;
            
            // Создание крепости
            createFortress(0, 0, 50, wallHeight, wallThickness);
            
            // Создание внешних укреплений
            createFortressWalls(0, 0, 80, wallHeight-2, wallThickness);
            
            // Создание оружия для сбора
            createWeaponPickup(20, 1, -20);
            
            // Создание охранников крепости
            for (let i = 0; i < 10; i++) {
                let x, z;
                
                if (i < 5) {
                    // Внутри крепости
                    x = Math.random() * 30 - 15;
                    z = Math.random() * 30 - 15;
                } else {
                    // Вокруг крепости
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 60 + Math.random() * 15;
                    x = Math.cos(angle) * radius;
                    z = Math.sin(angle) * radius;
                }
                
                createEnemy(x, 0, z, 'guard');
            }
            
            // Создание босса крепости
            createBoss(0, 0, 0);
            
            // Создание бонусов здоровья и патронов
            createCollectible(-25, 1, 25, 'health');
            createCollectible(25, 1, 25, 'ammo');
            createCollectible(-25, 1, -25, 'health');
            createCollectible(25, 1, -25, 'ammo');
            
            // Создание контрольных точек
            createCheckpoint(0, 0, 70);
        }
        
        // Создание крепости
        function createFortress(centerX, centerZ, size, height, thickness) {
            const halfSize = size / 2;
            
            // Материал крепости
            const fortressMaterial = new THREE.MeshStandardMaterial({ 
                map: textures.wall,
                roughness: 0.8,
                metalness: 0.2
            });
            
            // Стены крепости
            const walls = [
                // Северная стена с воротами
                { x: centerX, z: centerZ - halfSize, width: size, depth: thickness, hasGate: true },
                // Южная стена
                { x: centerX, z: centerZ + halfSize, width: size, depth: thickness, hasGate: false },
                // Восточная стена
                { x: centerX + halfSize, z: centerZ, width: thickness, depth: size, hasGate: false },
                // Западная стена
                { x: centerX - halfSize, z: centerZ, width: thickness, depth: size, hasGate: false }
            ];
            
            // Создание стен
            for (const wallData of walls) {
                if (wallData.hasGate) {
                    // Стена с воротами
                    const gateWidth = 10;
                    const sideWidth = (wallData.width - gateWidth) / 2;
                    
                    // Левая часть стены
                    const leftWallGeometry = new THREE.BoxGeometry(sideWidth, height, wallData.depth);
                    const leftWall = new THREE.Mesh(leftWallGeometry, fortressMaterial);
                    leftWall.position.set(
                        wallData.x - gateWidth/2 - sideWidth/2, 
                        height/2, 
                        wallData.z
                    );
                    leftWall.castShadow = true;
                    leftWall.receiveShadow = true;
                    scene.add(leftWall);
                    this.walls.push(leftWall);
                    
                    // Правая часть стены
                    const rightWallGeometry = new THREE.BoxGeometry(sideWidth, height, wallData.depth);
                    const rightWall = new THREE.Mesh(rightWallGeometry, fortressMaterial);
                    rightWall.position.set(
                        wallData.x + gateWidth/2 + sideWidth/2, 
                        height/2, 
                        wallData.z
                    );
                    rightWall.castShadow = true;
                    rightWall.receiveShadow = true;
                    scene.add(rightWall);
                    this.walls.push(rightWall);
                    
                    // Верхняя часть ворот
                    const gateTopGeometry = new THREE.BoxGeometry(gateWidth, height/3, wallData.depth);
                    const gateTop = new THREE.Mesh(gateTopGeometry, fortressMaterial);
                    gateTop.position.set(
                        wallData.x, 
                        height - height/6, 
                        wallData.z
                    );
                    gateTop.castShadow = true;
                    gateTop.receiveShadow = true;
                    scene.add(gateTop);
                    this.walls.push(gateTop);
                } else {
                    // Обычная стена
                    const wallGeometry = new THREE.BoxGeometry(wallData.width, height, wallData.depth);
                    const wall = new THREE.Mesh(wallGeometry, fortressMaterial);
                    wall.position.set(
                        wallData.x, 
                        height/2, 
                        wallData.z
                    );
                    wall.castShadow = true;
                    wall.receiveShadow = true;
                    scene.add(wall);
                    this.walls.push(wall);
                }
            }
            
            // Создание башен в углах
            const towerRadius = thickness * 1.5;
            const towerHeight = height * 1.3;
            const towers = [
                { x: centerX - halfSize, z: centerZ - halfSize }, // Северо-западная
                { x: centerX + halfSize, z: centerZ - halfSize }, // Северо-восточная
                { x: centerX - halfSize, z: centerZ + halfSize }, // Юго-западная
                { x: centerX + halfSize, z: centerZ + halfSize }  // Юго-восточная
            ];
            
            for (const towerData of towers) {
                const towerGeometry = new THREE.CylinderGeometry(towerRadius, towerRadius, towerHeight, 16);
                const tower = new THREE.Mesh(towerGeometry, fortressMaterial);
                tower.position.set(
                    towerData.x, 
                    towerHeight/2, 
                    towerData.z
                );
                tower.castShadow = true;
                tower.receiveShadow = true;
                scene.add(tower);
                this.walls.push(tower);
                
                // Крыша башни
                const roofGeometry = new THREE.ConeGeometry(towerRadius*1.2, towerHeight/2, 16);
                const roofMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x882222,
                    roughness: 0.7,
                    metalness: 0.3
                });
                const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                roof.position.set(
                    towerData.x, 
                    towerHeight + towerHeight/4, 
                    towerData.z
                );
                roof.castShadow = true;
                scene.add(roof);
            }
            
            // Создание внутренних зданий
            const buildingCount = 3;
            const buildingSize = 10;
            
            for (let i = 0; i < buildingCount; i++) {
                const offsetX = (i - 1) * 15;
                
                const buildingGeometry = new THREE.BoxGeometry(buildingSize, height*0.7, buildingSize);
                const buildingMaterial = new THREE.MeshStandardMaterial({ 
                    map: textures.wood,
                    roughness: 0.7,
                    metalness: 0.2
                });
                const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                building.position.set(
                    centerX + offsetX, 
                    height*0.7/2, 
                    centerZ + 10
                );
                building.castShadow = true;
                building.receiveShadow = true;
                scene.add(building);
                this.walls.push(building);
                
                // Крыша здания
                const buildingRoofGeometry = new THREE.ConeGeometry(buildingSize*0.8, height*0.4, 4);
                const buildingRoofMaterial = new THREE.MeshStandardMaterial({ 
                                        color: 0x883333,
                    roughness: 0.7,
                    metalness: 0.2
                });
                const buildingRoof = new THREE.Mesh(buildingRoofGeometry, buildingRoofMaterial);
                buildingRoof.position.set(
                    centerX + offsetX, 
                    height*0.7 + height*0.2, 
                    centerZ + 10
                );
                buildingRoof.rotation.y = Math.PI / 4; // Поворот на 45 градусов
                buildingRoof.castShadow = true;
                scene.add(buildingRoof);
            }
        }
        
        // Создание внешних стен крепости
        function createFortressWalls(centerX, centerZ, size, height, thickness) {
            const halfSize = size / 2;
            
            // Материал стен
            const wallMaterial = new THREE.MeshStandardMaterial({ 
                map: textures.wall,
                roughness: 0.8,
                metalness: 0.2
            });
            
            // Стены
            const wallsData = [
                // Северная стена с воротами
                { x: centerX, z: centerZ - halfSize, width: size, depth: thickness, hasGate: true },
                // Южная стена
                { x: centerX, z: centerZ + halfSize, width: size, depth: thickness, hasGate: false },
                // Восточная стена
                { x: centerX + halfSize, z: centerZ, width: thickness, depth: size, hasGate: false },
                // Западная стена
                { x: centerX - halfSize, z: centerZ, width: thickness, depth: size, hasGate: false }
            ];
            
            // Создание стен
            for (const wallData of wallsData) {
                if (wallData.hasGate) {
                    // Стена с воротами
                    const gateWidth = 15;
                    const sideWidth = (wallData.width - gateWidth) / 2;
                    
                    // Левая часть стены
                    const leftWallGeometry = new THREE.BoxGeometry(sideWidth, height, wallData.depth);
                    const leftWall = new THREE.Mesh(leftWallGeometry, wallMaterial);
                    leftWall.position.set(
                        wallData.x - gateWidth/2 - sideWidth/2, 
                        height/2, 
                        wallData.z
                    );
                    leftWall.castShadow = true;
                    leftWall.receiveShadow = true;
                    scene.add(leftWall);
                    walls.push(leftWall);
                    
                    // Правая часть стены
                    const rightWallGeometry = new THREE.BoxGeometry(sideWidth, height, wallData.depth);
                    const rightWall = new THREE.Mesh(rightWallGeometry, wallMaterial);
                    rightWall.position.set(
                        wallData.x + gateWidth/2 + sideWidth/2, 
                        height/2, 
                        wallData.z
                    );
                    rightWall.castShadow = true;
                    rightWall.receiveShadow = true;
                    scene.add(rightWall);
                    walls.push(rightWall);
                    
                    // Создание подъемных ворот
                    createGate(wallData.x, height/2, wallData.z, gateWidth, height, wallData.depth);
                } else {
                    // Обычная стена
                    const wallGeometry = new THREE.BoxGeometry(wallData.width, height, wallData.depth);
                    const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                    wall.position.set(
                        wallData.x, 
                        height/2, 
                        wallData.z
                    );
                    wall.castShadow = true;
                    wall.receiveShadow = true;
                    scene.add(wall);
                    walls.push(wall);
                }
            }
        }
        
        // Создание ворот
        function createGate(x, y, z, width, height, depth) {
            const gateMaterial = new THREE.MeshStandardMaterial({ 
                map: textures.wood,
                roughness: 0.7,
                metalness: 0.5
            });
            
            const gateGeometry = new THREE.BoxGeometry(width, height, depth*0.8);
            const gate = new THREE.Mesh(gateGeometry, gateMaterial);
            gate.position.set(x, y, z);
            gate.castShadow = true;
            gate.receiveShadow = true;
            
            // Металлические детали ворот
            const detailMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x444444,
                roughness: 0.5,
                metalness: 0.8
            });
            
            // Горизонтальные полосы
            for (let i = 0; i < 3; i++) {
                const stripGeometry = new THREE.BoxGeometry(width+0.1, height/10, depth*0.9);
                const strip = new THREE.Mesh(stripGeometry, detailMaterial);
                strip.position.set(x, y - height/4 + i * height/4, z);
                gate.add(strip);
            }
            
            // Вертикальные полосы
            for (let i = 0; i < 3; i++) {
                const stripGeometry = new THREE.BoxGeometry(width/10, height+0.1, depth*0.9);
                const strip = new THREE.Mesh(stripGeometry, detailMaterial);
                strip.position.set(x - width/4 + i * width/4, y, z);
                gate.add(strip);
            }
            
            scene.add(gate);
            secretDoors.push(gate);
            gate.isSecretDoor = true;
            gate.isOpen = false;
            walls.push(gate);
            
            return gate;
        }
        
        // Создание подбираемого оружия
        function createWeaponPickup(x, y, z) {
            const weaponGroup = new THREE.Group();
            
            // Основа оружия
            const baseGeometry = new THREE.BoxGeometry(1, 0.3, 3);
            const baseMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                roughness: 0.5,
                metalness: 0.7
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            weaponGroup.add(base);
            
            // Ствол
            const barrelGeometry = new THREE.CylinderGeometry(0.1, 0.1, 3.5, 8);
            const barrelMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x222222,
                roughness: 0.3,
                metalness: 0.9
            });
            const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
            barrel.rotation.x = Math.PI / 2;
            barrel.position.set(0, 0, 1.5);
            weaponGroup.add(barrel);
            
            // Рукоятка
            const handleGeometry = new THREE.BoxGeometry(0.4, 1, 0.4);
            const handleMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.8,
                metalness: 0.2,
                map: textures.wood
            });
            const handle = new THREE.Mesh(handleGeometry, handleMaterial);
            handle.position.set(0, -0.6, -0.5);
            weaponGroup.add(handle);
            
            // Свечение вокруг оружия
            const glowGeometry = new THREE.SphereGeometry(1.5, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffaa00,
                transparent: true,
                opacity: 0.3
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            weaponGroup.add(glow);
            
            weaponGroup.position.set(x, y, z);
            weaponGroup.rotation.y = Math.PI / 4;
            
            // Анимация оружия (парение и вращение)
            weaponGroup.floatAnimation = {
                speed: 0.01,
                height: 0.5,
                direction: 1,
                progress: 0,
                originalY: y,
                rotation: 0.01
            };
            
            // Установка параметров коллектибла
            weaponGroup.isCollectible = true;
            weaponGroup.collectibleType = 'weapon';
            weaponGroup.weaponId = 2; // Автомат
            
            scene.add(weaponGroup);
            collectibles.push(weaponGroup);
            
            return weaponGroup;
        }
        
        // Создание босса крепости
        function createBoss(x, y, z) {
            const bossGroup = new THREE.Group();
            
            // Тело босса (больше обычных врагов)
            const bodyGeometry = new THREE.BoxGeometry(3, 4, 2);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x880000,
                roughness: 0.7,
                metalness: 0.5
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 2;
            body.castShadow = true;
            body.receiveShadow = true;
            bossGroup.add(body);
            
            // Голова босса
            const headGeometry = new THREE.SphereGeometry(1.2, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xaa0000,
                roughness: 0.7,
                metalness: 0.5
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 4.6;
            head.castShadow = true;
            head.receiveShadow = true;
            bossGroup.add(head);
            
            // Шипы на голове
            for (let i = 0; i < 5; i++) {
                const angle = (i / 5) * Math.PI * 2;
                const spikeGeometry = new THREE.ConeGeometry(0.2, 0.8, 8);
                const spike = new THREE.Mesh(spikeGeometry, headMaterial);
                spike.position.set(
                    Math.sin(angle) * 0.8,
                    5.2,
                    Math.cos(angle) * 0.8
                );
                spike.rotation.x = Math.PI/2 - angle;
                bossGroup.add(spike);
            }
            
            // Руки босса (более массивные)
            const armGeometry = new THREE.CylinderGeometry(0.4, 0.3, 3, 8);
            const armMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x990000,
                roughness: 0.7,
                metalness: 0.5
            });
            
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-2, 2.5, 0);
            leftArm.rotation.z = Math.PI / 3;
            leftArm.castShadow = true;
            leftArm.receiveShadow = true;
            bossGroup.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(2, 2.5, 0);
            rightArm.rotation.z = -Math.PI / 3;
            rightArm.castShadow = true;
            rightArm.receiveShadow = true;
            bossGroup.add(rightArm);
            
            // Оружие в руках босса
            const weaponGeometry = new THREE.BoxGeometry(0.5, 0.5, 3);
            const weaponMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x444444,
                roughness: 0.5,
                metalness: 0.8
            });
            
            const leftWeapon = new THREE.Mesh(weaponGeometry, weaponMaterial);
            leftWeapon.position.set(-3, 1.5, 0);
            leftWeapon.rotation.z = Math.PI / 6;
            leftWeapon.castShadow = true;
            bossGroup.add(leftWeapon);
            
            const rightWeapon = new THREE.Mesh(weaponGeometry, weaponMaterial);
            rightWeapon.position.set(3, 1.5, 0);
            rightWeapon.rotation.z = -Math.PI / 6;
            rightWeapon.castShadow = true;
            bossGroup.add(rightWeapon);
            
            // Ноги босса
            const legGeometry = new THREE.CylinderGeometry(0.5, 0.4, 2, 8);
            const legMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x990000,
                roughness: 0.7,
                metalness: 0.5
            });
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-1, 0, 0);
            leftLeg.castShadow = true;
            leftLeg.receiveShadow = true;
            bossGroup.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(1, 0, 0);
            rightLeg.castShadow = true;
            rightLeg.receiveShadow = true;
            bossGroup.add(rightLeg);
            
            // Эффект свечения для босса
            const glowGeometry = new THREE.SphereGeometry(3, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff0000,
                transparent: true,
                opacity: 0.2,
                side: THREE.BackSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.y = 2;
            bossGroup.add(glow);
            
            // Позиционирование босса
            bossGroup.position.set(x, y, z);
            
            // Добавление свойств босса
            bossGroup.health = 500;  // Больше здоровья
            bossGroup.speed = 0.08;  // Медленнее обычных врагов, но с особыми атаками
            bossGroup.lastShot = 0;
            bossGroup.shootInterval = 1000;
            bossGroup.isBoss = true;
            bossGroup.attackMode = 'normal';  // Режимы атаки: normal, rage, defensive
            bossGroup.attackTimer = 0;
            bossGroup.attackCooldown = 5000;
            
            // Добавление коллайдера для босса
            bossGroup.collider = new THREE.Box3().setFromObject(bossGroup);
            
            // Анимации босса
            bossGroup.animations = {
                bobbing: { amplitude: 0.2, frequency: 0.5, offset: Math.random() * Math.PI * 2 },
                arms: { amplitude: 0.3, frequency: 1, offset: Math.random() * Math.PI * 2 }
            };
            
            // Добавление босса на сцену
            scene.add(bossGroup);
            bosses.push(bossGroup);
            
            // Добавление невидимого хелпера для определения попаданий
            const helperGeometry = new THREE.BoxGeometry(3, 4, 2);
            const helperMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff0000,
                transparent: true,
                opacity: 0.0 // Невидимый
            });
            const helper = new THREE.Mesh(helperGeometry, helperMaterial);
            helper.position.copy(bossGroup.position);
            helper.position.y = 2;
            helper.scale.set(1.2, 1.2, 1.2);  // Больший хитбокс для босса
            helper.enemyRef = bossGroup; // Ссылка на босса
            scene.add(helper);
            enemyHelpers.push(helper);
            
            return bossGroup;
        }
        
        // Создание уровня с подземельем
        function createDungeonLevel(size) {
            const halfSize = size / 2 - 10;
            
            // Изменение текстуры пола на каменный для подземелья
            floor.material.map = textures.lava;
            floor.material.needsUpdate = true;
            
            // Создание основных элементов подземелья
            createDungeonRooms(0, 0, halfSize);
            
            // Создание платформ над лавой
            createLavaPlatforms(0, -25, 10);
            
            // Создание артефактов для сбора
            for (let i = 0; i < 5; i++) {
                const angle = (i / 5) * Math.PI * 2;
                const radius = 30;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                
                createCollectible(x, 1, z, 'artifact');
            }
            
            // Создание финального босса
            createFinalBoss(0, 0, 0);
            
            // Создание врагов подземелья
            for (let i = 0; i < 15; i++) {
                let x, z;
                
                // Распределяем врагов по подземелью
                const angle = Math.random() * Math.PI * 2;
                const radius = 10 + Math.random() * 40;
                x = Math.cos(angle) * radius;
                z = Math.sin(angle) * radius;
                
                createEnemy(x, 0, z, 'dungeon');
            }
            
            // Создание контрольных точек
            createCheckpoint(0, 0, 40);
            createCheckpoint(0, 2, -35); // Контрольная точка после платформ над лавой
        }
        
        // Создание комнат подземелья
        function createDungeonRooms(centerX, centerZ, size) {
            const roomCount = 5;
            const roomSize = 15;
            const wallHeight = 8;
            
            // Материал стен подземелья
            const dungeonMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                roughness: 0.9,
                metalness: 0.1,
                map: textures.wall
            });
            
            // Центральная комната
            createDungeonRoom(centerX, centerZ, roomSize*1.5, wallHeight, dungeonMaterial);
            
            // Окружающие комнаты
            for (let i = 0; i < roomCount; i++) {
                const angle = (i / roomCount) * Math.PI * 2;
                const distance = size * 0.6;
                
                const x = centerX + Math.cos(angle) * distance;
                const z = centerZ + Math.sin(angle) * distance;
                
                // Разные размеры комнат для разнообразия
                const roomVariation = 0.7 + Math.random() * 0.6;
                createDungeonRoom(x, z, roomSize * roomVariation, wallHeight, dungeonMaterial);
                
                // Создание коридора, соединяющего с центральной комнатой
                createDungeonCorridor(
                    centerX, centerZ,
                    x, z,
                    3, wallHeight,
                    dungeonMaterial
                );
            }
        }
        
        // Создание отдельной комнаты подземелья
        function createDungeonRoom(x, z, size, height, material) {
            const halfSize = size / 2;
            
            // Стены комнаты
            const walls = [
                // Северная стена
                { x: x, z: z - halfSize, width: size, depth: 1 },
                // Южная стена
                { x: x, z: z + halfSize, width: size, depth: 1 },
                // Восточная стена
                { x: x + halfSize, z: z, width: 1, depth: size },
                // Западная стена
                { x: x - halfSize, z: z, width: 1, depth: size }
            ];
            
            // Создание стен комнаты
            for (const wallData of walls) {
                // Проверяем, нужен ли проем для двери
                const needsDoor = Math.random() > 0.7;
                
                if (needsDoor) {
                    // Стена с дверным проемом
                    const doorWidth = 3;
                    const sideWidth = (wallData.width - doorWidth) / 2;
                    
                    if (wallData.width > doorWidth*2) { // Только для достаточно широких стен
                        // Левая часть стены
                        const leftWallGeometry = new THREE.BoxGeometry(
                            wallData.width === 1 ? 1 : sideWidth, 
                            height, 
                            wallData.depth === 1 ? 1 : sideWidth
                        );
                        const leftWall = new THREE.Mesh(leftWallGeometry, material);
                        
                        if (wallData.width === 1) { // Вертикальная стена
                            leftWall.position.set(
                                wallData.x, 
                                height/2, 
                                wallData.z - doorWidth - sideWidth/2
                            );
                        } else { // Горизонтальная стена
                            leftWall.position.set(
                                wallData.x - doorWidth/2 - sideWidth/2, 
                                height/2, 
                                wallData.z
                            );
                        }
                        
                        leftWall.castShadow = true;
                        leftWall.receiveShadow = true;
                        scene.add(leftWall);
                        this.walls.push(leftWall);
                        
                        // Правая часть стены
                        const rightWallGeometry = new THREE.BoxGeometry(
                            wallData.width === 1 ? 1 : sideWidth, 
                            height, 
                            wallData.depth === 1 ? 1 : sideWidth
                        );
                        const rightWall = new THREE.Mesh(rightWallGeometry, material);
                        
                        if (wallData.width === 1) { // Вертикальная стена
                            rightWall.position.set(
                                wallData.x, 
                                height/2, 
                                wallData.z + doorWidth + sideWidth/2
                            );
                        } else { // Горизонтальная стена
                            rightWall.position.set(
                                wallData.x + doorWidth/2 + sideWidth/2, 
                                height/2, 
                                wallData.z
                            );
                        }
                        
                        rightWall.castShadow = true;
                        rightWall.receiveShadow = true;
                        scene.add(rightWall);
                        this.walls.push(rightWall);
                        
                        // Верхняя часть дверного проема
                        const topDoorGeometry = new THREE.BoxGeometry(
                            wallData.width === 1 ? 1 : doorWidth, 
                            height/3, 
                            wallData.depth === 1 ? 1 : doorWidth
                        );
                        const topDoor = new THREE.Mesh(topDoorGeometry, material);
                        
                        topDoor.position.set(
                            wallData.x, 
                            height - height/6, 
                            wallData.z
                        );
                        
                        topDoor.castShadow = true;
                        topDoor.receiveShadow = true;
                        scene.add(topDoor);
                        this.walls.push(topDoor);
                    } else {
                        // Для узких стен просто создаем обычную стену
                        createRegularWall(wallData);
                    }
                } else {
                    // Обычная стена без проема
                    createRegularWall(wallData);
                }
            }
            
            // Функция для создания обычной стены
            function createRegularWall(wallData) {
                const wallGeometry = new THREE.BoxGeometry(wallData.width, height, wallData.depth);
                const wall = new THREE.Mesh(wallGeometry, material);
                wall.position.set(
                    wallData.x, 
                    height/2, 
                    wallData.z
                );
                wall.castShadow = true;
                wall.receiveShadow = true;
                scene.add(wall);
                this.walls.push(wall);
            }
            
            // Добавление декоративных элементов
            addDungeonDecorations(x, z, size);
        }
        
        // Создание коридора между комнатами
        function createDungeonCorridor(x1, z1, x2, z2, width, height, material) {
            const dx = x2 - x1;
            const dz = z2 - z1;
            const length = Math.sqrt(dx*dx + dz*dz);
            const angle = Math.atan2(dz, dx);
            
            // Коридор (пол и стены)
            const corridorGeometry = new THREE.BoxGeometry(length, 0.1, width);
            const corridorMaterial = new THREE.MeshStandardMaterial({
                color: 0x444444,
                roughness: 0.8,
                metalness: 0.2
            });
            const corridor = new THREE.Mesh(corridorGeometry, corridorMaterial);
            corridor.position.set(
                (x1 + x2) / 2,
                0.05,
                (z1 + z2) / 2
            );
            corridor.rotation.y = angle;
            corridor.receiveShadow = true;
            scene.add(corridor);
            
            // Стены коридора
            const wallGeometry = new THREE.BoxGeometry(length, height, 0.5);
            
            // Левая стена
            const leftWall = new THREE.Mesh(wallGeometry, material);
            leftWall.position.set(
                (x1 + x2) / 2,
                height/2,
                (z1 + z2) / 2 + (width/2 - 0.25) * Math.cos(angle + Math.PI/2)
            );
            leftWall.position.x += (width/2 - 0.25) * Math.sin(angle + Math.PI/2);
            leftWall.rotation.y = angle;
            leftWall.castShadow = true;
            leftWall.receiveShadow = true;
            scene.add(leftWall);
            walls.push(leftWall);
            
            // Правая стена
            const rightWall = new THREE.Mesh(wallGeometry, material);
            rightWall.position.set(
                (x1 + x2) / 2,
                height/2,
                (z1 + z2) / 2 + (width/2 - 0.25) * Math.cos(angle - Math.PI/2)
            );
            rightWall.position.x += (width/2 - 0.25) * Math.sin(angle - Math.PI/2);
            rightWall.rotation.y = angle;
            rightWall.castShadow = true;
            rightWall.receiveShadow = true;
            scene.add(rightWall);
            walls.push(rightWall);
            
            // Потолок коридора
            const ceilingGeometry = new THREE.BoxGeometry(length, 0.5, width);
            const ceiling = new THREE.Mesh(ceilingGeometry, material);
            ceiling.position.set(
                (x1 + x2) / 2,
                height,
                (z1 + z2) / 2
            );
            ceiling.rotation.y = angle;
            ceiling.castShadow = true;
            ceiling.receiveShadow = true;
            scene.add(ceiling);
            walls.push(ceiling);
            
            // Добавление факелов вдоль коридора
            const torchCount = Math.floor(length / 5);
            for (let i = 0; i < torchCount; i++) {
                const t = (i + 1) / (torchCount + 1);
                const torchX = x1 + dx * t;
                const torchZ = z1 + dz * t;
                
                // Левый факел
                createTorch(
                    torchX + (width/2 - 0.3) * Math.sin(angle + Math.PI/2),
                    height - 1.5,
                    torchZ + (width/2 - 0.3) * Math.cos(angle + Math.PI/2),
                    angle + Math.PI/2
                );
                
                // Правый факел
                createTorch(
                    torchX + (width/2 - 0.3) * Math.sin(angle - Math.PI/2),
                    height - 1.5,
                    torchZ + (width/2 - 0.3) * Math.cos(angle - Math.PI/2),
                    angle - Math.PI/2
                );
            }
        }
        
                // Создание факела
        function createTorch(x, y, z, angle) {
            const torchGroup = new THREE.Group();
            
            // Основание факела
            const baseGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1, 8);
            const baseMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.8,
                metalness: 0.2,
                map: textures.wood
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = -0.2;
            torchGroup.add(base);
            
            // Огонь факела
            const fireGeometry = new THREE.ConeGeometry(0.2, 0.5, 8);
            const fireMaterial = new THREE.MeshBasicMaterial({
                color: 0xff4500,
                transparent: true,
                opacity: 0.9
            });
            const fire = new THREE.Mesh(fireGeometry, fireMaterial);
            fire.position.y = 0.45;
            torchGroup.add(fire);
            
            // Свет от факела
            const light = new THREE.PointLight(0xff6a00, 1, 8);
            light.position.y = 0.45;
            torchGroup.add(light);
            
            // Настройка позиции и ориентации
            torchGroup.position.set(x, y, z);
            torchGroup.rotation.z = Math.PI / 2;
            torchGroup.rotation.y = angle;
            
            // Анимация огня
            torchGroup.fireAnimation = {
                intensity: { base: 1, variation: 0.3 },
                color: { hue: 0.05, saturation: 1, lightness: 0.6 },
                scale: { base: 1, variation: 0.2 },
                speed: 0.1,
                time: Math.random() * Math.PI * 2
            };
            
            scene.add(torchGroup);
            return torchGroup;
        }
        
        // Создание декораций для подземелья
        function addDungeonDecorations(x, z, size) {
            const halfSize = size / 2 - 2;
            
            // Расставляем бочки
            for (let i = 0; i < 3; i++) {
                const barrelX = x + Math.random() * halfSize * (Math.random() > 0.5 ? 1 : -1);
                const barrelZ = z + Math.random() * halfSize * (Math.random() > 0.5 ? 1 : -1);
                
                createBarrel(barrelX, 0, barrelZ);
            }
            
            // Расставляем ящики
            for (let i = 0; i < 2; i++) {
                const crateX = x + Math.random() * halfSize * (Math.random() > 0.5 ? 1 : -1);
                const crateZ = z + Math.random() * halfSize * (Math.random() > 0.5 ? 1 : -1);
                
                createCrate(crateX, 0, crateZ);
            }
            
            // Расставляем колонны по углам
            const columnPositions = [
                { x: x - halfSize * 0.7, z: z - halfSize * 0.7 },
                { x: x + halfSize * 0.7, z: z - halfSize * 0.7 },
                { x: x - halfSize * 0.7, z: z + halfSize * 0.7 },
                { x: x + halfSize * 0.7, z: z + halfSize * 0.7 }
            ];
            
            columnPositions.forEach(pos => {
                createDungeonColumn(pos.x, 0, pos.z);
            });
            
            // Добавляем факелы на стены
            createTorch(x - halfSize + 0.3, 3, z, 0);
            createTorch(x + halfSize - 0.3, 3, z, Math.PI);
            createTorch(x, 3, z - halfSize + 0.3, Math.PI / 2);
            createTorch(x, 3, z + halfSize - 0.3, -Math.PI / 2);
            
            // Создаем стол в центре некоторых комнат
            if (Math.random() > 0.5) {
                createDungeonTable(x, 0, z);
            }
        }
        
        // Создание бочки
        function createBarrel(x, y, z) {
            const barrelGeometry = new THREE.CylinderGeometry(0.8, 0.8, 1.5, 16);
            const barrelMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.8,
                metalness: 0.2,
                map: textures.wood
            });
            const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
            
            // Обручи бочки
            const hoopGeometry = new THREE.TorusGeometry(0.82, 0.05, 8, 16);
            const hoopMaterial = new THREE.MeshStandardMaterial({
                color: 0x444444,
                roughness: 0.6,
                metalness: 0.8
            });
            
            const hoop1 = new THREE.Mesh(hoopGeometry, hoopMaterial);
            hoop1.rotation.x = Math.PI / 2;
            hoop1.position.y = 0.4;
            barrel.add(hoop1);
            
            const hoop2 = new THREE.Mesh(hoopGeometry, hoopMaterial);
            hoop2.rotation.x = Math.PI / 2;
            hoop2.position.y = 0;
            barrel.add(hoop2);
            
            const hoop3 = new THREE.Mesh(hoopGeometry, hoopMaterial);
            hoop3.rotation.x = Math.PI / 2;
            hoop3.position.y = -0.4;
            barrel.add(hoop3);
            
            barrel.position.set(x, y + 0.75, z);
            barrel.rotation.y = Math.random() * Math.PI * 2;
            barrel.castShadow = true;
            barrel.receiveShadow = true;
            
            scene.add(barrel);
            walls.push(barrel);
            
            return barrel;
        }
        
        // Создание ящика
        function createCrate(x, y, z) {
            const size = 0.8 + Math.random() * 0.4;
            const crateGeometry = new THREE.BoxGeometry(size, size, size);
            const crateMaterial = new THREE.MeshStandardMaterial({
                map: textures.crate,
                roughness: 0.8,
                metalness: 0.2
            });
            const crate = new THREE.Mesh(crateGeometry, crateMaterial);
            
            crate.position.set(x, y + size/2, z);
            crate.rotation.y = Math.random() * Math.PI / 2;
            crate.castShadow = true;
            crate.receiveShadow = true;
            
            scene.add(crate);
            walls.push(crate);
            
            return crate;
        }
        
        // Создание колонны подземелья
        function createDungeonColumn(x, y, z) {
            const columnGroup = new THREE.Group();
            
            // Основание колонны
            const baseGeometry = new THREE.CylinderGeometry(1, 1.2, 0.5, 8);
            const baseMaterial = new THREE.MeshStandardMaterial({
                color: 0x666666,
                roughness: 0.9,
                metalness: 0.1
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 0.25;
            columnGroup.add(base);
            
            // Ствол колонны
            const shaftGeometry = new THREE.CylinderGeometry(0.8, 0.8, 6, 8);
            const shaftMaterial = new THREE.MeshStandardMaterial({
                color: 0x888888,
                roughness: 0.7,
                metalness: 0.2
            });
            const shaft = new THREE.Mesh(shaftGeometry, shaftMaterial);
            shaft.position.y = 3.5;
            columnGroup.add(shaft);
            
            // Капитель колонны
            const capitalGeometry = new THREE.CylinderGeometry(1.2, 0.8, 0.5, 8);
            const capital = new THREE.Mesh(capitalGeometry, baseMaterial);
            capital.position.y = 6.75;
            columnGroup.add(capital);
            
            // Орнамент на капители
            const ornamentGeometry = new THREE.BoxGeometry(2.5, 0.3, 2.5);
            const ornament = new THREE.Mesh(ornamentGeometry, baseMaterial);
            ornament.position.y = 7.15;
            columnGroup.add(ornament);
            
            columnGroup.position.set(x, y, z);
            columnGroup.castShadow = true;
            columnGroup.receiveShadow = true;
            
            scene.add(columnGroup);
            walls.push(columnGroup);
            
            return columnGroup;
        }
        
        // Создание стола подземелья
        function createDungeonTable(x, y, z) {
            const tableGroup = new THREE.Group();
            
            // Столешница
            const topGeometry = new THREE.BoxGeometry(4, 0.2, 2);
            const topMaterial = new THREE.MeshStandardMaterial({
                color: 0x5D4037,
                roughness: 0.8,
                metalness: 0.2,
                map: textures.wood
            });
            const top = new THREE.Mesh(topGeometry, topMaterial);
            top.position.y = 1.5;
            tableGroup.add(top);
            
            // Ножки стола
            const legGeometry = new THREE.BoxGeometry(0.3, 1.5, 0.3);
            const legMaterial = new THREE.MeshStandardMaterial({
                color: 0x4E342E,
                roughness: 0.8,
                metalness: 0.2,
                map: textures.wood
            });
            
            // Четыре ножки по углам
            const legPositions = [
                { x: -1.8, z: -0.8 },
                { x: 1.8, z: -0.8 },
                { x: -1.8, z: 0.8 },
                { x: 1.8, z: 0.8 }
            ];
            
            legPositions.forEach(pos => {
                const leg = new THREE.Mesh(legGeometry, legMaterial);
                leg.position.set(pos.x, 0.75, pos.z);
                tableGroup.add(leg);
            });
            
            // Предметы на столе
            // Книга
            const bookGeometry = new THREE.BoxGeometry(0.6, 0.1, 0.8);
            const bookMaterial = new THREE.MeshStandardMaterial({
                color: 0xA1887F,
                roughness: 0.9,
                metalness: 0.1
            });
            const book = new THREE.Mesh(bookGeometry, bookMaterial);
            book.position.set(-1, 1.65, -0.5);
            book.rotation.y = Math.PI / 6;
            tableGroup.add(book);
            
            // Свеча
            const candleGeometry = new THREE.CylinderGeometry(0.05, 0.07, 0.3, 8);
            const candleMaterial = new THREE.MeshStandardMaterial({
                color: 0xEEEEEE,
                roughness: 0.8,
                metalness: 0.2
            });
            const candle = new THREE.Mesh(candleGeometry, candleMaterial);
            candle.position.set(0.8, 1.65, 0);
            tableGroup.add(candle);
            
            // Пламя свечи
            const flameGeometry = new THREE.ConeGeometry(0.04, 0.15, 8);
            const flameMaterial = new THREE.MeshBasicMaterial({
                color: 0xFF9800,
                transparent: true,
                opacity: 0.9
            });
            const flame = new THREE.Mesh(flameGeometry, flameMaterial);
            flame.position.set(0, 0.225, 0);
            candle.add(flame);
            
            // Свет от свечи
            const candleLight = new THREE.PointLight(0xFF9800, 0.8, 5);
            candleLight.position.set(0, 0.225, 0);
            candle.add(candleLight);
            
            // Чаша
            const bowlGeometry = new THREE.CylinderGeometry(0.3, 0.2, 0.2, 16);
            const bowlMaterial = new THREE.MeshStandardMaterial({
                color: 0xB0BEC5,
                roughness: 0.5,
                metalness: 0.8
            });
            const bowl = new THREE.Mesh(bowlGeometry, bowlMaterial);
            bowl.position.set(0, 1.6, 0.5);
            tableGroup.add(bowl);
            
            tableGroup.position.set(x, y, z);
            tableGroup.castShadow = true;
            tableGroup.receiveShadow = true;
            
            scene.add(tableGroup);
            walls.push(tableGroup);
            
            return tableGroup;
        }
        
        // Создание платформ над лавой
        function createLavaPlatforms(centerX, centerZ, count) {
            // Лава на полу
            const lavaSize = 40;
            const lavaGeometry = new THREE.PlaneGeometry(lavaSize, lavaSize);
            const lavaMaterial = new THREE.MeshStandardMaterial({
                map: textures.lava,
                emissive: 0xff5500,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.8
            });
            const lava = new THREE.Mesh(lavaGeometry, lavaMaterial);
            lava.rotation.x = -Math.PI / 2;
            lava.position.set(centerX, 0.1, centerZ);
            scene.add(lava);
            
            // Создание платформ
            const platforms = [];
            
            // Стартовая платформа
            const startPlatform = createPlatform(5, 1, 5, centerX, 0, centerZ + 15, 0x555555);
            platforms.push(startPlatform);
            
            // Конечная платформа
            const endPlatform = createPlatform(5, 1, 5, centerX, 0, centerZ - 15, 0x555555);
            platforms.push(endPlatform);
            
            // Промежуточные платформы
            const distanceBetweenPlatforms = 30 / (count + 1);
            
            for (let i = 0; i < count; i++) {
                const t = (i + 1) / (count + 1);
                const x = centerX + (Math.random() - 0.5) * 10;
                const z = centerZ + 15 - t * 30;
                
                const size = 1.5 + Math.random();
                const platform = createPlatform(size, 1, size, x, 0, z, 0x555555);
                
                // Делаем некоторые платформы движущимися
                if (i % 3 === 1) {
                    platform.isMoving = true;
                    platform.startPosition = new THREE.Vector3(x, 0, z);
                    platform.rangeX = 5;
                    platform.rangeY = 0;
                    platform.rangeZ = 0;
                    platform.movementSpeed = 0.02;
                    platform.movementDirection = 1;
                    platform.movementProgress = 0;
                } else if (i % 3 === 2) {
                    platform.isMoving = true;
                    platform.startPosition = new THREE.Vector3(x, 0, z);
                    platform.rangeX = 0;
                    platform.rangeY = 0;
                    platform.rangeZ = 5;
                    platform.movementSpeed = 0.02;
                    platform.movementDirection = 1;
                    platform.movementProgress = 0;
                }
                
                platforms.push(platform);
            }
            
            // Создание точечных источников света для эффекта лавы
            for (let i = 0; i < 5; i++) {
                const lightX = centerX + (Math.random() - 0.5) * lavaSize * 0.8;
                const lightZ = centerZ + (Math.random() - 0.5) * lavaSize * 0.8;
                
                const lavaLight = new THREE.PointLight(0xff3300, 1, 10);
                lavaLight.position.set(lightX, 0.5, lightZ);
                lavaLight.intensity = 0.5 + Math.random() * 0.5;
                scene.add(lavaLight);
                
                // Анимация света
                lavaLight.animation = {
                    intensity: { min: 0.5, max: 1.0 },
                    speed: 0.01 + Math.random() * 0.02,
                    phase: Math.random() * Math.PI * 2
                };
            }
            
            return platforms;
        }
        
        // Создание финального босса
        function createFinalBoss(x, y, z) {
            const bossGroup = new THREE.Group();
            
            // Тело босса (более сложная геометрия)
            const bodyGeometry = new THREE.DodecahedronGeometry(2.5, 1);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x660066,
                roughness: 0.5,
                metalness: 0.8,
                emissive: 0x330033,
                emissiveIntensity: 0.3
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 3;
            body.castShadow = true;
            body.receiveShadow = true;
            bossGroup.add(body);
            
            // Создание "короны" на голове босса
            const spikes = 8;
            for (let i = 0; i < spikes; i++) {
                const angle = (i / spikes) * Math.PI * 2;
                const spikeGeometry = new THREE.ConeGeometry(0.3, 1.5, 6);
                const spikeMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x990099,
                    roughness: 0.5,
                    metalness: 0.8,
                    emissive: 0x550055,
                    emissiveIntensity: 0.3
                });
                const spike = new THREE.Mesh(spikeGeometry, spikeMaterial);
                spike.position.set(
                    Math.sin(angle) * 2.5,
                    5,
                    Math.cos(angle) * 2.5
                );
                spike.rotation.x = Math.PI/2;
                spike.rotation.z = -angle;
                bossGroup.add(spike);
            }
            
            // Эффект глаз
            const createEye = (posX) => {
                const eyeGroup = new THREE.Group();
                
                // Глазное яблоко
                const eyeGeometry = new THREE.SphereGeometry(0.4, 16, 16);
                const eyeMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x000000,
                    roughness: 0.1,
                    metalness: 1.0,
                    emissive: 0x330000,
                    emissiveIntensity: 0.8
                });
                const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                eyeGroup.add(eye);
                
                // Зрачок
                const pupilGeometry = new THREE.SphereGeometry(0.2, 16, 16);
                const pupilMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff0000
                });
                const pupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                pupil.position.z = 0.25;
                eyeGroup.add(pupil);
                
                // Свет из глаз
                const eyeLight = new THREE.PointLight(0xff0000, 1, 10);
                eyeLight.position.z = 0.5;
                eyeGroup.add(eyeLight);
                
                eyeGroup.position.set(posX, 3.5, 1.8);
                
                return eyeGroup;
            };
            
            bossGroup.add(createEye(-0.8));
            bossGroup.add(createEye(0.8));
            
            // Щупальца босса
            const tentacleCount = 6;
            const segments = 8;
            
            for (let i = 0; i < tentacleCount; i++) {
                const angle = (i / tentacleCount) * Math.PI * 2;
                const tentacleGroup = new THREE.Group();
                
                for (let j = 0; j < segments; j++) {
                    const segmentGeometry = new THREE.SphereGeometry(0.4 - j * 0.03, 8, 8);
                    const segmentMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x990099,
                        roughness: 0.7,
                        metalness: 0.5
                    });
                    const segment = new THREE.Mesh(segmentGeometry, segmentMaterial);
                    segment.position.y = -j * 0.8;
                    tentacleGroup.add(segment);
                }
                
                tentacleGroup.rotation.x = Math.PI/4;
                tentacleGroup.rotation.y = angle;
                tentacleGroup.position.set(
                    Math.sin(angle) * 2,
                    1,
                    Math.cos(angle) * 2
                );
                
                // Анимация щупальца
                tentacleGroup.animation = {
                    waveAmplitude: 0.2,
                    waveFrequency: 1 + Math.random() * 0.5,
                    waveOffset: Math.random() * Math.PI * 2
                };
                
                bossGroup.add(tentacleGroup);
            }
            
            // Эффект свечения вокруг босса
            const glowGeometry = new THREE.SphereGeometry(4, 32, 32);
            const glowMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff00ff,
                transparent: true,
                opacity: 0.1,
                side: THREE.BackSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.y = 3;
            bossGroup.add(glow);
            
            // Позиционирование босса
            bossGroup.position.set(x, y, z);
            
            // Добавление свойств босса
            bossGroup.health = 1000;  // Очень много здоровья
            bossGroup.speed = 0.04;   // Медленный, но сильный
            bossGroup.lastShot = 0;
            bossGroup.shootInterval = 800;
            bossGroup.attackMode = 'normal';  // Режимы атаки: normal, rage, shield
            bossGroup.isBoss = true;
            bossGroup.isFinalBoss = true;
            bossGroup.attackPhase = 0;
            bossGroup.attackTimer = 0;
            bossGroup.phaseTimer = 0;
            
            // Анимации босса
            bossGroup.animations = {
                bobbing: { amplitude: 0.5, frequency: 0.3, offset: 0 },
                rotation: { speed: 0.005, axis: new THREE.Vector3(0, 1, 0) }
            };
            
            // Добавление босса на сцену
            scene.add(bossGroup);
            bosses.push(bossGroup);
            
            // Добавление невидимого хелпера для определения попаданий
            const helperGeometry = new THREE.SphereGeometry(2.5, 16, 16);
            const helperMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff0000,
                transparent: true,
                opacity: 0.0 // Невидимый
            });
            const helper = new THREE.Mesh(helperGeometry, helperMaterial);
            helper.position.copy(bossGroup.position);
            helper.position.y = 3;
            helper.enemyRef = bossGroup; // Ссылка на босса
            scene.add(helper);
            enemyHelpers.push(helper);
            
            return bossGroup;
        }
        
        // Создание продвинутого уровня для высоких уровней
        function createAdvancedLevel(size) {
            const halfSize = size / 2 - 10;
            
            // Создание многоуровневых платформ
            for (let i = 0; i < 5; i++) {
                createPlatform(10 - i, 1, 10 - i, 0, i * 3, -20 - i * 5, 0x4d4dff + i * 0x001100);
            }
            
            // Создание движущихся платформ
            createMovingPlatform(5, 1, 5, 20, 5, 0, 20, 0, 20, 0x4dffbd);
            createMovingPlatform(5, 1, 5, -20, 10, -20, 20, 0, 0, 0x4dffda);
            createMovingPlatform(5, 1, 5, 0, 15, 20, 0, 5, 0, 0x4deeff);
            
            // Создание сложных препятствий и барьеров
            createObstacle(2, 10, 30, -30, 5, 0, 0x8c8c8c);
            createObstacle(30, 10, 2, 0, 5, 30, 0x8c8c8c);
            
            // Создание вращающихся препятствий
            createRotatingObstacle(2, 10, 2, 0, 5, 0, 0x8c8c8c);
            createRotatingObstacle(20, 1, 1, 0, 10, 0, 0xff4d4d);
            
            // Создание коллектиблов
            createCollectible(0, 15, -40, 'key');
            createCollectible(20, 6, 0, 'ammo');
            createCollectible(-20, 11, -20, 'health');
            
            // Создание секретных дверей
            createSecretDoor(10, 5, 2, halfSize - 5, 2.5, 0, 0x7d4d4d);
            
            // Создание дополнительных контрольных точек
            createCheckpoint(0, 0, 0);
            createCheckpoint(0, 15, -40);
            createCheckpoint(0, 13, 20);
        }
        
        // Функция создания платформы
        function createPlatform(width, height, depth, x, y, z, color) {
            const platformGeometry = new THREE.BoxGeometry(width, height, depth);
            const platformMaterial = new THREE.MeshStandardMaterial({ 
                color: color || 0x4d4dff,
                map: textures.metal,
                roughness: 0.4,
                metalness: 0.6
            });
            const platform = new THREE.Mesh(platformGeometry, platformMaterial);
            platform.position.set(x, y, z);
            platform.castShadow = true;
            platform.receiveShadow = true;
            scene.add(platform);
            walls.push(platform);
            platforms.push(platform);
            return platform;
        }
        
        // Функция создания движущейся платформы
        function createMovingPlatform(width, height, depth, x, y, z, rangeX, rangeY, rangeZ, color) {
            const platform = createPlatform(width, height, depth, x, y, z, color);
            platform.isMoving = true;
            platform.startPosition = new THREE.Vector3(x, y, z);
            platform.rangeX = rangeX;
            platform.rangeY = rangeY;
            platform.rangeZ = rangeZ;
            platform.movementSpeed = 0.02;
            platform.movementDirection = 1;
            platform.movementProgress = 0;
            return platform;
        }
        
        // Функция создания вращающегося препятствия
        function createRotatingObstacle(width, height, depth, x, y, z, color) {
            const obstacleGeometry = new THREE.BoxGeometry(width, height, depth);
            const obstacleMaterial = new THREE.MeshStandardMaterial({ 
                color: color || 0x8c8c8c,
                map: textures.metal,
                roughness: 0.6,
                metalness: 0.4
            });
                        const obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
            obstacle.position.set(x, y, z);
            obstacle.castShadow = true;
            obstacle.receiveShadow = true;
            scene.add(obstacle);
            walls.push(obstacle);
            
            obstacle.isRotating = true;
            obstacle.rotationSpeed = 0.02;
            obstacle.rotationAxis = new THREE.Vector3(0, 1, 0);
            
            return obstacle;
        }
        
        // Функция создания препятствия
        function createObstacle(width, height, depth, x, y, z, color) {
            const obstacleGeometry = new THREE.BoxGeometry(width, height, depth);
            const obstacleMaterial = new THREE.MeshStandardMaterial({ 
                color: color || 0x8c8c8c,
                map: textures.wall,
                roughness: 0.8,
                metalness: 0.2
            });
            const obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
            obstacle.position.set(x, y, z);
            obstacle.castShadow = true;
            obstacle.receiveShadow = true;
            scene.add(obstacle);
            walls.push(obstacle);
            return obstacle;
        }
        
        // Функция создания коллектибла
        function createCollectible(x, y, z, type) {
            let collectibleGeometry, collectibleMaterial;
            
            switch(type) {
                case 'key':
                    collectibleGeometry = new THREE.TorusGeometry(0.5, 0.2, 16, 32);
                    collectibleMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0xffcc00,
                        metalness: 0.8,
                        roughness: 0.2,
                        emissive: 0xffcc00,
                        emissiveIntensity: 0.5
                    });
                    break;
                case 'health':
                    collectibleGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
                    collectibleMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x00ff00,
                        metalness: 0.5,
                        roughness: 0.5,
                        emissive: 0x00ff00,
                        emissiveIntensity: 0.5
                    });
                    break;
                case 'ammo':
                    collectibleGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.8, 8);
                    collectibleMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0xffff00,
                        metalness: 0.7,
                        roughness: 0.3,
                        emissive: 0xffff00,
                        emissiveIntensity: 0.5
                    });
                    break;
                case 'artifact':
                    collectibleGeometry = new THREE.OctahedronGeometry(0.6, 0);
                    collectibleMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x00ffff,
                        metalness: 0.9,
                        roughness: 0.1,
                        emissive: 0x00ffff,
                        emissiveIntensity: 0.7
                    });
                    break;
                default:
                    collectibleGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                    collectibleMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x00ffff,
                        metalness: 0.6,
                        roughness: 0.4,
                        emissive: 0x00ffff,
                        emissiveIntensity: 0.5
                    });
            }
            
            const collectible = new THREE.Mesh(collectibleGeometry, collectibleMaterial);
            collectible.position.set(x, y, z);
            collectible.castShadow = true;
            collectible.receiveShadow = true;
            collectible.collectibleType = type;
            collectible.rotation.x = Math.PI / 2;
            
            // Добавление анимации вращения и подпрыгивания
            collectible.isCollectible = true;
            collectible.rotationSpeed = 0.02;
            collectible.floatSpeed = 0.01;
            collectible.floatHeight = 0.5;
            collectible.floatDirection = 1;
            collectible.floatProgress = 0;
            collectible.originalY = y;
            
            // Добавление света вокруг предмета
            const light = new THREE.PointLight(collectibleMaterial.color, 0.8, 3);
            collectible.add(light);
            
            scene.add(collectible);
            collectibles.push(collectible);
            return collectible;
        }
        
        // Функция создания секретной двери
        function createSecretDoor(width, height, depth, x, y, z, color) {
            const doorGeometry = new THREE.BoxGeometry(width, height, depth);
            const doorMaterial = new THREE.MeshStandardMaterial({ 
                color: color || 0x7d4d4d,
                map: textures.wood,
                roughness: 0.7,
                metalness: 0.3
            });
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.set(x, y, z);
            door.castShadow = true;
            door.receiveShadow = true;
            door.isSecretDoor = true;
            door.isOpen = false;
            scene.add(door);
            walls.push(door);
            secretDoors.push(door);
            
            // Добавление замочной скважины
            const keyholeCutout = new THREE.Mesh(
                new THREE.BoxGeometry(0.3, 0.5, depth * 0.6),
                new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            keyholeCutout.position.set(0, 0, -depth * 0.3);
            door.add(keyholeCutout);
            
            return door;
        }
        
        // Функция создания контрольной точки
        function createCheckpoint(x, y, z) {
            const checkpointGeometry = new THREE.CylinderGeometry(1, 1, 0.2, 16);
            const checkpointMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x00ffff,
                transparent: true,
                opacity: 0.5,
                emissive: 0x00ffff,
                emissiveIntensity: 0.5
            });
            const checkpoint = new THREE.Mesh(checkpointGeometry, checkpointMaterial);
            checkpoint.position.set(x, y + 0.1, z);
            checkpoint.rotation.x = Math.PI / 2;
            checkpoint.receiveShadow = true;
            checkpoint.isCheckpoint = true;
            
            // Создание эффекта свечения
            const glowGeometry = new THREE.CylinderGeometry(1.2, 1.2, 0.1, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ffff,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            checkpoint.add(glow);
            
            // Создание столба света
            const lightBeamGeometry = new THREE.CylinderGeometry(0.1, 0.1, 10, 8);
            const lightBeamMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ffff,
                transparent: true,
                opacity: 0.2
            });
            const lightBeam = new THREE.Mesh(lightBeamGeometry, lightBeamMaterial);
            lightBeam.position.y = 5;
            checkpoint.add(lightBeam);
            
            // Свет от контрольной точки
            const checkpointLight = new THREE.PointLight(0x00ffff, 1, 10);
            checkpointLight.position.y = 0.5;
            checkpoint.add(checkpointLight);
            
            scene.add(checkpoint);
            return checkpoint;
        }
        
        // Создание врага
        function createEnemy(x, y, z, type = 'basic') {
            const enemyGroup = new THREE.Group();
            let enemyColor, enemyHealth, enemySpeed, enemyShootInterval;
            
            // Различные типы врагов
            switch(type) {
                case 'basic': // Обычный враг
                    enemyColor = 0xff0000;
                    enemyHealth = 100;
                    enemySpeed = 0.05;
                    enemyShootInterval = 2000;
                    break;
                case 'maze': // Враг в лабиринте, быстрее
                    enemyColor = 0xff3300;
                    enemyHealth = 120;
                    enemySpeed = 0.08;
                    enemyShootInterval = 1800;
                    break;
                case 'guard': // Охранник крепости, сильнее
                    enemyColor = 0x990000;
                    enemyHealth = 150;
                    enemySpeed = 0.06;
                    enemyShootInterval = 1500;
                    break;
                case 'dungeon': // Враг подземелья, еще сильнее
                    enemyColor = 0x660000;
                    enemyHealth = 200;
                    enemySpeed = 0.04;
                    enemyShootInterval = 1200;
                    break;
                default:
                    enemyColor = 0xff0000;
                    enemyHealth = 100;
                    enemySpeed = 0.05;
                    enemyShootInterval = 2000;
            }
            
            // Тело врага
            const bodyGeometry = new THREE.BoxGeometry(1.5, 2, 1);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: enemyColor,
                roughness: 0.7,
                metalness: 0.3,
                map: textures.enemy
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1;
            body.castShadow = true;
            body.receiveShadow = true;
            enemyGroup.add(body);
            
            // Голова врага
            const headGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({ 
                color: enemyColor,
                roughness: 0.7,
                metalness: 0.3
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 2.5;
            head.castShadow = true;
            head.receiveShadow = true;
            enemyGroup.add(head);
            
            // Руки врага
            const armGeometry = new THREE.CylinderGeometry(0.2, 0.2, 1.5, 8);
            const armMaterial = new THREE.MeshStandardMaterial({ 
                color: enemyColor,
                roughness: 0.7,
                metalness: 0.3
            });
            
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.9, 1, 0);
            leftArm.rotation.z = Math.PI / 2;
            leftArm.castShadow = true;
            leftArm.receiveShadow = true;
            enemyGroup.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.9, 1, 0);
            rightArm.rotation.z = -Math.PI / 2;
            rightArm.castShadow = true;
            rightArm.receiveShadow = true;
            enemyGroup.add(rightArm);
            
            // Ноги врага
            const legGeometry = new THREE.CylinderGeometry(0.25, 0.25, 1, 8);
            const legMaterial = new THREE.MeshStandardMaterial({ 
                color: enemyColor,
                roughness: 0.7,
                metalness: 0.3
            });
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.5, -0.5, 0);
            leftLeg.castShadow = true;
            leftLeg.receiveShadow = true;
            enemyGroup.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.5, -0.5, 0);
            rightLeg.castShadow = true;
            rightLeg.receiveShadow = true;
            enemyGroup.add(rightLeg);
            
            // Специальные детали для разных типов врагов
            if (type === 'guard') {
                // Шлем для охранника
                const helmetGeometry = new THREE.ConeGeometry(0.6, 0.8, 8);
                const helmetMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x444444,
                    roughness: 0.5,
                    metalness: 0.8
                });
                const helmet = new THREE.Mesh(helmetGeometry, helmetMaterial);
                helmet.position.y = 3;
                helmet.castShadow = true;
                enemyGroup.add(helmet);
                
                // Оружие для охранника
                const weaponGeometry = new THREE.BoxGeometry(0.3, 0.3, 2);
                const weaponMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x222222,
                    roughness: 0.5,
                    metalness: 0.8
                });
                const weapon = new THREE.Mesh(weaponGeometry, weaponMaterial);
                weapon.position.set(1.5, 1, 0);
                weapon.rotation.y = Math.PI / 2;
                enemyGroup.add(weapon);
            } else if (type === 'dungeon') {
                // Плащ для врага подземелья
                const cloakGeometry = new THREE.CylinderGeometry(1, 1.5, 3, 8, 1, true);
                const cloakMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x330000,
                    roughness: 0.9,
                    metalness: 0.1,
                    side: THREE.DoubleSide
                });
                const cloak = new THREE.Mesh(cloakGeometry, cloakMaterial);
                cloak.position.y = 0.5;
                cloak.castShadow = true;
                enemyGroup.add(cloak);
                
                // Свечение глаз
                const eyeGlowGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeGlowMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff0000,
                    transparent: true,
                    opacity: 0.8
                });
                
                const leftEyeGlow = new THREE.Mesh(eyeGlowGeometry, eyeGlowMaterial);
                leftEyeGlow.position.set(-0.2, 2.5, 0.4);
                enemyGroup.add(leftEyeGlow);
                
                const rightEyeGlow = new THREE.Mesh(eyeGlowGeometry, eyeGlowMaterial);
                rightEyeGlow.position.set(0.2, 2.5, 0.4);
                enemyGroup.add(rightEyeGlow);
                
                // Свет от глаз
                const eyeLight = new THREE.PointLight(0xff0000, 0.5, 3);
                eyeLight.position.set(0, 2.5, 0.5);
                enemyGroup.add(eyeLight);
            }
            
            // Позиционирование врага
            enemyGroup.position.set(x, y, z);
            
            // Добавление свойств врага
            enemyGroup.health = enemyHealth;
            enemyGroup.speed = enemySpeed * (1 + level * 0.1);
            enemyGroup.lastShot = 0;
            enemyGroup.shootInterval = enemyShootInterval - level * 100;
            if (enemyGroup.shootInterval < 500) enemyGroup.shootInterval = 500;
            enemyGroup.type = type;
            
            // Добавление коллайдера для врага
            enemyGroup.collider = new THREE.Box3().setFromObject(enemyGroup);
            
            // Добавление врага на сцену
            scene.add(enemyGroup);
            enemies.push(enemyGroup);
            
            // Добавление невидимого хелпера для определения попаданий
            const helperGeometry = new THREE.BoxGeometry(1.5, 3, 1.5);
            const helperMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff0000,
                transparent: true,
                opacity: 0.0 // Невидимый
            });
            const helper = new THREE.Mesh(helperGeometry, helperMaterial);
            helper.position.copy(enemyGroup.position);
            helper.position.y = 1.5;
            helper.enemyRef = enemyGroup; // Ссылка на врага
            scene.add(helper);
            enemyHelpers.push(helper);
            
            return enemyGroup;
        }
        
        // Обработка нажатия клавиш
        function onKeyDown(event) {
            if (gameOver || levelCompleted) return;
            
            switch (event.code) {
                case 'KeyW':
                case 'ArrowUp':
                    moveForward = true;
                    isPlayerMoving = true;
                    break;
                case 'KeyS':
                case 'ArrowDown':
                    moveBackward = true;
                    isPlayerMoving = true;
                    break;
                case 'KeyA':
                case 'ArrowLeft':
                    moveLeft = true;
                    isPlayerMoving = true;
                    break;
                case 'KeyD':
                case 'ArrowRight':
                    moveRight = true;
                    isPlayerMoving = true;
                    break;
                case 'Space':
                    if (canJump) {
                        player.velocity.y = JUMP_FORCE;
                        canJump = false;
                    }
                    break;
                case 'ShiftLeft':
                case 'ShiftRight':
                    isRunning = true;
                    break;
                case 'KeyC':
                    isCrouching = !isCrouching;
                    if (isCrouching) {
                        player.position.y = 1;
                        camera.position.y = 0;
                    } else {
                        player.position.y = 2;
                        camera.position.y = 0;
                    }
                    break;
                case 'KeyR':
                    reload();
                    break;
                case 'KeyE':
                    interact();
                    break;
            }
        }
        
        // Обработка отпускания клавиш
        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW':
                case 'ArrowUp':
                    moveForward = false;
                    isPlayerMoving = moveBackward || moveLeft || moveRight;
                    break;
                case 'KeyS':
                case 'ArrowDown':
                    moveBackward = false;
                    isPlayerMoving = moveForward || moveLeft || moveRight;
                    break;
                case 'KeyA':
                case 'ArrowLeft':
                    moveLeft = false;
                    isPlayerMoving = moveForward || moveBackward || moveRight;
                    break;
                case 'KeyD':
                case 'ArrowRight':
                    moveRight = false;
                    isPlayerMoving = moveForward || moveBackward || moveLeft;
                    break;
                case 'ShiftLeft':
                case 'ShiftRight':
                    isRunning = false;
                    break;
            }
        }
        
        // Обработка нажатия кнопки мыши
        function onMouseDown(event) {
            if (gameOver || levelCompleted) return;
            
            if (event.button === 0) { // Левая кнопка мыши
                isShooting = true;
                shoot();
                
                // Автоматическая стрельба для автоматических оружий
                if (weapons[currentWeapon - 1].automatic) {
                    touchShootId = setInterval(shoot, weapons[currentWeapon - 1].shootInterval);
                }
            }
        }
        
        // Обработка отпускания кнопки мыши
        function onMouseUp(event) {
            if (event.button === 0) {
                isShooting = false;
                if (touchShootId !== null) {
                    clearInterval(touchShootId);
                    touchShootId = null;
                }
            }
        }
        
        // Обработка блокировки указателя мыши
        function lockChangeAlert() {
            if (document.pointerLockElement === renderer.domElement) {
                document.addEventListener('mousemove', updateCamera, false);
            } else {
                document.removeEventListener('mousemove', updateCamera, false);
            }
        }
        
        // Обновление камеры при движении мыши
        function updateCamera(event) {
            if (gameOver || levelCompleted) return;
            
            const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
            const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
            
            player.rotation.y -= movementX * 0.002;
            
            // Ограничение вертикального вращения камеры
            camera.rotation.x -= movementY * 0.002;
            camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
        }
        
        // Обработка изменения размера окна
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Система автоприцеливания
        function findTargetEnemy() {
            // Направление взгляда
            const lookDirection = new THREE.Vector3();
            camera.getWorldDirection(lookDirection);
            
            let closestEnemy = null;
            let closestAngle = AUTO_AIM_ANGLE;
            
            for (const helper of enemyHelpers) {
                // Проверяем, что враг еще жив
                if (!helper.enemyRef || !scene.getObjectById(helper.enemyRef.id)) continue;
                
                // Вектор от игрока к врагу
                const enemyDirection = new THREE.Vector3();
                enemyDirection.subVectors(helper.position, player.position).normalize();
                
                // Угол между направлением взгляда и направлением к врагу
                const angle = lookDirection.angleTo(enemyDirection);
                
                // Расстояние до врага
                const distance = player.position.distanceTo(helper.position);
                
                // Если враг в пределах угла автоприцеливания и не слишком далеко
                if (angle < closestAngle && distance < AUTO_AIM_DISTANCE) {
                    // Проверка видимости (нет ли стен между игроком и врагом)
                    raycaster.set(player.position, enemyDirection);
                    const intersects = raycaster.intersectObjects(walls);
                    
                    if (intersects.length === 0 || 
                        intersects[0].distance > distance) {
                        closestEnemy = helper;
                        closestAngle = angle;
                    }
                }
            }
            
            return closestEnemy;
        }
        
        // Стрельба
        function shoot() {
            if (reloading || ammo <= 0) {
                if (ammo <= 0) reload();
                return;
            }
            
            // Найти цель для автоприцеливания
            targetEnemy = findTargetEnemy();
            
            // Создание пули
            const bulletGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
            
            // Позиционирование пули перед игроком
            bullet.position.copy(player.position);
            bullet.position.y = camera.position.y;
            
            // Направление пули
            let direction = new THREE.Vector3();
            
            if (targetEnemy) {
                // Если есть цель, стреляем в нее
                direction.subVectors(targetEnemy.position, player.position).normalize();
                
                // Добавляем небольшой разброс для реалистичности
                direction.x += (Math.random() - 0.5) * 0.02;
                direction.y += (Math.random() - 0.5) * 0.02;
                direction.z += (Math.random() - 0.5) * 0.02;
                direction.normalize();
                
                // Показываем маркер попадания
                showHitMarker();
            } else {
                // Иначе стреляем в направлении камеры
                camera.getWorldDirection(direction);
            }
            
            bullet.velocity = direction.multiplyScalar(1);
            
            // Установка урона пули в зависимости от оружия
            bullet.damage = weapons[currentWeapon - 1].damage;
            
            // Добавление пули на сцену
            scene.add(bullet);
            bullets.push(bullet);
            
            // Создание эффекта вспышки выстрела
            createMuzzleFlash();
            
            // Уменьшение патронов
            ammo--;
            document.getElementById('ammo-count').textContent = ammo;
            
            // Звуковой эффект (в реальном проекте добавьте звук)
            // playSound('shoot');
            
            // Добавление эффекта отдачи
            if (!isMobile) {
                camera.rotation.x += 0.01;
                player.rotation.y += (Math.random() - 0.5) * 0.005;
            }
        }
        
        // Создание эффекта вспышки выстрела
        function createMuzzleFlash() {
            // Позиция вспышки
            const muzzlePosition = new THREE.Vector3(0, 0, -1);
            muzzlePosition.applyQuaternion(camera.quaternion);
            muzzlePosition.add(camera.position);
            
            // Создание частиц для вспышки
            const particleCount = 20;
            const particleGeometry = new THREE.BufferGeometry();
            const particleMaterial = new THREE.PointsMaterial({
                color: 0xffff00,
                size: 0.1,
                transparent: true,
                opacity: 0.8
            });
            
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];
            
            for (let i = 0; i < particleCount; i++) {
                // Случайное положение вокруг точки вспышки
                const x = muzzlePosition.x + (Math.random() - 0.5) * 0.2;
                const y = muzzlePosition.y + (Math.random() - 0.5) * 0.2;
                const z = muzzlePosition.z + (Math.random() - 0.5) * 0.2;
                
                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;
                
                // Случайная скорость
                velocities.push(new THREE.Vector3(
                    (Math.random() - 0.5) * 0.1,
                    (Math.random() - 0.5) * 0.1,
                    (Math.random() - 0.5) * 0.1
                ));
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
            
            // Добавление системы частиц для обновления
            particleSystems.push({
                particles: particles,
                velocities: velocities,
                life: 10 // Время жизни эффекта в кадрах
            });
        }
        
        // Показать маркер попадания
        function showHitMarker() {
            const hitMarker = document.getElementById('hit-marker');
            hitMarker.style.opacity = '1';
            
            setTimeout(() => {
                hitMarker.style.opacity = '0';
            }, 100);
        }
        
        // Перезарядка
        function reload() {
            const weapon = weapons[currentWeapon - 1];
            if (reloading || ammo === weapon.maxAmmo) return;
            
                        reloading = true;
            
            // Показать индикатор перезарядки
            document.getElementById('reload-indicator').style.display = 'block';
            
            setTimeout(() => {
                ammo = weapon.maxAmmo;
                document.getElementById('ammo-count').textContent = ammo;
                reloading = false;
                document.getElementById('reload-indicator').style.display = 'none';
            }, 2000);
        }
        
        // Обновление полосы здоровья
        function updateHealthBar() {
            const healthFill = document.getElementById('health-fill');
            healthFill.style.width = health + '%';
            
            // Изменение цвета в зависимости от здоровья
            if (health > 60) {
                healthFill.style.backgroundColor = '#0f0';
            } else if (health > 30) {
                healthFill.style.backgroundColor = '#ff0';
            } else {
                healthFill.style.backgroundColor = '#f00';
            }
        }
        
        // Создание эффекта попадания
        function createHitEffect(position) {
            // Создание частиц для эффекта попадания
            const particleCount = 30;
            const particleGeometry = new THREE.BufferGeometry();
            const particleMaterial = new THREE.PointsMaterial({
                color: 0xff0000,
                size: 0.1,
                transparent: true,
                opacity: 0.8
            });
            
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];
            
            for (let i = 0; i < particleCount; i++) {
                // Начальное положение в точке попадания
                positions[i * 3] = position.x;
                positions[i * 3 + 1] = position.y;
                positions[i * 3 + 2] = position.z;
                
                // Случайная скорость во все стороны
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.2,
                    (Math.random() - 0.5) * 0.2,
                    (Math.random() - 0.5) * 0.2
                );
                velocity.normalize().multiplyScalar(0.1 + Math.random() * 0.1);
                velocities.push(velocity);
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
            
            // Добавление системы частиц для обновления
            particleSystems.push({
                particles: particles,
                velocities: velocities,
                life: 20 // Время жизни эффекта в кадрах
            });
        }
        
        // Обработка попадания пули во врага
        function hitEnemy(enemy, bulletIndex) {
            const bulletDamage = bullets[bulletIndex].damage || 25;
            enemy.health -= bulletDamage;
            
            // Создание эффекта попадания
            createHitEffect(bullets[bulletIndex].position.clone());
            
            if (enemy.health <= 0) {
                // Создание эффекта уничтожения
                createExplosion(enemy.position.clone());
                
                // Удаление врага со сцены
                scene.remove(enemy);
                enemies.splice(enemies.indexOf(enemy), 1);
                
                // Удаление хелпера
                for (let i = 0; i < enemyHelpers.length; i++) {
                    if (enemyHelpers[i].enemyRef === enemy) {
                        scene.remove(enemyHelpers[i]);
                        enemyHelpers.splice(i, 1);
                        break;
                    }
                }
                
                // Увеличение счета
                score += enemy.isBoss ? 500 : 100;
                document.getElementById('score').textContent = score;
                
                // Проверка текущего задания
                if (currentObjective && currentObjective.type === 'kill') {
                    // Если задание на убийство врагов
                    if (currentObjective.count) {
                        currentObjective.currentCount = (currentObjective.currentCount || 0) + 1;
                        
                        // Обновление индикатора задания
                        if (currentObjective.currentCount < currentObjective.count) {
                            document.getElementById('objective-indicator').textContent = 
                                `Задача: ${currentObjective.description} (${currentObjective.currentCount}/${currentObjective.count})`;
                        } else {
                            completeObjective();
                        }
                    }
                }
                
                // Проверка на убийство босса
                if (enemy.isBoss) {
                    if (enemy.isFinalBoss) {
                        // Победа над финальным боссом
                        showVictory();
                    } else if (currentObjective && currentObjective.type === 'boss') {
                        completeObjective();
                    }
                }
                
                // Проверка на завершение уровня
                if (enemies.length === 0 && bosses.length === 0) {
                    // Если нет задания на убийство, можно завершить уровень
                    if (!(currentObjective && currentObjective.type === 'kill')) {
                        levelComplete();
                    }
                }
                
                // Случайный дроп предметов
                const dropChance = enemy.isBoss ? 1.0 : 0.3;
                if (Math.random() < dropChance) {
                    const dropType = Math.random() < 0.5 ? 'health' : 'ammo';
                    createCollectible(enemy.position.x, 1, enemy.position.z, dropType);
                }
            }
            
            // Удаление пули
            scene.remove(bullets[bulletIndex]);
            bullets.splice(bulletIndex, 1);
        }
        
        // Создание эффекта взрыва
        function createExplosion(position) {
            // Создание частиц для эффекта взрыва
            const particleCount = 100;
            const particleGeometry = new THREE.BufferGeometry();
            const particleMaterial = new THREE.PointsMaterial({
                color: 0xff5500,
                size: 0.2,
                transparent: true,
                opacity: 0.8
            });
            
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];
            const colors = [];
            
            for (let i = 0; i < particleCount; i++) {
                // Начальное положение в точке взрыва
                positions[i * 3] = position.x;
                positions[i * 3 + 1] = position.y;
                positions[i * 3 + 2] = position.z;
                
                // Случайная скорость во все стороны
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2
                );
                velocity.normalize().multiplyScalar(0.1 + Math.random() * 0.2);
                velocities.push(velocity);
                
                // Случайный цвет от красного до желтого
                const color = new THREE.Color();
                color.setHSL(0.05 + Math.random() * 0.05, 1, 0.5 + Math.random() * 0.5);
                colors.push(color);
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
            
            // Добавление системы частиц для обновления
            particleSystems.push({
                particles: particles,
                velocities: velocities,
                colors: colors,
                life: 40 // Время жизни эффекта в кадрах
            });
            
            // Создание точечного света при взрыве
            const explosionLight = new THREE.PointLight(0xff5500, 2, 10);
            explosionLight.position.copy(position);
            scene.add(explosionLight);
            
            // Угасание света
            setTimeout(() => {
                scene.remove(explosionLight);
            }, 500);
        }
        
        // Отображение экрана победы
        function showVictory() {
            const notification = document.getElementById('level-up');
            notification.querySelector('h2').textContent = "Поздравляем!";
            notification.querySelector('p').textContent = "Вы победили всех боссов и прошли игру!";
            notification.querySelector('#level-description').textContent = `Ваш финальный счет: ${score}`;
            notification.querySelector('#next-level-button').textContent = "Начать заново";
            notification.style.display = 'block';
            
            document.getElementById('next-level-button').addEventListener('click', function() {
                notification.style.display = 'none';
                level = 1;
                score = 0;
                health = 100;
                createLevel();
            }, { once: true });
        }
        
        // Обработка попадания пули в игрока
        function hitPlayer(bulletIndex) {
            health -= 10;
            updateHealthBar();
            
            // Эффект тряски камеры при попадании
            camera.rotation.z = (Math.random() - 0.5) * 0.05;
            setTimeout(() => {
                camera.rotation.z = 0;
            }, 300);
            
            // Создание эффекта попадания
            createHitEffect(enemyBullets[bulletIndex].position.clone());
            
            // Удаление пули
            scene.remove(enemyBullets[bulletIndex]);
            enemyBullets.splice(bulletIndex, 1);
            
            // Проверка на конец игры
            if (health <= 0) {
                endGame();
            }
        }
        
        // Завершение уровня
        function levelComplete() {
            levelCompleted = true;
            
            const levelUp = document.getElementById('level-up');
            const newLevelSpan = document.getElementById('new-level');
            const levelDescription = document.getElementById('level-description');
            
            newLevelSpan.textContent = level + 1;
            
            // Установка описания следующего уровня
            if (level < LEVELS.length) {
                levelDescription.textContent = LEVELS[level].description;
            } else {
                levelDescription.textContent = "Сражайтесь с более сильными врагами в процедурно-сгенерированных уровнях!";
            }
            
            levelUp.style.display = 'block';
            
            document.getElementById('next-level-button').addEventListener('click', function() {
                level++;
                levelUp.style.display = 'none';
                levelCompleted = false;
                createLevel();
            }, { once: true });
        }
        
        // Конец игры
        function endGame() {
            gameOver = true;
            document.getElementById('final-score').textContent = score;
            document.getElementById('game-over').style.display = 'block';
            
            if (!isMobile) {
                document.exitPointerLock();
            }
            
            document.getElementById('restart-button').addEventListener('click', function() {
                document.getElementById('game-over').style.display = 'none';
                gameOver = false;
                health = 100;
                score = 0;
                level = 1;
                createLevel();
            }, { once: true });
        }
        
        // Обновление систем частиц
        function updateParticleSystems() {
            for (let i = particleSystems.length - 1; i >= 0; i--) {
                const system = particleSystems[i];
                
                // Обновление позиций частиц
                const positions = system.particles.geometry.attributes.position.array;
                
                for (let j = 0; j < positions.length / 3; j++) {
                    positions[j * 3] += system.velocities[j].x;
                    positions[j * 3 + 1] += system.velocities[j].y;
                    positions[j * 3 + 2] += system.velocities[j].z;
                    
                    // Добавление гравитации для некоторых эффектов
                    system.velocities[j].y -= 0.001;
                }
                
                system.particles.geometry.attributes.position.needsUpdate = true;
                
                // Уменьшение времени жизни
                system.life--;
                
                // Уменьшение прозрачности со временем
                system.particles.material.opacity = system.life / 40;
                
                // Удаление системы после окончания времени жизни
                if (system.life <= 0) {
                    scene.remove(system.particles);
                    particleSystems.splice(i, 1);
                }
            }
        }
        
        // Обновление коллектиблов
        function updateCollectibles() {
            for (let i = collectibles.length - 1; i >= 0; i--) {
                const collectible = collectibles[i];
                
                // Вращение коллектибла
                collectible.rotation.y += collectible.rotationSpeed;
                
                // Подпрыгивание коллектибла
                collectible.floatProgress += collectible.floatDirection * collectible.floatSpeed;
                
                // Изменение направления движения при достижении границ
                if (Math.abs(collectible.floatProgress) >= collectible.floatHeight) {
                    collectible.floatDirection *= -1;
                }
                
                // Применение позиции Y
                collectible.position.y = collectible.originalY + collectible.floatProgress;
                
                // Проверка коллизии с игроком
                const collectibleBox = new THREE.Box3().setFromObject(collectible);
                const playerBox = new THREE.Box3();
                
                playerBox.min.set(
                    player.position.x - 0.5,
                    player.position.y - (isCrouching ? 0.5 : 1),
                    player.position.z - 0.5
                );
                playerBox.max.set(
                    player.position.x + 0.5,
                    player.position.y + (isCrouching ? 0.5 : 1),
                    player.position.z + 0.5
                );
                
                if (collectibleBox.intersectsBox(playerBox)) {
                    // Обработка подбора коллектибла
                    collectItem(collectible);
                    
                    // Удаление коллектибла со сцены
                    scene.remove(collectible);
                    collectibles.splice(i, 1);
                }
            }
        }
        
        // Обработка подбора коллектибла
        function collectItem(collectible) {
            switch (collectible.collectibleType) {
                case 'key':
                    hasCollectibleKey = true;
                    showItemPickupNotification("Получен ключ!");
                    // Создание эффекта получения ключа
                    createCollectEffect(collectible.position.clone(), 0xffcc00);
                    // Проверка на завершение задания
                    if (currentObjective && currentObjective.type === 'key') {
                        completeObjective();
                    }
                    break;
                case 'health':
                    health = Math.min(health + 25, 100);
                    updateHealthBar();
                    showItemPickupNotification("Здоровье восстановлено");
                    // Создание эффекта получения здоровья
                    createCollectEffect(collectible.position.clone(), 0x00ff00);
                    break;
                case 'ammo':
                    // Восстановление патронов для текущего оружия
                    weapons[currentWeapon - 1].ammo = weapons[currentWeapon - 1].maxAmmo;
                    ammo = weapons[currentWeapon - 1].ammo;
                    document.getElementById('ammo-count').textContent = ammo;
                    showItemPickupNotification("Патроны пополнены");
                    // Создание эффекта получения патронов
                    createCollectEffect(collectible.position.clone(), 0xffff00);
                    break;
                case 'weapon':
                    // Получение нового оружия
                    const weaponId = collectible.weaponId || 2;
                    switchWeapon(weaponId);
                    showItemPickupNotification(`Получено: ${weapons[weaponId - 1].name}`);
                    // Создание эффекта получения оружия
                    createCollectEffect(collectible.position.clone(), 0xff7700);
                    // Проверка на завершение задания
                    if (currentObjective && currentObjective.type === 'weapon') {
                        completeObjective();
                    }
                    break;
                case 'artifact':
                    score += 100;
                    document.getElementById('score').textContent = score;
                    showItemPickupNotification("Артефакт найден! +100 очков");
                    // Создание эффекта получения артефакта
                    createCollectEffect(collectible.position.clone(), 0x00ffff);
                    // Проверка на завершение задания
                    if (currentObjective && currentObjective.type === 'collect') {
                        currentObjective.currentCount = (currentObjective.currentCount || 0) + 1;
                        
                        // Обновление индикатора задания
                        if (currentObjective.currentCount < currentObjective.count) {
                            document.getElementById('objective-indicator').textContent = 
                                `Задача: ${currentObjective.description} (${currentObjective.currentCount}/${currentObjective.count})`;
                        } else {
                            completeObjective();
                        }
                    }
                    break;
                default:
                    score += 50;
                    document.getElementById('score').textContent = score;
                    showItemPickupNotification("Предмет собран");
                    // Создание эффекта получения очков
                    createCollectEffect(collectible.position.clone(), 0x00ffff);
            }
        }
        
        // Создание эффекта сбора предмета
        function createCollectEffect(position, color) {
            // Создание частиц для эффекта сбора
            const particleCount = 30;
            const particleGeometry = new THREE.BufferGeometry();
            const particleMaterial = new THREE.PointsMaterial({
                color: color,
                size: 0.2,
                transparent: true,
                opacity: 0.8
            });
            
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];
            
            for (let i = 0; i < particleCount; i++) {
                // Начальное положение в точке сбора
                positions[i * 3] = position.x;
                positions[i * 3 + 1] = position.y;
                positions[i * 3 + 2] = position.z;
                
                // Случайная скорость вверх и в стороны
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.1,
                    Math.random() * 0.2,
                    (Math.random() - 0.5) * 0.1
                );
                velocities.push(velocity);
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
            
            // Добавление системы частиц для обновления
            particleSystems.push({
                particles: particles,
                velocities: velocities,
                life: 30 // Время жизни эффекта в кадрах
            });
        }
        
        // Обновление секретных дверей
        function updateSecretDoors() {
            if (hasCollectibleKey) {
                for (const door of secretDoors) {
                    // Обновление анимации открытия, если она есть
                    if (door.animation && door.animation.progress < 1) {
                        door.animation.progress += door.animation.speed;
                        if (door.animation.progress > 1) door.animation.progress = 1;
                        
                        const newY = door.animation.startY + (door.animation.targetY - door.animation.startY) * door.animation.progress;
                        door.position.y = newY;
                    }
                }
            }
        }
        
        // Обновление движущихся платформ
        function updatePlatforms() {
            for (const platform of platforms) {
                if (platform.isMoving) {
                    platform.movementProgress += platform.movementDirection * platform.movementSpeed;
                    
                    if (Math.abs(platform.movementProgress) >= 1) {
                        platform.movementDirection *= -1;
                    }
                    
                    const newX = platform.startPosition.x + platform.rangeX * platform.movementProgress;
                    const newY = platform.startPosition.y + platform.rangeY * platform.movementProgress;
                    const newZ = platform.startPosition.z + platform.rangeZ * platform.movementProgress;
                    
                    const deltaX = newX - platform.position.x;
                    const deltaY = newY - platform.position.y;
                    const deltaZ = newZ - platform.position.z;
                    
                    platform.position.set(newX, newY, newZ);
                    
                    // Перемещение игрока вместе с платформой, если он на ней
                    const playerBox = new THREE.Box3();
                    playerBox.min.set(
                        player.position.x - 0.5,
                        player.position.y - 0.1,
                        player.position.z - 0.5
                    );
                    playerBox.max.set(
                        player.position.x + 0.5,
                        player.position.y,
                        player.position.z + 0.5
                    );
                    
                    const platformBox = new THREE.Box3().setFromObject(platform);
                    platformBox.max.y += 0.1; // Чуть увеличиваем высоту для лучшей проверки
                    
                    if (playerBox.intersectsBox(platformBox) && player.position.y >= platform.position.y) {
                        player.position.x += deltaX;
                        player.position.y += deltaY;
                        player.position.z += deltaZ;
                    }
                }
                
                if (platform.isRotating) {
                    platform.rotation.y += platform.rotationSpeed;
                }
            }
            
            // Обновление вращающихся препятствий
            for (const wall of walls) {
                if (wall.isRotating) {
                    wall.rotation.y += wall.rotationSpeed;
                }
            }
        }
        
        // Обновление контрольных точек
        function updateCheckpoints() {
            for (let i = 0; i < scene.children.length; i++) {
                const object = scene.children[i];
                
                if (object.isCheckpoint) {
                    object.rotation.y += 0.01;
                    
                    // Проверка, находится ли игрок на этой контрольной точке
                    const distance = player.position.distanceTo(object.position);
                    
                    if (distance < 1.5 && currentCheckpoint !== object) {
                        currentCheckpoint = object;
                        
                        // Создание эффекта активации контрольной точки
                        createCheckpointEffect(object.position.clone());
                        
                        // Обновление счёта
                        score += 25;
                        document.getElementById('score').textContent = score;
                        
                        // Уведомление
                        showItemPickupNotification("Контрольная точка активирована");
                    }
                }
            }
        }
        
        // Создание эффекта активации контрольной точки
        function createCheckpointEffect(position) {
            // Создание частиц для эффекта активации
            const particleCount = 50;
            const particleGeometry = new THREE.BufferGeometry();
            const particleMaterial = new THREE.PointsMaterial({
                color: 0x00ffff,
                size: 0.2,
                transparent: true,
                opacity: 0.8
            });
            
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];
            
            for (let i = 0; i < particleCount; i++) {
                // Начальное положение в точке активации
                positions[i * 3] = position.x;
                positions[i * 3 + 1] = position.y;
                positions[i * 3 + 2] = position.z;
                
                // Случайная скорость во все стороны
                const angle = (i / particleCount) * Math.PI * 2;
                const speed = 0.1;
                
                velocities.push(new THREE.Vector3(
                    Math.cos(angle) * speed,
                    0.05 + Math.random() * 0.1,
                    Math.sin(angle) * speed
                ));
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
            
            // Добавление системы частиц для обновления
            particleSystems.push({
                particles: particles,
                velocities: velocities,
                life: 40 // Время жизни эффекта в кадрах
            });
        }
        
        // Обновление боссов
        function updateBosses() {
            for (let i = 0; i < bosses.length; i++) {
                const boss = bosses[i];
                
                // Обновление анимаций босса
                if (boss.animations) {
                    // Покачивание
                    if (boss.animations.bobbing) {
                        const bobbing = boss.animations.bobbing;
                        boss.position.y += Math.sin(Date.now() * 0.001 * bobbing.frequency + bobbing.offset) * bobbing.amplitude * 0.01;
                    }
                    
                    // Вращение
                    if (boss.animations.rotation) {
                        const rotation = boss.animations.rotation;
                        boss.rotation[rotation.axis.x ? 'x' : rotation.axis.y ? 'y' : 'z'] += rotation.speed;
                    }
                }
                
                // Обновление логики в зависимости от фазы атаки
                if (boss.isFinalBoss) {
                    boss.phaseTimer += deltaTime * 1000;
                    
                    // Смена фазы каждые 10 секунд
                    if (boss.phaseTimer > 10000) {
                        boss.phaseTimer = 0;
                        boss.attackPhase = (boss.attackPhase + 1) % 3;
                        
                        switch(boss.attackPhase) {
                            case 0: // Обычная фаза
                                boss.attackMode = 'normal';
                                break;
                            case 1: // Защитная фаза
                                boss.attackMode = 'shield';
                                // Создание защитного щита
                                createBossShield(boss);
                                break;
                            case 2: // Фаза ярости
                                boss.attackMode = 'rage';
                                boss.shootInterval = 500; // Более частые выстрелы
                                break;
                        }
                    }
                }
                
                // Обновление атак босса
                const now = Date.now();
                const direction = new THREE.Vector3();
                direction.subVectors(player.position, boss.position).normalize();
                
                // Проверка видимости игрока
                raycaster.set(boss.position, direction);
                const intersects = raycaster.intersectObjects(walls);
                
                // Если нет препятствий между боссом и игроком или босс в режиме ярости
                if (intersects.length === 0 || 
                    intersects[0].distance > boss.position.distanceTo(player.position) ||
                    boss.attackMode === 'rage') {
                    
                    // Движение к игроку
                    if (boss.attackMode !== 'shield') {
                        const newPosition = boss.position.clone();
                        newPosition.x += direction.x * boss.speed;
                        newPosition.z += direction.z * boss.speed;
                        
                        // Проверка коллизий
                        let canMove = true;
                        
                        for (const wall of walls) {
                            const bossBox = new THREE.Box3().setFromObject(boss);
                            bossBox.min.set(
                                newPosition.x - (boss.isFinalBoss ? 2.5 : 1.5),
                                newPosition.y,
                                newPosition.z - (boss.isFinalBoss ? 2.5 : 1.5)
                            );
                            bossBox.max.set(
                                newPosition.x + (boss.isFinalBoss ? 2.5 : 1.5),
                                newPosition.y + (boss.isFinalBoss ? 5 : 3),
                                newPosition.z + (boss.isFinalBoss ? 2.5 : 1.5)
                            );
                            
                                                        const wallBox = new THREE.Box3().setFromObject(wall);
                            
                            if (bossBox.intersectsBox(wallBox)) {
                                canMove = false;
                                break;
                            }
                        }
                        
                        // Применение движения, если нет коллизий
                        if (canMove) {
                            boss.position.copy(newPosition);
                        }
                    }
                    
                    // Поворот босса к игроку
                    boss.lookAt(player.position);
                    
                    // Атаки босса
                    if (now - boss.lastShot > boss.shootInterval) {
                        // Разные атаки в зависимости от режима
                        if (boss.attackMode === 'rage') {
                            // Залп из нескольких выстрелов
                            for (let j = 0; j < 3; j++) {
                                setTimeout(() => {
                                    if (boss.parent) bossShoot(boss, 'rage');
                                }, j * 200);
                            }
                        } else if (boss.attackMode === 'shield') {
                            // Круговая атака
                            for (let j = 0; j < 8; j++) {
                                const angle = (j / 8) * Math.PI * 2;
                                const direction = new THREE.Vector3(
                                    Math.cos(angle),
                                    0,
                                    Math.sin(angle)
                                );
                                setTimeout(() => {
                                    if (boss.parent) bossShoot(boss, 'shield', direction);
                                }, j * 100);
                            }
                        } else {
                            // Обычная атака
                            bossShoot(boss, 'normal');
                        }
                        
                        boss.lastShot = now;
                    }
                }
                
                // Обновление хелпера
                for (const helper of enemyHelpers) {
                    if (helper.enemyRef === boss) {
                        helper.position.copy(boss.position);
                        if (boss.isFinalBoss) {
                            helper.position.y = 3;
                        } else {
                            helper.position.y = 1.5;
                        }
                        break;
                    }
                }
            }
        }
        
        // Создание щита босса
        function createBossShield(boss) {
            const shieldGeometry = new THREE.SphereGeometry(4, 32, 32);
            const shieldMaterial = new THREE.MeshBasicMaterial({
                color: 0x4444ff,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            
            const shield = new THREE.Mesh(shieldGeometry, shieldMaterial);
            shield.position.y = boss.isFinalBoss ? 3 : 1.5;
            boss.add(shield);
            
            // Щит вращается
            shield.isRotating = true;
            shield.rotationSpeed = 0.02;
            
            // Щит исчезает через некоторое время
            setTimeout(() => {
                if (boss.parent) boss.remove(shield);
            }, 5000);
            
            return shield;
        }
        
        // Выстрел босса
        function bossShoot(boss, mode, customDirection) {
            // Создание пули
            const bulletGeometry = new THREE.SphereGeometry(0.2, 8, 8);
            let bulletMaterial;
            
            switch(mode) {
                case 'rage':
                    bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                    break;
                case 'shield':
                    bulletMaterial = new THREE.MeshBasicMaterial({ color: 0x4444ff });
                    break;
                default:
                    bulletMaterial = new THREE.MeshBasicMaterial({ 
                        color: boss.isFinalBoss ? 0xff00ff : 0xff0000 
                    });
            }
            
            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
            
            // Позиционирование пули
            bullet.position.copy(boss.position);
            bullet.position.y = boss.isFinalBoss ? 3 : 1.5;
            
            // Направление пули
            let direction;
            
            if (customDirection) {
                direction = customDirection;
            } else {
                direction = new THREE.Vector3();
                direction.subVectors(player.position, boss.position).normalize();
                
                // Добавление разброса в зависимости от режима
                const spread = mode === 'rage' ? 0.2 : 0.1;
                direction.x += (Math.random() - 0.5) * spread;
                direction.y += (Math.random() - 0.5) * spread;
                direction.z += (Math.random() - 0.5) * spread;
                direction.normalize();
            }
            
            // Скорость пули в зависимости от режима
            const speed = mode === 'rage' ? 1.2 : 0.8;
            bullet.velocity = direction.multiplyScalar(speed);
            
            // Добавление урона пуле
            bullet.damage = mode === 'rage' ? 20 : 10;
            
            // Создание эффекта вспышки выстрела
            createMuzzleFlash();
            
            // Добавление пули на сцену
            scene.add(bullet);
            enemyBullets.push(bullet);
            
            return bullet;
        }
        
        // Главный игровой цикл
        function animate() {
            requestAnimationFrame(animate);
            
            // Расчет времени между кадрами для плавного движения
            deltaTime = clock.getDelta();
            
            if (!gameOver && !levelCompleted) {
                // Обновление позиции игрока
                updatePlayer();
                
                // Обновление врагов
                updateEnemies();
                
                // Обновление боссов
                updateBosses();
                
                // Обновление пуль
                updateBullets();
                
                // Обновление пуль врагов
                updateEnemyBullets();
                
                // Обновление систем частиц
                updateParticleSystems();
                
                // Обновление коллектиблов
                updateCollectibles();
                
                // Обновление секретных дверей
                updateSecretDoors();
                
                // Обновление движущихся платформ
                updatePlatforms();
                
                // Обновление контрольных точек
                updateCheckpoints();
                
                // Обновление анимации покачивания при ходьбе
                updateHeadbob();
                
                // Обновление камеры для мобильных устройств
                if (isMobile) {
                    updateMobileCamera();
                }
                
                // Автоматическая стрельба при зажатой кнопке
                if (isShooting && !reloading && ammo > 0 && weapons[currentWeapon - 1].automatic) {
                    // Для автоматического оружия выстрелы уже обрабатываются через setInterval
                }
            }
            
            // Рендеринг сцены
            renderer.render(scene, camera);
        }
        
        // Обновление покачивания камеры при ходьбе
        function updateHeadbob() {
            if (isPlayerMoving && canJump) {
                headbobTimer += deltaTime * headbobSpeed * (isRunning ? 1.5 : 1.0);
                const bobOffset = Math.sin(headbobTimer) * headbobAmount;
                camera.position.y = bobOffset;
            } else {
                camera.position.y = 0;
            }
        }
        
        // Обновление камеры для мобильных устройств
        function updateMobileCamera() {
            if (lookJoystickPosition.x !== 0 || lookJoystickPosition.y !== 0) {
                player.rotation.y -= lookJoystickPosition.x * 0.1;
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x - lookJoystickPosition.y * 0.05));
            }
        }
        
        // Обновление позиции игрока
        function updatePlayer() {
            // Гравитация
            player.velocity.y -= GRAVITY;
            
            // Проверка столкновения с полом
            if (player.position.y < (isCrouching ? 1 : 2)) {
                player.position.y = isCrouching ? 1 : 2;
                player.velocity.y = 0;
                canJump = true;
            }
            
            // Обновление позиции по вертикали
            player.position.y += player.velocity.y;
            
            // Расчет направления движения
            const speed = isRunning ? RUNNING_SPEED : PLAYER_SPEED;
            
            if (isMobile) {
                // Для мобильных устройств используем значения джойстика
                player.direction.z = -joystickPosition.y; // Инвертированная ось Y для правильного движения
                player.direction.x = joystickPosition.x;
                isPlayerMoving = Math.abs(joystickPosition.x) > 0.1 || Math.abs(joystickPosition.y) > 0.1;
            } else {
                // Для ПК используем клавиши
                player.direction.z = Number(moveForward) - Number(moveBackward);
                player.direction.x = Number(moveRight) - Number(moveLeft);
            }
            
            player.direction.normalize();
            
            // Преобразование направления в соответствии с поворотом игрока
            if (player.direction.z !== 0) {
                player.velocity.z = player.direction.z * speed;
            }
            if (player.direction.x !== 0) {
                player.velocity.x = player.direction.x * speed;
            }
            
            // Если нет движения, постепенно замедляем
            if (player.direction.z === 0) {
                player.velocity.z *= 0.9;
            }
            if (player.direction.x === 0) {
                player.velocity.x *= 0.9;
            }
            
            // Вращение направления в соответствии с поворотом игрока
            const rotatedVelocity = player.velocity.clone();
            rotatedVelocity.applyAxisAngle(new THREE.Vector3(0, 1, 0), player.rotation.y);
            
            // Проверка коллизий перед движением
            const nextPosition = player.position.clone();
            nextPosition.x += rotatedVelocity.x;
            nextPosition.z += rotatedVelocity.z;
            
            // Проверка столкновений со стенами
            let canMove = true;
            
            for (const wall of walls) {
                const playerBox = new THREE.Box3().setFromObject(
                    new THREE.Mesh(
                        new THREE.BoxGeometry(1, isCrouching ? 1 : 2, 1),
                        new THREE.MeshBasicMaterial()
                    )
                );
                playerBox.min.set(
                    nextPosition.x - 0.5,
                    nextPosition.y - (isCrouching ? 0.5 : 1),
                    nextPosition.z - 0.5
                );
                playerBox.max.set(
                    nextPosition.x + 0.5,
                    nextPosition.y + (isCrouching ? 0.5 : 1),
                    nextPosition.z + 0.5
                );
                
                const wallBox = new THREE.Box3().setFromObject(wall);
                
                if (playerBox.intersectsBox(wallBox)) {
                    canMove = false;
                    break;
                }
            }
            
            // Применение движения, если нет коллизий
            if (canMove) {
                player.position.x += rotatedVelocity.x;
                player.position.z += rotatedVelocity.z;
            }
            
            // Проверка падения в пропасть
            if (player.position.y < -10) {
                // Возврат на контрольную точку или начальную позицию
                if (currentCheckpoint) {
                    player.position.set(
                        currentCheckpoint.position.x,
                        currentCheckpoint.position.y + 2,
                        currentCheckpoint.position.z
                    );
                } else {
                    player.position.set(0, 2, 0);
                }
                player.velocity.set(0, 0, 0);
                
                // Уменьшение здоровья за падение
                health -= 20;
                updateHealthBar();
                
                if (health <= 0) {
                    endGame();
                }
            }
        }
        
        // Обновление врагов
        function updateEnemies() {
            const now = Date.now();
            
            for (let i = 0; i < enemies.length; i++) {
                const enemy = enemies[i];
                
                // Обновление хелпера
                for (const helper of enemyHelpers) {
                    if (helper.enemyRef === enemy) {
                        helper.position.copy(enemy.position);
                        helper.position.y = 1.5;
                        break;
                    }
                }
                
                // Направление к игроку
                const direction = new THREE.Vector3();
                direction.subVectors(player.position, enemy.position).normalize();
                
                // Проверка видимости игрока
                raycaster.set(enemy.position, direction);
                const intersects = raycaster.intersectObjects(walls);
                
                // Если между врагом и игроком нет стен
                if (intersects.length === 0 || 
                    intersects[0].distance > enemy.position.distanceTo(player.position)) {
                    
                    // Движение к игроку
                    const newPosition = enemy.position.clone();
                    newPosition.x += direction.x * enemy.speed;
                    newPosition.z += direction.z * enemy.speed;
                    
                    // Проверка коллизий
                    let canMove = true;
                    
                    for (const wall of walls) {
                        const enemyBox = new THREE.Box3().setFromObject(
                            new THREE.Mesh(
                                new THREE.BoxGeometry(1.5, 3, 1.5),
                                new THREE.MeshBasicMaterial()
                            )
                        );
                        enemyBox.min.set(
                            newPosition.x - 0.75,
                            newPosition.y - 1.5,
                            newPosition.z - 0.75
                        );
                        enemyBox.max.set(
                            newPosition.x + 0.75,
                            newPosition.y + 1.5,
                            newPosition.z + 0.75
                        );
                        
                        const wallBox = new THREE.Box3().setFromObject(wall);
                        
                        if (enemyBox.intersectsBox(wallBox)) {
                            canMove = false;
                            break;
                        }
                    }
                    
                    // Применение движения, если нет коллизий
                    if (canMove) {
                        enemy.position.copy(newPosition);
                    }
                    
                    // Поворот врага к игроку
                    enemy.lookAt(player.position);
                    
                    // Стрельба в игрока
                    if (now - enemy.lastShot > enemy.shootInterval) {
                        enemyShoot(enemy);
                        enemy.lastShot = now;
                    }
                }
                
                // Анимация врага (покачивание)
                enemy.position.y = Math.sin(now * 0.003 + i) * 0.1;
                
                // Обновление коллайдера
                enemy.collider = new THREE.Box3().setFromObject(enemy);
            }
        }
        
        // Стрельба врага
        function enemyShoot(enemy) {
            // Создание пули
            const bulletGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
            
            // Позиционирование пули
            bullet.position.copy(enemy.position);
            bullet.position.y = 1.5;
            
            // Направление пули в игрока
            const direction = new THREE.Vector3();
            direction.subVectors(player.position, enemy.position).normalize();
            
            // Добавление небольшого разброса
            direction.x += (Math.random() - 0.5) * 0.1;
            direction.y += (Math.random() - 0.5) * 0.1;
            direction.z += (Math.random() - 0.5) * 0.1;
            direction.normalize();
            
            bullet.velocity = direction.multiplyScalar(0.7);
            
            // Создание эффекта вспышки выстрела
            const muzzlePosition = enemy.position.clone();
            muzzlePosition.y = 1.5;
            muzzlePosition.add(direction.clone().multiplyScalar(1));
            createEnemyMuzzleFlash(muzzlePosition);
            
            // Добавление пули на сцену
            scene.add(bullet);
            enemyBullets.push(bullet);
        }
        
        // Создание эффекта вспышки выстрела врага
        function createEnemyMuzzleFlash(position) {
            // Создание частиц для вспышки
            const particleCount = 15;
            const particleGeometry = new THREE.BufferGeometry();
            const particleMaterial = new THREE.PointsMaterial({
                color: 0xff3300,
                size: 0.1,
                transparent: true,
                opacity: 0.8
            });
            
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];
            
            for (let i = 0; i < particleCount; i++) {
                // Случайное положение вокруг точки вспышки
                const x = position.x + (Math.random() - 0.5) * 0.2;
                const y = position.y + (Math.random() - 0.5) * 0.2;
                const z = position.z + (Math.random() - 0.5) * 0.2;
                
                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;
                
                // Случайная скорость
                velocities.push(new THREE.Vector3(
                    (Math.random() - 0.5) * 0.1,
                    (Math.random() - 0.5) * 0.1,
                    (Math.random() - 0.5) * 0.1
                ));
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
            
            // Добавление системы частиц для обновления
            particleSystems.push({
                particles: particles,
                velocities: velocities,
                life: 8 // Время жизни эффекта в кадрах
            });
            
            // Создание света вспышки
            const flashLight = new THREE.PointLight(0xff5500, 1, 3);
            flashLight.position.copy(position);
            scene.add(flashLight);
            
            // Удаление света через короткое время
            setTimeout(() => {
                scene.remove(flashLight);
            }, 100);
        }
        
        // Обновление пуль
        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                
                // Перемещение пули
                bullet.position.add(bullet.velocity);
                
                // Проверка коллизий с врагами
                for (let j = 0; j < enemyHelpers.length; j++) {
                    const helper = enemyHelpers[j];
                    
                    const bulletBox = new THREE.Box3().setFromObject(bullet);
                    const enemyBox = new THREE.Box3().setFromObject(helper);
                    
                    if (bulletBox.intersectsBox(enemyBox)) {
                        hitEnemy(helper.enemyRef, i);
                        // Выход из цикла, так как пуля уже удалена
                        break;
                    }
                }
                
                // Если пуля все еще существует, проверяем коллизии со стенами
                if (i < bullets.length) {
                    // Проверка коллизий со стенами
                    for (const wall of walls) {
                        const bulletBox = new THREE.Box3().setFromObject(bullet);
                        const wallBox = new THREE.Box3().setFromObject(wall);
                        
                        if (bulletBox.intersectsBox(wallBox)) {
                            // Создание эффекта попадания в стену
                            createHitEffect(bullet.position.clone());
                            
                            scene.remove(bullet);
                            bullets.splice(i, 1);
                            break;
                        }
                    }
                }
                
                // Удаление пуль, которые улетели слишком далеко
                if (i < bullets.length && bullet.position.distanceTo(player.position) > 100) {
                    scene.remove(bullet);
                    bullets.splice(i, 1);
                }
            }
        }
        
        // Обновление пуль врагов
        function updateEnemyBullets() {
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const bullet = enemyBullets[i];
                
                // Перемещение пули
                bullet.position.add(bullet.velocity);
                
                // Проверка коллизий с игроком
                const bulletBox = new THREE.Box3().setFromObject(bullet);
                const playerBox = new THREE.Box3();
                
                playerBox.min.set(
                    player.position.x - 0.5,
                    player.position.y - (isCrouching ? 0.5 : 1),
                    player.position.z - 0.5
                );
                playerBox.max.set(
                    player.position.x + 0.5,
                    player.position.y + (isCrouching ? 0.5 : 1),
                    player.position.z + 0.5
                );
                
                if (bulletBox.intersectsBox(playerBox)) {
                    hitPlayer(i);
                    continue;
                }
                
                // Проверка коллизий со стенами
                for (const wall of walls) {
                    const wallBox = new THREE.Box3().setFromObject(wall);
                    
                    if (bulletBox.intersectsBox(wallBox)) {
                        // Создание эффекта попадания в стену
                        createHitEffect(bullet.position.clone());
                        
                        scene.remove(bullet);
                        enemyBullets.splice(i, 1);
                        break;
                    }
                }
                
                // Удаление пуль, которые улетели слишком далеко
                if (i < enemyBullets.length && bullet.position.distanceTo(player.position) > 100) {
                    scene.remove(bullet);
                    enemyBullets.splice(i, 1);
                }
            }
        }
    </script>
</body>
</html>
