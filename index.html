<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StaricBoll - 3D –®—É—Ç–µ—Ä –æ—Ç –ø–µ—Ä–≤–æ–≥–æ –ª–∏—Ü–∞</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Arial, sans-serif;
            background-color: #121212;
            color: white;
        }
        canvas {
            display: block;
        }
        #loader {
            position: fixed;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            background-color: #121212;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 1;
            transition: opacity 1s ease-out;
        }
        #loader h1 {
            font-size: 72px;
            color: #fff;
            text-shadow: 0 0 20px rgba(79, 220, 255, 0.7);
            letter-spacing: 5px;
            margin-bottom: 50px;
            opacity: 0;
            transform: translateY(30px);
            animation: fadeInUp 1.5s ease forwards 0.5s;
        }
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        .loader-bar {
            width: 300px;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
            margin-top: 20px;
        }
        .loader-progress {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #4FDCFF, #7165FF);
            border-radius: 4px;
            transition: width 0.5s ease;
            animation: loadProgress 3s ease forwards;
        }
        @keyframes loadProgress {
            0% { width: 0%; }
            100% { width: 100%; }
        }
        #code-check {
            position: fixed;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            background-color: #121212;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 999;
            opacity: 0;
            transform: scale(0.98);
            transition: opacity 0.7s ease, transform 0.7s ease;
        }
        #code-check.active {
            opacity: 1;
            transform: scale(1);
        }
        #code-check h2 {
            font-size: 36px;
            color: #fff;
            text-shadow: 0 0 10px rgba(79, 220, 255, 0.5);
            letter-spacing: 2px;
            margin-bottom: 30px;
            text-align: center;
        }
        #code-form {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 400px;
        }
        .code-input-container {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            width: 100%;
        }
        .code-digit {
            width: 50px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(79, 220, 255, 0.3);
            border-radius: 8px;
            color: white;
            font-size: 24px;
            text-align: center;
            transition: all 0.3s ease;
        }
        .code-digit:focus {
            outline: none;
            border-color: #4FDCFF;
            box-shadow: 0 0 15px rgba(79, 220, 255, 0.5);
        }
        #submit-code {
            background: linear-gradient(90deg, #4FDCFF, #7165FF);
            color: white;
            border: none;
            padding: 12px 40px;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 20px;
            width: 100%;
            max-width: 300px;
            letter-spacing: 1px;
            font-weight: 600;
        }
        #submit-code:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
        }
        #submit-code:active {
            transform: translateY(0);
        }
        #error-message {
            color: #ff5555;
            margin-top: 20px;
            font-size: 16px;
            height: 20px;
            text-align: center;
            transition: opacity 0.3s ease;
            opacity: 0;
        }
        #help-link {
            color: rgba(79, 220, 255, 0.7);
            margin-top: 30px;
            font-size: 16px;
            text-decoration: underline;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        #help-link:hover {
            color: #4FDCFF;
        }
        #instructions {
            position: fixed;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            background-color: rgba(18, 18, 18, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1001;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
            padding: 20px;
        }
        #instructions.active {
            opacity: 1;
            pointer-events: auto;
        }
        .instructions-container {
            background-color: #1c1c1c;
            border-radius: 15px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.5);
            position: relative;
            transform: translateY(30px);
            opacity: 0;
            transition: transform 0.5s ease, opacity 0.5s ease;
        }
        #instructions.active .instructions-container {
            transform: translateY(0);
            opacity: 1;
        }
        .instructions-container h3 {
            color: #4FDCFF;
            font-size: 24px;
            margin-bottom: 20px;
            text-align: center;
        }
        .instructions-container p {
            margin-bottom: 15px;
            line-height: 1.6;
        }
        .instructions-container ol {
            padding-left: 20px;
        }
        .instructions-container ol li {
            margin-bottom: 15px;
            line-height: 1.6;
        }
        #close-instructions {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            font-size: 24px;
            cursor: pointer;
            transition: color 0.3s ease;
        }
        #close-instructions:hover {
            color: white;
        }
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 18px;
            text-shadow: 1px 1px 2px black;
            pointer-events: none;
        }
        #health-bar {
            width: 200px;
            height: 20px;
            background-color: rgba(51, 51, 51, 0.7);
            margin-top: 10px;
            border-radius: 10px;
            overflow: hidden;
        }
        #health-fill {
            width: 100%;
            height: 100%;
            background-color: #0f0;
            transition: width 0.3s;
        }
        #ammo {
            margin-top: 10px;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.8);
            font-size: 24px;
            text-align: center;
            line-height: 20px;
            pointer-events: none;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }
        #game-over, #level-up, #quest-notification, #objective-complete {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 15px;
            display: none;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            transition: all 0.5s ease;
            animation: fadeInScale 0.5s ease forwards;
        }
        @keyframes fadeInScale {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }
        #level-up {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(47, 128, 237, 0.4));
            border: 2px solid #4FDCFF;
            max-width: 90%;
            width: 400px;
        }
        #level-up h2 {
            font-size: 36px;
            margin-bottom: 20px;
            color: #4FDCFF;
            text-shadow: 0 0 10px rgba(79, 220, 255, 0.5);
        }
        #level-up p {
            font-size: 20px;
            margin-bottom: 30px;
        }
        #quest-notification, #objective-complete {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(76, 175, 80, 0.4));
            border: 2px solid #76ff03;
            max-width: 90%;
            width: 400px;
            z-index: 900;
        }
        #quest-notification h3, #objective-complete h3 {
            font-size: 28px;
            margin-bottom: 15px;
            color: #76ff03;
            text-shadow: 0 0 10px rgba(118, 255, 3, 0.5);
        }
        #quest-description, #objective-description {
            font-size: 18px;
            margin-bottom: 20px;
            line-height: 1.5;
        }
        button {
            background: linear-gradient(90deg, #4FDCFF, #7165FF);
            border: none;
            color: white;
            padding: 12px 24px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 18px;
            margin: 15px 5px;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s ease;
            font-weight: 600;
            letter-spacing: 1px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
            background: linear-gradient(90deg, #5de2ff, #8370ff);
        }
        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }
        #device-selection {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            animation: fadeIn 1.2s ease-out;
        }
        @keyframes fadeIn {
            0% { opacity: 0; }
            100% { opacity: 1; }
        }
        #device-selection h1 {
            font-size: 48px;
            margin-bottom: 50px;
            text-align: center;
            color: #fff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            animation: titlePulse 2s infinite;
            letter-spacing: 2px;
        }
        @keyframes titlePulse {
            0% { text-shadow: 0 0 10px rgba(255, 255, 255, 0.5); }
            50% { text-shadow: 0 0 20px rgba(255, 255, 255, 0.8), 0 0 30px rgba(79, 220, 255, 0.6); }
            100% { text-shadow: 0 0 10px rgba(255, 255, 255, 0.5); }
        }
        .device-buttons {
            display: flex;
            gap: 40px;
            animation: slideUp 0.8s ease-out 0.4s both;
            flex-direction: row;
        }
        @media (max-width: 768px) {
            .device-buttons {
                flex-direction: column;
            }
        }
        @keyframes slideUp {
            0% { transform: translateY(50px); opacity: 0; }
            100% { transform: translateY(0); opacity: 1; }
        }
        .device-button {
            background: linear-gradient(145deg, #4FDCFF, #7165FF);
            color: white;
            border: none;
            padding: 20px 40px;
            font-size: 22px;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3), 
                        0 0 0 rgba(79, 220, 255, 0.4);
            position: relative;
            overflow: hidden;
            letter-spacing: 1px;
            font-weight: bold;
            text-transform: uppercase;
        }
        .device-button:before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.3) 0%, transparent 60%);
            transform: rotate(45deg);
            opacity: 0;
            transition: opacity 0.3s;
        }
        .device-button:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5), 
                        0 0 20px rgba(79, 220, 255, 0.6);
            background: linear-gradient(145deg, #5de2ff, #8370ff);
        }
        .device-button:hover:before {
            opacity: 1;
            animation: shine 1.5s infinite;
        }
        @keyframes shine {
            0% { opacity: 0.5; }
            50% { opacity: 0.8; }
            100% { opacity: 0.5; }
        }
        .device-button:active {
            transform: translateY(0) scale(0.98);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }
        #mobile-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            pointer-events: none;
            z-index: 800;
        }
        .joystick-area {
            position: absolute;
            bottom: 70px;
            left: 30px;
            width: 120px;
            height: 120px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 60px;
            pointer-events: auto;
        }
        .joystick {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.5);
            border-radius: 30px;
        }
        .action-buttons {
            position: absolute;
            bottom: 70px;
            right: 30px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            pointer-events: auto;
        }
        .action-button {
            width: 60px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: white;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        }
        .action-button:active {
            transform: scale(0.95);
            background-color: rgba(255, 255, 255, 0.4);
        }
        .look-area {
            position: absolute;
            bottom: 70px;
            right: 120px;
            width: 120px;
            height: 120px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 60px;
            pointer-events: auto;
        }
        .look-joystick {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.5);
            border-radius: 30px;
        }
        #reload-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            display: none;
            pointer-events: none;
        }
        #hit-marker {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: red;
            font-size: 40px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.1s;
        }
        #objective-indicator {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            text-align: center;
            z-index: 900;
            pointer-events: none;
            font-size: 18px;
            transition: opacity 0.5s ease;
            opacity: 0;
        }
        #objective-indicator.active {
            opacity: 1;
        }
        #inventory {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            pointer-events: none;
        }
        .inventory-slot {
            width: 60px;
            height: 60px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 16px;
            transition: all 0.3s ease;
        }
        .inventory-slot.active {
            border-color: #4FDCFF;
            box-shadow: 0 0 10px rgba(79, 220, 255, 0.5);
        }
        #item-pickup-notification {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            text-align: center;
            z-index: 900;
            pointer-events: none;
            font-size: 18px;
            transition: all 0.5s ease;
            opacity: 0;
        }
        .shake {
            animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
        }
        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }
        @media (max-width: 768px) {
            #hud {
                top: 10px;
                left: 10px;
                font-size: 16px;
            }
            #health-bar {
                width: 150px;
                height: 15px;
            }
            .action-buttons {
                bottom: 30px;
                right: 20px;
                gap: 10px;
            }
            .joystick-area {
                bottom: 30px;
                left: 20px;
            }
            .look-area {
                bottom: 30px;
                right: 100px;
            }
            .action-button {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }
            #inventory {
                bottom: 10px;
            }
            .inventory-slot {
                width: 45px;
                height: 45px;
                font-size: 14px;
            }
        }
        .weapon-switch {
            position: absolute;
            bottom: 30px;
            right: 300px;
            display: flex;
            gap: 15px;
            pointer-events: auto;
        }
        .weapon-button {
            width: 60px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: white;
            transition: all 0.2s ease;
        }
        .weapon-button.active {
            background-color: rgba(79, 220, 255, 0.5);
            box-shadow: 0 0 10px rgba(79, 220, 255, 0.5);
        }
        @media (max-width: 768px) {
            .weapon-switch {
                right: 200px;
            }
            .weapon-button {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loader">
        <h1>StaricBoll</h1>
        <div class="loader-bar">
            <div class="loader-progress"></div>
        </div>
    </div>

    <!-- Code Check Screen -->
    <div id="code-check">
        <h2>–í–≤–µ–¥–∏—Ç–µ –∫–æ–¥ –¥–æ—Å—Ç—É–ø–∞</h2>
        <form id="code-form">
            <div class="code-input-container">
                <input type="text" class="code-digit" maxlength="1" pattern="[0-9]" required>
                <input type="text" class="code-digit" maxlength="1" pattern="[0-9]" required>
                <input type="text" class="code-digit" maxlength="1" pattern="[0-9]" required>
                <input type="text" class="code-digit" maxlength="1" pattern="[0-9]" required>
                <input type="text" class="code-digit" maxlength="1" pattern="[0-9]" required>
                <input type="text" class="code-digit" maxlength="1" pattern="[0-9]" required>
            </div>
            <button type="submit" id="submit-code">–í–æ–π—Ç–∏</button>
        </form>
        <div id="error-message"></div>
        <div id="help-link">–ö–∞–∫ –º–Ω–µ –ø–æ–ª—É—á–∏—Ç—å –∫–æ–¥?</div>
    </div>

    <!-- Instructions Modal -->
    <div id="instructions">
        <div class="instructions-container">
            <button id="close-instructions">√ó</button>
            <h3>–ö–∞–∫ –ø–æ–ª—É—á–∏—Ç—å –∫–æ–¥ –¥–æ—Å—Ç—É–ø–∞</h3>
            <ol>
                <li>–í–∞–º –Ω—É–∂–Ω–æ –ø–µ—Ä–µ–π—Ç–∏ –Ω–∞ —Å–∞–π—Ç <a href="https://www.donationalerts.com/r/andrey291414" target="_blank" style="color: #4FDCFF;">donationalerts.com/r/andrey291414</a> –∏ –æ–ø–ª–∞—Ç–∏—Ç—å 99 –†—É–±–ª–µ–π. –ï—Å–ª–∏ —É –≤–∞—Å —É–∫–∞–∑–∞–Ω—ã –ï–≤—Ä–æ, —Ç–æ –ø–æ–º–µ–Ω—è–π—Ç–µ –∏—Ö –Ω–∞ –†—É–±–ª–∏.</li>
                <li><strong>–í–ê–ñ–ù–û:</strong> –ö–æ–≥–¥–∞ –≤—ã –ø–µ—Ä–µ–π–¥–µ—Ç–µ –ø–æ —Å—Å—ã–ª–∫–µ, —Ç–∞–º –±—É–¥–µ—Ç –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–∞—è –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è —á—Ç–æ –∏ –∫–∞–∫. <strong>–ü–†–û–ß–¢–ò–¢–ï –ï–ï –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û!!!</strong></li>
                <li>–ü–æ—Å–ª–µ –ø–æ–∫—É–ø–∫–∏ –Ω–∞ –≤–∞—à—É –ø–æ—á—Ç—É –ø–æ—Å—Ç—É–ø–∏—Ç 6-–∑–Ω–∞—á–Ω—ã–π –∫–æ–¥. –ï–≥–æ –Ω—É–∂–Ω–æ –±—É–¥–µ—Ç –≤–≤–µ—Å—Ç–∏ –≤ –ø–æ–ª–µ –¥–ª—è –≤–≤–æ–¥–∞ –∫–æ–¥–∞, –∏ —Ç–æ–≥–¥–∞ –≤—ã –ø–æ–ø–∞–¥–µ—Ç–µ –≤ –∏–≥—Ä—É, –∏ –≤–∞–º –±–æ–ª—å—à–µ –æ–ø–ª–∞—á–∏–≤–∞—Ç—å –¥–æ—Å—Ç—É–ø –±—É–¥–µ—Ç –Ω–µ –Ω—É–∂–Ω–æ.</li>
            </ol>
            <p>–í—ã –ø–æ–∫—É–ø–∞–µ—Ç–µ –∏–≥—Ä—É –Ω–∞ –≤—Å—é –∂–∏–∑–Ω—å –Ω–∞ —ç—Ç–æ–º IP –∞–¥—Ä–µ—Å–µ. –ü–æ—Å–ª–µ –ø–æ–∫—É–ø–∫–∏ –∏ –≤–≤–µ–¥–µ–Ω–∏—è –∫–æ–¥–∞ –≤–∞–º –Ω–µ –Ω—É–∂–Ω–æ –±—É–¥–µ—Ç –µ–≥–æ –±–æ–ª—å—à–µ –≤–≤–æ–¥–∏—Ç—å –Ω–∞ —ç—Ç–æ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ.</p>
        </div>
    </div>

    <div id="device-selection">
        <h1>–í—ã–±–µ—Ä–∏—Ç–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ</h1>
        <div class="device-buttons">
            <button class="device-button" id="pc-button">–ö–æ–º–ø—å—é—Ç–µ—Ä / –ù–æ—É—Ç–±—É–∫</button>
            <button class="device-button" id="mobile-button">–¢–µ–ª–µ—Ñ–æ–Ω / –ü–ª–∞–Ω—à–µ—Ç</button>
        </div>
    </div>

    <div id="hud">
        <div>–£—Ä–æ–≤–µ–Ω—å: <span id="level">1</span></div>
        <div>–û—á–∫–∏: <span id="score">0</span></div>
        <div>–ó–¥–æ—Ä–æ–≤—å–µ:</div>
        <div id="health-bar"><div id="health-fill"></div></div>
        <div id="ammo">–ü–∞—Ç—Ä–æ–Ω—ã: <span id="ammo-count">30</span> / <span id="max-ammo">30</span></div>
    </div>
    <div id="crosshair">+</div>
    <div id="hit-marker">√ó</div>
    <div id="reload-indicator">–ü–µ—Ä–µ–∑–∞—Ä—è–¥–∫–∞...</div>
    <div id="objective-indicator">–í–∞—à–∞ –∑–∞–¥–∞—á–∞: –ù–∞–π–¥–∏—Ç–µ –∫–ª—é—á</div>
    <div id="item-pickup-notification"></div>
    
    <div id="game-over">
        <h2>–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞</h2>
        <p>–í–∞—à —Å—á–µ—Ç: <span id="final-score">0</span></p>
        <button id="restart-button">–ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ</button>
    </div>
    <div id="level-up">
        <h2>–£—Ä–æ–≤–µ–Ω—å –ø—Ä–æ–π–¥–µ–Ω!</h2>
        <p>–ü–µ—Ä–µ—Ö–æ–¥ –Ω–∞ —É—Ä–æ–≤–µ–Ω—å <span id="new-level">2</span></p>
        <p id="level-description">–°–ª–µ–¥—É—é—â–∏–π —É—Ä–æ–≤–µ–Ω—å —Å–ª–æ–∂–Ω–µ–µ. –ò—â–∏—Ç–µ –∫–ª—é—á–∏, –æ—Ç–∫—Ä—ã–≤–∞–π—Ç–µ –¥–≤–µ—Ä–∏ –∏ —Å—Ä–∞–∂–∞–π—Ç–µ—Å—å —Å –Ω–æ–≤—ã–º–∏ –≤—Ä–∞–≥–∞–º–∏!</p>
        <button id="next-level-button">–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å</button>
    </div>
    
    <div id="quest-notification">
        <h3>–ù–æ–≤–æ–µ –∑–∞–¥–∞–Ω–∏–µ</h3>
        <p id="quest-description">–ù–∞–π–¥–∏—Ç–µ –∫–ª—é—á, —á—Ç–æ–±—ã –æ—Ç–∫—Ä—ã—Ç—å –¥–≤–µ—Ä—å –∏ –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å –ø—É—Ç—å</p>
        <button id="accept-quest-button">–ü—Ä–∏–Ω—è—Ç—å</button>
    </div>
    
        <div id="objective-complete">
        <h3>–ó–∞–¥–∞–Ω–∏–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ!</h3>
        <p id="objective-description">–í—ã –Ω–∞—à–ª–∏ –∫–ª—é—á. –¢–µ–ø–µ—Ä—å –Ω–∞–π–¥–∏—Ç–µ –¥–≤–µ—Ä—å!</p>
        <button id="continue-button">–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å</button>
    </div>

    <div id="inventory">
        <div class="inventory-slot" data-slot="1">1</div>
        <div class="inventory-slot active" data-slot="2">2</div>
        <div class="inventory-slot" data-slot="3">3</div>
    </div>

    <div id="mobile-controls">
        <div class="joystick-area">
            <div class="joystick" id="joystick"></div>
        </div>
        <div class="look-area">
            <div class="look-joystick" id="look-joystick"></div>
        </div>
        <div class="action-buttons">
            <div class="action-button" id="shoot-button">üî´</div>
            <div class="action-button" id="jump-button">‚Üë</div>
            <div class="action-button" id="reload-button">‚Üª</div>
            <div class="action-button" id="interact-button">‚úã</div>
        </div>
        <div class="weapon-switch">
            <div class="weapon-button active" id="weapon-1">1</div>
            <div class="weapon-button" id="weapon-2">2</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–≥—Ä—É–∑–æ—á–Ω–æ–≥–æ —ç–∫—Ä–∞–Ω–∞ –∏ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∫–æ–¥–∞
        document.addEventListener('DOMContentLoaded', function() {
            // –ê–Ω–∏–º–∞—Ü–∏—è –∑–∞–≥—Ä—É–∑–æ—á–Ω–æ–≥–æ —ç–∫—Ä–∞–Ω–∞
            setTimeout(function() {
                document.getElementById('loader').style.opacity = '0';
                setTimeout(function() {
                    document.getElementById('loader').style.display = 'none';
                    document.getElementById('code-check').classList.add('active');
                }, 1000);
            }, 3000);

            // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Ñ–æ—Ä–º—ã –≤–≤–æ–¥–∞ –∫–æ–¥–∞
            const codeInputs = document.querySelectorAll('.code-digit');
            const form = document.getElementById('code-form');
            const errorMessage = document.getElementById('error-message');
            
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∞–≤—Ç–æ–ø–µ—Ä–µ—Ö–æ–¥–∞ –º–µ–∂–¥—É –ø–æ–ª—è–º–∏ –≤–≤–æ–¥–∞
            codeInputs.forEach((input, index) => {
                input.addEventListener('input', function() {
                    if (this.value && index < codeInputs.length - 1) {
                        codeInputs[index + 1].focus();
                    }
                });
                
                input.addEventListener('keydown', function(e) {
                    if (e.key === 'Backspace' && !this.value && index > 0) {
                        codeInputs[index - 1].focus();
                    }
                });
            });
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–¥–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Ñ–æ—Ä–º—ã
            form.addEventListener('submit', function(e) {
                e.preventDefault();
                
                let code = '';
                codeInputs.forEach(input => {
                    code += input.value;
                });
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–¥–∞
                checkCode(code);
            });
            
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å—Å—ã–ª–∫–∏ –ø–æ–º–æ—â–∏
            document.getElementById('help-link').addEventListener('click', function() {
                document.getElementById('instructions').classList.add('active');
            });
            
            // –ó–∞–∫—Ä—ã—Ç–∏–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–π
            document.getElementById('close-instructions').addEventListener('click', function() {
                document.getElementById('instructions').classList.remove('active');
            });
            
            // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∫–æ–¥–∞
            function checkCode(code) {
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–¥ –±–µ–∑ –ø—Ä—è–º–æ–≥–æ —É–∫–∞–∑–∞–Ω–∏—è –≤ –∏—Å—Ö–æ–¥–Ω–æ–º –∫–æ–¥–µ
                const correctCode = atob('MjkxNDE0'); // –ó–∞–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–æ–¥ –≤ base64
                
                if (code === correctCode) {
                    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ localStorage –ø—Ä–∏–∑–Ω–∞–∫ —Ç–æ–≥–æ, —á—Ç–æ –∫–æ–¥ –±—ã–ª –≤–≤–µ–¥–µ–Ω
                    localStorage.setItem('gameAccess', 'true');
                    
                    // –ü–ª–∞–≤–Ω–æ–µ —Å–∫—Ä—ã—Ç–∏–µ —ç–∫—Ä–∞–Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∫–æ–¥–∞
                    document.getElementById('code-check').style.opacity = '0';
                    setTimeout(function() {
                        document.getElementById('code-check').style.display = 'none';
                        // –ü–æ–∫–∞–∑ —ç–∫—Ä–∞–Ω–∞ –≤—ã–±–æ—Ä–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
                        document.getElementById('device-selection').style.display = 'flex';
                    }, 700);
                } else {
                    // –ü–æ–∫–∞–∑ —Å–æ–æ–±—â–µ–Ω–∏—è –æ–± –æ—à–∏–±–∫–µ
                    errorMessage.textContent = '–ù–µ–≤–µ—Ä–Ω—ã–π –∫–æ–¥ –¥–æ—Å—Ç—É–ø–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.';
                    errorMessage.style.opacity = '1';
                    
                    // –û—á–∏—Å—Ç–∫–∞ –ø–æ–ª–µ–π –≤–≤–æ–¥–∞
                    codeInputs.forEach(input => {
                        input.value = '';
                    });
                    codeInputs[0].focus();
                    
                    // –ê–Ω–∏–º–∞—Ü–∏—è —Ç—Ä—è—Å–∫–∏ —Ñ–æ—Ä–º—ã
                    form.classList.add('shake');
                    setTimeout(function() {
                        form.classList.remove('shake');
                    }, 600);
                }
            }
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –±—ã–ª –ª–∏ —Ä–∞–Ω–µ–µ –≤–≤–µ–¥–µ–Ω –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –∫–æ–¥
            if (localStorage.getItem('gameAccess') === 'true') {
                document.getElementById('loader').style.opacity = '0';
                setTimeout(function() {
                    document.getElementById('loader').style.display = 'none';
                    document.getElementById('code-check').style.display = 'none';
                    document.getElementById('device-selection').style.display = 'flex';
                }, 1000);
            }
        });

        // –û—Å–Ω–æ–≤–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        let scene, camera, renderer, player, controls;
        let enemies = [];
        let bullets = [];
        let enemyBullets = [];
        let walls = [];
        let floor;
        let raycaster;
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let canJump = false;
        let isShooting = false;
        let isCrouching = false;
        let isRunning = false;
        let health = 100;
        let score = 0;
        let level = 1;
        let ammo = 30;
        let maxAmmo = 30;
        let reloading = false;
        let gameOver = false;
        let levelCompleted = false;
        let isMobile = false;
        let joystickPosition = { x: 0, y: 0 };
        let lookJoystickPosition = { x: 0, y: 0 };
        let touchLookPosition = { x: 0, y: 0 };
        let lastTouchLookPosition = { x: 0, y: 0 };
        let touchShootId = null;
        let clock = new THREE.Clock();
        let deltaTime = 0;
        let targetEnemy = null;
        let enemyHelpers = [];
        let skybox;
        let textures = {};
        let sounds = {};
        let particleSystems = [];
        let platforms = [];
        let collectibles = [];
        let hasCollectibleKey = false;
        let secretDoors = [];
        let currentCheckpoint = null;
        let currentWeapon = 1;
        let weapons = [
            { name: "–ü–∏—Å—Ç–æ–ª–µ—Ç", damage: 25, ammo: 30, maxAmmo: 30, shootInterval: 200, automatic: false },
            { name: "–ê–≤—Ç–æ–º–∞—Ç", damage: 15, ammo: 45, maxAmmo: 45, shootInterval: 100, automatic: true }
        ];
        let playerInventory = [];
        let currentQuest = null;
        let headbobTimer = 0;
        let headbobAmount = 0.05;
        let headbobSpeed = 10;
        let isPlayerMoving = false;
        let objectives = [];
        let doors = [];
        let keys = [];
        let currentObjective = null;
        let bosses = [];
        
        // –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã
        const ENEMY_COUNT_BASE = 5;
        const LEVEL_SIZE_BASE = 100;
        const ENEMY_SPEED_BASE = 0.05;
        const PLAYER_SPEED = 0.15;
        const RUNNING_SPEED = 0.25;
        const GRAVITY = 0.005;
        const JUMP_FORCE = 0.2;
        const AUTO_AIM_DISTANCE = 20;
        const AUTO_AIM_ANGLE = 0.3;
        
        // –ü—Ä–µ–¥–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–µ —É—Ä–æ–≤–Ω–∏ –∏ –∑–∞–¥–∞–Ω–∏—è
        const LEVELS = [
            {
                name: "–û–±—É—á–µ–Ω–∏–µ",
                description: "–ò–∑—É—á–∏—Ç–µ –æ—Å–Ω–æ–≤—ã —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∏ —É–Ω–∏—á—Ç–æ–∂—å—Ç–µ –≤—Ä–∞–≥–æ–≤.",
                objectives: [
                    { type: "key", description: "–ù–∞–π–¥–∏—Ç–µ –∫–ª—é—á –¥–ª—è –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è" },
                    { type: "door", description: "–ù–∞–π–¥–∏—Ç–µ –∏ –æ—Ç–∫—Ä–æ–π—Ç–µ –¥–≤–µ—Ä—å –∫–ª—é—á–æ–º" },
                    { type: "kill", description: "–£–Ω–∏—á—Ç–æ–∂—å—Ç–µ –≤—Å–µ—Ö –≤—Ä–∞–≥–æ–≤", count: 5 }
                ]
            },
            {
                name: "–õ–∞–±–∏—Ä–∏–Ω—Ç",
                description: "–ù–∞–π–¥–∏—Ç–µ –ø—É—Ç—å —á–µ—Ä–µ–∑ –ª–∞–±–∏—Ä–∏–Ω—Ç –∏ —Å–æ–±–µ—Ä–∏—Ç–µ –≤—Å–µ –∫–ª—é—á–∏.",
                objectives: [
                    { type: "collect", description: "–°–æ–±–µ—Ä–∏—Ç–µ 3 –∫–ª—é—á–∞", count: 3 },
                    { type: "door", description: "–ù–∞–π–¥–∏—Ç–µ —Ç–∞–π–Ω—ã–π –ø—Ä–æ—Ö–æ–¥" },
                    { type: "kill", description: "–£–Ω–∏—á—Ç–æ–∂—å—Ç–µ –ø—Ä–æ–¥–≤–∏–Ω—É—Ç—ã—Ö –≤—Ä–∞–≥–æ–≤", count: 8 }
                ]
            },
            {
                name: "–ö—Ä–µ–ø–æ—Å—Ç—å",
                description: "–ü—Ä–æ–±–µ—Ä–∏—Ç–µ—Å—å —á–µ—Ä–µ–∑ –∫—Ä–µ–ø–æ—Å—Ç—å –∏ –Ω–∞–π–¥–∏—Ç–µ –æ—Ä—É–∂–∏–µ.",
                objectives: [
                    { type: "weapon", description: "–ù–∞–π–¥–∏—Ç–µ –∞–≤—Ç–æ–º–∞—Ç" },
                    { type: "kill", description: "–£–Ω–∏—á—Ç–æ–∂—å—Ç–µ –æ—Ö—Ä–∞–Ω–Ω–∏–∫–æ–≤", count: 10 },
                    { type: "boss", description: "–ü–æ–±–µ–¥–∏—Ç–µ –±–æ—Å—Å–∞ –∫—Ä–µ–ø–æ—Å—Ç–∏" }
                ]
            },
            {
                name: "–ü–æ–¥–∑–µ–º–µ–ª—å–µ",
                description: "–ò—Å—Å–ª–µ–¥—É–π—Ç–µ –ø–æ–¥–∑–µ–º–µ–ª—å–µ –∏ –Ω–∞–π–¥–∏—Ç–µ –≤—Å–µ —Å–µ–∫—Ä–µ—Ç—ã.",
                objectives: [
                    { type: "collect", description: "–°–æ–±–µ—Ä–∏—Ç–µ 5 –∞—Ä—Ç–µ—Ñ–∞–∫—Ç–æ–≤", count: 5 },
                    { type: "platform", description: "–ü—Ä–µ–æ–¥–æ–ª–µ–π—Ç–µ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã –Ω–∞–¥ –ª–∞–≤–æ–π" },
                    { type: "boss", description: "–ü–æ–±–µ–¥–∏—Ç–µ —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ –±–æ—Å—Å–∞" }
                ]
            }
        ];
        
        // –í—ã–±–æ—Ä —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
        document.getElementById('pc-button').addEventListener('click', function() {
            isMobile = false;
            document.getElementById('device-selection').style.display = 'none';
            init();
        });
        
        document.getElementById('mobile-button').addEventListener('click', function() {
            isMobile = true;
            document.getElementById('device-selection').style.display = 'none';
            document.getElementById('mobile-controls').style.display = 'block';
            init();
        });
        
        // –ü—Ä–µ–¥–∑–∞–≥—Ä—É–∑–∫–∞ —Ç–µ–∫—Å—Ç—É—Ä
        function preloadTextures() {
            const textureLoader = new THREE.TextureLoader();
            
            // –ó–∞–≥—Ä—É–∑–∫–∞ —Ç–µ–∫—Å—Ç—É—Ä
            textures.ground = textureLoader.load('https://threejs.org/examples/textures/floors/FloorsCheckerboard_S_Diffuse.jpg', function(texture) {
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(10, 10);
            });
            
            textures.wall = textureLoader.load('https://threejs.org/examples/textures/brick_diffuse.jpg', function(texture) {
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(2, 2);
            });
            
            textures.metal = textureLoader.load('https://threejs.org/examples/textures/metal.jpg', function(texture) {
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(1, 1);
            });
            
            textures.wood = textureLoader.load('https://threejs.org/examples/textures/wood.jpg', function(texture) {
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(1, 1);
            });
            
            textures.enemy = textureLoader.load('https://threejs.org/examples/textures/uv_grid_opengl.jpg');
            
            // –ó–∞–≥—Ä—É–∑–∫–∞ –∫—É–±–∏—á–µ—Å–∫–æ–π —Ç–µ–∫—Å—Ç—É—Ä—ã –¥–ª—è skybox
            const cubeTextureLoader = new THREE.CubeTextureLoader();
            textures.skybox = cubeTextureLoader.load([
                'https://threejs.org/examples/textures/cube/skybox/px.jpg',
                'https://threejs.org/examples/textures/cube/skybox/nx.jpg',
                'https://threejs.org/examples/textures/cube/skybox/py.jpg',
                'https://threejs.org/examples/textures/cube/skybox/ny.jpg',
                'https://threejs.org/examples/textures/cube/skybox/pz.jpg',
                'https://threejs.org/examples/textures/cube/skybox/nz.jpg'
            ]);
            
            // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ç–µ–∫—Å—Ç—É—Ä—ã –¥–ª—è —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–Ω—ã—Ö –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–µ–π
            textures.lava = textureLoader.load('https://threejs.org/examples/textures/lava/lavatile.jpg', function(texture) {
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(5, 5);
            });
            
            textures.grass = textureLoader.load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg', function(texture) {
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(10, 10);
            });
            
            textures.crate = textureLoader.load('https://threejs.org/examples/textures/crate.gif');
        }
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–≥—Ä—ã
        function init() {
            // –ü—Ä–µ–¥–∑–∞–≥—Ä—É–∑–∫–∞ —Ç–µ–∫—Å—Ç—É—Ä
            preloadTextures();
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —Å—Ü–µ–Ω—ã
            scene = new THREE.Scene();
            scene.background = textures.skybox || new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 0, 500);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –∫–∞–º–µ—Ä—ã
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = 2;
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —Ä–µ–Ω–¥–µ—Ä–µ—Ä–∞ —Å –∞–Ω—Ç–∏–∞–ª–∏–∞—Å–∏–Ω–≥–æ–º –¥–ª—è –ª—É—á—à–µ–π –≥—Ä–∞—Ñ–∏–∫–∏
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                powerPreference: "high-performance" 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio > 2 ? 2 : window.devicePixelRatio); // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // –ú—è–≥–∫–∏–µ —Ç–µ–Ω–∏
            document.body.appendChild(renderer.domElement);
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –æ—Å–≤–µ—â–µ–Ω–∏—è
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(100, 100, 100);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            scene.add(directionalLight);
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ç–æ—á–µ—á–Ω—ã—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤ —Å–≤–µ—Ç–∞ –¥–ª—è –±–æ–ª–µ–µ —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω–æ–≥–æ –æ—Å–≤–µ—â–µ–Ω–∏—è
            const pointLight1 = new THREE.PointLight(0xffaa00, 1, 50);
            pointLight1.position.set(10, 15, 10);
            pointLight1.castShadow = true;
            scene.add(pointLight1);
            
            const pointLight2 = new THREE.PointLight(0x0044ff, 1, 50);
            pointLight2.position.set(-10, 15, -10);
            pointLight2.castShadow = true;
            scene.add(pointLight2);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –∏–≥—Ä–æ–∫–∞ (–∫–∞–º–µ—Ä–∞ + —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ)
            player = new THREE.Object3D();
            player.position.set(0, 2, 0);
            player.add(camera);
            scene.add(player);
            
            // –§–∏–∑–∏–∫–∞ –∏–≥—Ä–æ–∫–∞
            player.velocity = new THREE.Vector3();
            player.direction = new THREE.Vector3();
            
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ä–µ–π–∫–∞—Å—Ç–µ—Ä–∞ –¥–ª—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è –∫–æ–ª–ª–∏–∑–∏–π
            raycaster = new THREE.Raycaster();
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —É—Ä–æ–≤–Ω—è
            createLevel();
            
            // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
            if (isMobile) {
                setupMobileControls();
            } else {
                setupPCControls();
            }
            
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞ –æ–∫–Ω–∞
            window.addEventListener('resize', onWindowResize, false);
            
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–Ω–≤–µ–Ω—Ç–∞—Ä—è
            setupInventory();
            
            // –ü–æ–∫–∞–∑ –ø–µ—Ä–≤–æ–≥–æ –∑–∞–¥–∞–Ω–∏—è
            showObjective(LEVELS[level-1].objectives[0]);
            
            // –ó–∞–ø—É—Å–∫ –∏–≥—Ä–æ–≤–æ–≥–æ —Ü–∏–∫–ª–∞
            animate();
        }
        
        // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∏–Ω–≤–µ–Ω—Ç–∞—Ä—è
        function setupInventory() {
            const inventorySlots = document.querySelectorAll('.inventory-slot');
            
            inventorySlots.forEach(slot => {
                slot.addEventListener('click', function() {
                    const slotNum = parseInt(slot.getAttribute('data-slot'));
                    switchWeapon(slotNum);
                });
            });
            
            // –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –Ω–∞—á–∞–ª—å–Ω–æ–≥–æ –æ—Ä—É–∂–∏—è
            switchWeapon(1);
        }
        
        // –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –æ—Ä—É–∂–∏—è
        function switchWeapon(weaponNum) {
            if (weaponNum < 1 || weaponNum > weapons.length || weaponNum === currentWeapon) return;
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ UI
            document.querySelectorAll('.inventory-slot').forEach(slot => {
                slot.classList.remove('active');
            });
            
            document.querySelector(`.inventory-slot[data-slot="${weaponNum}"]`).classList.add('active');
            
            if (isMobile) {
                document.querySelectorAll('.weapon-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.getElementById(`weapon-${weaponNum}`).classList.add('active');
            }
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç–µ–∫—É—â–µ–≥–æ –æ—Ä—É–∂–∏—è
            currentWeapon = weaponNum;
            ammo = weapons[currentWeapon - 1].ammo;
            maxAmmo = weapons[currentWeapon - 1].maxAmmo;
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ UI –ø–∞—Ç—Ä–æ–Ω–æ–≤
            document.getElementById('ammo-count').textContent = ammo;
            document.getElementById('max-ammo').textContent = maxAmmo;
            
            // –ü–æ–∫–∞–∑ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ —Å–º–µ–Ω–µ –æ—Ä—É–∂–∏—è
            showItemPickupNotification(`–í—ã–±—Ä–∞–Ω–æ: ${weapons[currentWeapon - 1].name}`);
        }
        
        // –ü–æ–∫–∞–∑ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –ø–æ–¥–±–æ—Ä–µ –ø—Ä–µ–¥–º–µ—Ç–∞
        function showItemPickupNotification(message) {
            const notification = document.getElementById('item-pickup-notification');
            notification.textContent = message;
            notification.style.opacity = '1';
            
            setTimeout(() => {
                notification.style.opacity = '0';
            }, 2000);
        }
        
        // –ü–æ–∫–∞–∑ –∑–∞–¥–∞–Ω–∏—è
        function showObjective(objective) {
            currentObjective = objective;
            
            const indicator = document.getElementById('objective-indicator');
            indicator.textContent = `–ó–∞–¥–∞—á–∞: ${objective.description}`;
            indicator.classList.add('active');
            
            // –ü–æ–∫–∞–∑ –º–æ–¥–∞–ª—å–Ω–æ–≥–æ –æ–∫–Ω–∞ —Å –∑–∞–¥–∞–Ω–∏–µ–º
            const notification = document.getElementById('quest-notification');
            const description = document.getElementById('quest-description');
            description.textContent = objective.description;
            notification.style.display = 'block';
            
            document.getElementById('accept-quest-button').addEventListener('click', function() {
                notification.style.display = 'none';
            }, { once: true });
        }
        
        // –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –∑–∞–¥–∞–Ω–∏—è
        function completeObjective() {
            const notification = document.getElementById('objective-complete');
            const description = document.getElementById('objective-description');
            description.textContent = `–í—ã –≤—ã–ø–æ–ª–Ω–∏–ª–∏ –∑–∞–¥–∞–Ω–∏–µ: ${currentObjective.description}`;
            notification.style.display = 'block';
            
            // –£–≤–µ–ª–∏—á–µ–Ω–∏–µ —Å—á–µ—Ç–∞
            score += 200;
            document.getElementById('score').textContent = score;
            
            document.getElementById('continue-button').addEventListener('click', function() {
                notification.style.display = 'none';
                
                // –ü–µ—Ä–µ—Ö–æ–¥ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É –∑–∞–¥–∞–Ω–∏—é
                const levelData = LEVELS[level-1];
                const currentIndex = levelData.objectives.indexOf(currentObjective);
                
                if (currentIndex < levelData.objectives.length - 1) {
                    showObjective(levelData.objectives[currentIndex + 1]);
                } else {
                    levelComplete();
                }
            }, { once: true });
            
            // –°–∫—Ä—ã—Ç–∏–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞ –∑–∞–¥–∞–Ω–∏—è
            document.getElementById('objective-indicator').classList.remove('active');
        }
        
        // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –¥–ª—è –ü–ö
        function setupPCControls() {
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);
            document.addEventListener('mousedown', onMouseDown, false);
            document.addEventListener('mouseup', onMouseUp, false);
            
            // –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ —É–∫–∞–∑–∞—Ç–µ–ª—è –º—ã—à–∏
            renderer.domElement.addEventListener('click', function() {
                renderer.domElement.requestPointerLock();
            });
            
            document.addEventListener('pointerlockchange', lockChangeAlert, false);
            
            // –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –æ—Ä—É–∂–∏—è –Ω–∞ –∫–ª–∞–≤–∏—à–∏ 1-9
            document.addEventListener('keydown', function(e) {
                if (e.key >= '1' && e.key <= '9') {
                    const weaponNum = parseInt(e.key);
                    if (weaponNum <= weapons.length) {
                        switchWeapon(weaponNum);
                    }
                }
                
                // –í–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ –Ω–∞ –∫–ª–∞–≤–∏—à—É E
                if (e.key === 'e' || e.key === 'E') {
                    interact();
                }
            });
        }
        
        // –§—É–Ω–∫—Ü–∏—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è —Å –æ–±—ä–µ–∫—Ç–∞–º–∏
        function interact() {
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –±–ª–∏–∑–æ—Å—Ç—å –∫ –¥–≤–µ—Ä—è–º, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–∂–Ω–æ –æ—Ç–∫—Ä—ã—Ç—å –∫–ª—é—á–æ–º
            if (hasCollectibleKey) {
                for (const door of secretDoors) {
                    if (!door.isOpen) {
                        const distance = player.position.distanceTo(door.position);
                        if (distance < 5) {
                            openDoor(door);
                            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ –∑–∞–¥–∞–Ω–∏—è
                            if (currentObjective && currentObjective.type === 'door') {
                                completeObjective();
                            }
                            break;
                        }
                    }
                }
            }
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –±–ª–∏–∑–æ—Å—Ç–∏ –∫ –∫–æ–ª–ª–µ–∫—Ç–∏–±–ª–∞–º
            for (let i = collectibles.length - 1; i >= 0; i--) {
                const collectible = collectibles[i];
                const distance = player.position.distanceTo(collectible.position);
                
                if (distance < 3) {
                    collectItem(collectible);
                    scene.remove(collectible);
                    collectibles.splice(i, 1);
                    break;
                }
            }
        }
        
        // –û—Ç–∫—Ä—ã—Ç–∏–µ –¥–≤–µ—Ä–∏
        function openDoor(door) {
            if (!door.isOpen) {
                // –û—Ç–∫—Ä—ã—Ç–∏–µ –¥–≤–µ—Ä–∏
                door.isOpen = true;
                
                // –ê–Ω–∏–º–∞—Ü–∏—è –æ—Ç–∫—Ä—ã—Ç–∏—è –¥–≤–µ—Ä–∏ - –ø–ª–∞–≤–Ω–æ–µ –æ–ø—É—Å–∫–∞–Ω–∏–µ
                const targetY = door.position.y - door.geometry.parameters.height;
                
                // –°–æ–∑–¥–∞–µ–º –ø—Ä–æ—Å—Ç—É—é –∞–Ω–∏–º–∞—Ü–∏—é –≤–º–µ—Å—Ç–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –∞–Ω–∏–º–∞—Ü–∏–∏
                door.animation = {
                    startY: door.position.y,
                    targetY: targetY,
                    progress: 0,
                    speed: 0.02
                };
                
                // –£–¥–∞–ª—è–µ–º –¥–≤–µ—Ä—å –∏–∑ –º–∞—Å—Å–∏–≤–∞ —Å—Ç–µ–Ω, —á—Ç–æ–±—ã –∏–≥—Ä–æ–∫ –º–æ–≥ –ø—Ä–æ–π—Ç–∏
                const doorIndex = walls.indexOf(door);
                if (doorIndex !== -1) {
                    walls.splice(doorIndex, 1);
                }
                
                // –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
                showItemPickupNotification("–î–≤–µ—Ä—å –æ—Ç–∫—Ä—ã—Ç–∞!");
                
                // –ó–≤—É–∫–æ–≤–æ–π —ç—Ñ—Ñ–µ–∫—Ç
                // playSound('door');
            }
        }
        
        // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤
        function setupMobileControls() {
            // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –¥–∂–æ–π—Å—Ç–∏–∫–∞ –¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è
            const joystickArea = document.querySelector('.joystick-area');
            const joystick = document.getElementById('joystick');
            
            joystickArea.addEventListener('touchstart', function(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = joystickArea.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                updateJoystickPosition(touch.clientX - centerX, touch.clientY - centerY);
            });
            
            joystickArea.addEventListener('touchmove', function(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = joystickArea.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                updateJoystickPosition(touch.clientX - centerX, touch.clientY - centerY);
            });
            
            joystickArea.addEventListener('touchend', function(e) {
                e.preventDefault();
                resetJoystick();
            });
            
            // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –¥–∂–æ–π—Å—Ç–∏–∫–∞ –¥–ª—è –æ–±–∑–æ—Ä–∞
            const lookArea = document.querySelector('.look-area');
            const lookJoystick = document.getElementById('look-joystick');
            
            lookArea.addEventListener('touchstart', function(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = lookArea.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                lastTouchLookPosition.x = touch.clientX;
                lastTouchLookPosition.y = touch.clientY;
                touchLookPosition.x = touch.clientX;
                touchLookPosition.y = touch.clientY;
                
                updateLookJoystickPosition(touch.clientX - centerX, touch.clientY - centerY);
            });
            
            lookArea.addEventListener('touchmove', function(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = lookArea.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                touchLookPosition.x = touch.clientX;
                touchLookPosition.y = touch.clientY;
                
                updateLookJoystickPosition(touch.clientX - centerX, touch.clientY - centerY);
            });
            
            lookArea.addEventListener('touchend', function(e) {
                e.preventDefault();
                resetLookJoystick();
            });
            
            // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∫–Ω–æ–ø–æ–∫ –¥–µ–π—Å—Ç–≤–∏–π
            document.getElementById('shoot-button').addEventListener('touchstart', function(e) {
                e.preventDefault();
                isShooting = true;
                shoot();
                touchShootId = setInterval(shoot, weapons[currentWeapon - 1].shootInterval);
            });
            
            document.getElementById('shoot-button').addEventListener('touchend', function(e) {
                e.preventDefault();
                isShooting = false;
                if (touchShootId !== null) {
                    clearInterval(touchShootId);
                    touchShootId = null;
                }
            });
            
            document.getElementById('jump-button').addEventListener('touchstart', function(e) {
                e.preventDefault();
                if (canJump) {
                    player.velocity.y = JUMP_FORCE;
                    canJump = false;
                }
            });
            
            document.getElementById('reload-button').addEventListener('touchstart', function(e) {
                e.preventDefault();
                reload();
            });
            
            document.getElementById('interact-button').addEventListener('touchstart', function(e) {
                e.preventDefault();
                interact();
            });
            
            // –ö–Ω–æ–ø–∫–∏ –≤—ã–±–æ—Ä–∞ –æ—Ä—É–∂–∏—è
            document.getElementById('weapon-1').addEventListener('touchstart', function(e) {
                e.preventDefault();
                switchWeapon(1);
            });
            
            document.getElementById('weapon-2').addEventListener('touchstart', function(e) {
                e.preventDefault();
                switchWeapon(2);
            });
        }
        
        function updateJoystickPosition(x, y) {
            const maxDistance = 40;
            const distance = Math.sqrt(x * x + y * y);
            
            if (distance > maxDistance) {
                const ratio = maxDistance / distance;
                x *= ratio;
                y *= ratio;
            }
            
            joystick.style.transform = `translate(${x}px, ${y}px)`;
            
            // –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –∑–Ω–∞—á–µ–Ω–∏–π –¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è
            joystickPosition.x = x / maxDistance;
            joystickPosition.y = y / maxDistance;
            
            // –£—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ñ–ª–∞–≥–æ–≤ –¥–≤–∏–∂–µ–Ω–∏—è
            moveForward = joystickPosition.y < -0.2;  // –í–ø–µ—Ä–µ–¥ –ø—Ä–∏ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–∏ –¥–∂–æ–π—Å—Ç–∏–∫–∞ –≤–≤–µ—Ä—Ö
            moveBackward = joystickPosition.y > 0.2;  // –ù–∞–∑–∞–¥ –ø—Ä–∏ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–∏ –¥–∂–æ–π—Å—Ç–∏–∫–∞ –≤–Ω–∏–∑
            moveLeft = joystickPosition.x < -0.2;     // –í–ª–µ–≤–æ –ø—Ä–∏ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–∏ –¥–∂–æ–π—Å—Ç–∏–∫–∞ –≤–ª–µ–≤–æ
            moveRight = joystickPosition.x > 0.2;     // –í–ø—Ä–∞–≤–æ –ø—Ä–∏ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–∏ –¥–∂–æ–π—Å—Ç–∏–∫–∞ –≤–ø—Ä–∞–≤–æ
        }
        
        function resetJoystick() {
            joystick.style.transform = 'translate(0, 0)';
            joystickPosition.x = 0;
            joystickPosition.y = 0;
            moveForward = false;
            moveBackward = false;
            moveLeft = false;
            moveRight = false;
        }
        
        function updateLookJoystickPosition(x, y) {
            const maxDistance = 40;
            const distance = Math.sqrt(x * x + y * y);
            
            if (distance > maxDistance) {
                const ratio = maxDistance / distance;
                x *= ratio;
                y *= ratio;
            }
            
            lookJoystick.style.transform = `translate(${x}px, ${y}px)`;
            
            // –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –∑–Ω–∞—á–µ–Ω–∏–π –¥–ª—è –ø–æ–≤–æ—Ä–æ—Ç–∞ –∫–∞–º–µ—Ä—ã
            lookJoystickPosition.x = x / maxDistance;
            lookJoystickPosition.y = y / maxDistance;
            
            // –ü–æ–≤–æ—Ä–æ—Ç –∫–∞–º–µ—Ä—ã
            player.rotation.y -= lookJoystickPosition.x * 0.1;
            camera.rotation.x -= lookJoystickPosition.y * 0.05;
            camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
        }
        
        function resetLookJoystick() {
            lookJoystick.style.transform = 'translate(0, 0)';
            lookJoystickPosition.x = 0;
            lookJoystickPosition.y = 0;
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —É—Ä–æ–≤–Ω—è
        function createLevel() {
            // –û—á–∏—Å—Ç–∫–∞ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ —É—Ä–æ–≤–Ω—è
            while(scene.children.length > 0){ 
                scene.remove(scene.children[0]); 
            }
            
            enemies = [];
            bullets = [];
            enemyBullets = [];
            walls = [];
            enemyHelpers = [];
            particleSystems = [];
            platforms = [];
            collectibles = [];
            secretDoors = [];
            doors = [];
            keys = [];
            bosses = [];
            hasCollectibleKey = false;
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–∞ –∏ –æ—Å–≤–µ—â–µ–Ω–∏—è –æ–±—Ä–∞—Ç–Ω–æ –Ω–∞ —Å—Ü–µ–Ω—É
            scene.add(player);
            
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(100, 100, 100);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ç–æ—á–µ—á–Ω—ã—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤ —Å–≤–µ—Ç–∞
            const pointLight1 = new THREE.PointLight(0xffaa00, 1, 50);
            pointLight1.position.set(10, 15, 10);
            pointLight1.castShadow = true;
            scene.add(pointLight1);
            
            const pointLight2 = new THREE.PointLight(0x0044ff, 1, 50);
            pointLight2.position.set(-10, 15, -10);
            pointLight2.castShadow = true;
            scene.add(pointLight2);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ skybox
            if (textures.skybox) {
                scene.background = textures.skybox;
            }
            
            // –†–∞–∑–º–µ—Ä —É—Ä–æ–≤–Ω—è —Ä–∞—Å—Ç–µ—Ç —Å –∫–∞–∂–¥—ã–º —É—Ä–æ–≤–Ω–µ–º
            const levelSize = LEVEL_SIZE_BASE + (level * 20);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ–ª–∞ —Å —Ç–µ–∫—Å—Ç—É—Ä–æ–π
            const floorGeometry = new THREE.PlaneGeometry(levelSize, levelSize, 10, 10);
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                map: textures.ground,
                roughness: 0.8,
                metalness: 0.2
            });
            floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —Å—Ç–µ–Ω
            createWalls(levelSize);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —É—Ä–æ–≤–Ω–µ–π –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–µ–∫—É—â–µ–≥–æ —É—Ä–æ–≤–Ω—è
            switch(level) {
                case 1:
                    createTutorialLevel(levelSize);
                    break;
                case 2:
                    createMazeLevel(levelSize);
                    break;
                case 3:
                    createFortressLevel(levelSize);
                    break;
                case 4:
                    createDungeonLevel(levelSize);
                    break;
                default:
                    createAdvancedLevel(levelSize);
            }
            
            // –°–±—Ä–æ—Å –ø–æ–∑–∏—Ü–∏–∏ –∏–≥—Ä–æ–∫–∞ –∏ —É—Å—Ç–∞–Ω–æ–≤–∫–∞ –Ω–∞ —Å—Ç–∞—Ä—Ç–æ–≤—É—é —Ç–æ—á–∫—É
            player.position.set(0, 2, 0);
            player.velocity.set(0, 0, 0);
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ HUD
            document.getElementById('level').textContent = level;
            document.getElementById('score').textContent = score;
            updateHealthBar();
            
            // –°–±—Ä–æ—Å –ø–∞—Ç—Ä–æ–Ω–æ–≤
            ammo = weapons[currentWeapon - 1].ammo;
            maxAmmo = weapons[currentWeapon - 1].maxAmmo;
            document.getElementById('ammo-count').textContent = ammo;
            document.getElementById('max-ammo').textContent = maxAmmo;
            
            // –ü–æ–∫–∞–∑–∞—Ç—å —Ç–µ–∫—É—â–µ–µ –∑–∞–¥–∞–Ω–∏–µ
            if (LEVELS[level-1] && LEVELS[level-1].objectives.length > 0) {
                showObjective(LEVELS[level-1].objectives[0]);
            }
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —Å—Ç–µ–Ω –≤–æ–∫—Ä—É–≥ —É—Ä–æ–≤–Ω—è
        function createWalls(size) {
            const wallHeight = 10;
            const wallThickness = 2;
            const halfSize = size / 2;
            
            const wallMaterial = new THREE.MeshStandardMaterial({ 
                map: textures.wall,
                roughness: 0.7,
                metalness: 0.2,
                bumpMap: textures.wall,
                bumpScale: 0.02
            });
            
            // –°–µ–≤–µ—Ä–Ω–∞—è —Å—Ç–µ–Ω–∞
            const northWallGeometry = new THREE.BoxGeometry(size + wallThickness * 2, wallHeight, wallThickness);
            const northWall = new THREE.Mesh(northWallGeometry, wallMaterial);
            northWall.position.set(0, wallHeight / 2, -halfSize - wallThickness / 2);
            northWall.castShadow = true;
            northWall.receiveShadow = true;
            scene.add(northWall);
            walls.push(northWall);
            
            // –Æ–∂–Ω–∞—è —Å—Ç–µ–Ω–∞
            const southWall = northWall.clone();
            southWall.position.z = halfSize + wallThickness / 2;
            scene.add(southWall);
            walls.push(southWall);
            
            // –í–æ—Å—Ç–æ—á–Ω–∞—è —Å—Ç–µ–Ω–∞
            const eastWallGeometry = new THREE.BoxGeometry(wallThickness, wallHeight, size);
            const eastWall = new THREE.Mesh(eastWallGeometry, wallMaterial);
            eastWall.position.set(halfSize + wallThickness / 2, wallHeight / 2, 0);
            eastWall.castShadow = true;
            eastWall.receiveShadow = true;
            scene.add(eastWall);
            walls.push(eastWall);
            
            // –ó–∞–ø–∞–¥–Ω–∞—è —Å—Ç–µ–Ω–∞
            const westWall = eastWall.clone();
            westWall.position.x = -halfSize - wallThickness / 2;
            scene.add(westWall);
            walls.push(westWall);
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ –æ–±—É—á–∞—é—â–µ–≥–æ —É—Ä–æ–≤–Ω—è
        function createTutorialLevel(size) {
            const halfSize = size / 2 - 5;
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –ø–ª–∞—Ç—Ñ–æ—Ä–º –¥–ª—è –æ–±—É—á–µ–Ω–∏—è –ø—Ä—ã–∂–∫–∞–º
            createPlatform(10, 1, 10, 0, 0, -15, 0x4d4dff);
            createPlatform(8, 1, 8, 0, 2, -25, 0x4d7fff);
            createPlatform(6, 1, 6, 0, 4, -35, 0x4db8ff);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π
            createObstacle(5, 3, 2, -10, 1.5, 10, 0x8c8c8c);
            createObstacle(5, 3, 2, 10, 1.5, 10, 0x8c8c8c);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –∫–ª—é—á–∞-–∫–æ–ª–ª–µ–∫—Ç–∏–±–ª–∞
            createCollectible(0, 1, -40, 'key');
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —Å–µ–∫—Ä–µ—Ç–Ω–æ–π –¥–≤–µ—Ä–∏, –∫–æ—Ç–æ—Ä–∞—è –æ—Ç–∫—Ä—ã–≤–∞–µ—Ç—Å—è –∫–ª—é—á–æ–º
            createSecretDoor(15, 5, 2, 20, 2.5, 0, 0x7d4d4d);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω–æ–π —Ç–æ—á–∫–∏
            createCheckpoint(0, 0, -15);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–µ–¥–º–µ—Ç–æ–≤ –¥–ª—è –æ–±—É—á–µ–Ω–∏—è
            createCollectible(-15, 1, 15, 'ammo');
            createCollectible(15, 1, 15, 'health');
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –æ–±—É—á–∞—é—â–∏—Ö –≤—Ä–∞–≥–æ–≤
            for (let i = 0; i < 5; i++) {
                const x = Math.random() * 30 - 15;
                const z = Math.random() * 30 - 40;
                createEnemy(x, 0, z, 'basic');
            }
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ—á–Ω–æ–π –∑–æ–Ω—ã –¥–ª—è —Å—Ç—Ä–µ–ª—å–±—ã
            createShootingRange(30, 20, -20);
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —Å—Ç—Ä–µ–ª—å–±–∏—â–∞ –¥–ª—è –æ–±—É—á–µ–Ω–∏—è
        function createShootingRange(x, z, radius) {
            // –û—Å–Ω–æ–≤–∞–Ω–∏–µ —Å—Ç—Ä–µ–ª—å–±–∏—â–∞
            const baseGeometry = new THREE.CylinderGeometry(radius, radius, 0.5, 16);
            const baseMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333,
                roughness: 0.8,
                metalness: 0.2
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.set(x, 0.25, z);
            base.receiveShadow = true;
            scene.add(base);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –º–∏—à–µ–Ω–µ–π
            for (let i = 0; i < 5; i++) {
                const angle = (i / 5) * Math.PI * 2;
                const targetX = x + Math.cos(angle) * (radius - 5);
                const targetZ = z + Math.sin(angle) * (radius - 5);
                
                createTarget(targetX, 3, targetZ);
            }
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ –º–∏—à–µ–Ω–∏
        function createTarget(x, y, z) {
            const targetGroup = new THREE.Group();
            
            // –û–ø–æ—Ä–∞ –º–∏—à–µ–Ω–∏
            const standGeometry = new THREE.BoxGeometry(0.5, 6, 0.5);
            const standMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.8,
                metalness: 0.1,
                map: textures.wood
            });
            const stand = new THREE.Mesh(standGeometry, standMaterial);
            stand.position.y = 3;
            stand.castShadow = true;
            stand.receiveShadow = true;
            targetGroup.add(stand);
            
            // –ú–∏—à–µ–Ω—å
            const targetGeometry = new THREE.CylinderGeometry(1.5, 1.5, 0.2, 16);
            const targetMaterial = new THREE.MeshStandardMaterial({
                color: 0xff0000,
                roughness: 0.5,
                metalness: 0.3
            });
            const target = new THREE.Mesh(targetGeometry, targetMaterial);
            target.rotation.x = Math.PI / 2;
            target.position.set(0, y, 0);
            target.castShadow = true;
            target.receiveShadow = true;
            targetGroup.add(target);
            
            // –¶–µ–Ω—Ç—Ä –º–∏—à–µ–Ω–∏
            const centerGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.22, 16);
            const centerMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 0.5,
                metalness: 0.3
            });
            const center = new THREE.Mesh(centerGeometry, centerMaterial);
            center.rotation.x = Math.PI / 2;
            center.position.set(0, y, 0.01);
            center.castShadow = true;
            targetGroup.add(center);
            
            targetGroup.position.set(x, 0, z);
            targetGroup.isTarget = true;
            targetGroup.targetHealth = 100;
            scene.add(targetGroup);
            
            return targetGroup;
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —É—Ä–æ–≤–Ω—è —Å –ª–∞–±–∏—Ä–∏–Ω—Ç–æ–º
        function createMazeLevel(size) {
            const halfSize = size / 2 - 10;
            const wallHeight = 4;
            const wallThickness = 2;
            const corridorWidth = 6;
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —Å—Ç–µ–Ω–æ–∫ –ª–∞–±–∏—Ä–∏–Ω—Ç–∞
            const mazeMaterial = new THREE.MeshStandardMaterial({ 
                map: textures.wall,
                roughness: 0.8,
                metalness: 0.2
            });
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —Å–ª–æ–∂–Ω–æ–≥–æ –ª–∞–±–∏—Ä–∏–Ω—Ç–∞
            const mazeSize = 5;  // 5x5 —è—á–µ–µ–∫
            const cellSize = 15;  // —Ä–∞–∑–º–µ—Ä —è—á–µ–π–∫–∏
            
            // –î–≤—É–º–µ—Ä–Ω—ã–π –º–∞—Å—Å–∏–≤ –¥–ª—è –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏—è –ª–∞–±–∏—Ä–∏–Ω—Ç–∞
            // 0 - –ø—Ä–æ—Ö–æ–¥, 1 - —Å—Ç–µ–Ω–∞
            const maze = createMazeLayout(mazeSize);
            
            // –°—Ç—Ä–æ–∏–º —Å—Ç–µ–Ω—ã –ª–∞–±–∏—Ä–∏–Ω—Ç–∞
            for (let i = 0; i < mazeSize; i++) {
                for (let j = 0; j < mazeSize; j++) {
                    if (maze[i][j] === 1) {
                        // –í—ã—á–∏—Å–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é —è—á–µ–π–∫–∏ –≤ 3D –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ
                        const x = (i - Math.floor(mazeSize/2)) * cellSize;
                        const z = (j - Math.floor(mazeSize/2)) * cellSize;
                        
                        const wallGeometry = new THREE.BoxGeometry(cellSize, wallHeight, cellSize);
                        const wall = new THREE.Mesh(wallGeometry, mazeMaterial);
                        wall.position.set(x, wallHeight/2, z);
                        wall.castShadow = true;
                        wall.receiveShadow = true;
                        scene.add(wall);
                        walls.push(wall);
                    }
                }
            }
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –∫–ª—é—á–µ–π –≤ –ª–∞–±–∏—Ä–∏–Ω—Ç–µ
            for (let i = 0; i < 3; i++) {
                let keyPlaced = false;
                
                while (!keyPlaced) {
                    const cellX = Math.floor(Math.random() * mazeSize);
                    const cellZ = Math.floor(Math.random() * mazeSize);
                    
                    if (maze[cellX][cellZ] === 0) {
                        const x = (cellX - Math.floor(mazeSize/2)) * cellSize;
                        const z = (cellZ - Math.floor(mazeSize/2)) * cellSize;
                        
                        createCollectible(x, 1, z, 'key');
                        keyPlaced = true;
                    }
                }
            }
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –≤—ã—Ö–æ–¥–∞ –∏–∑ –ª–∞–±–∏—Ä–∏–Ω—Ç–∞
            createSecretDoor(10, 5, 2, halfSize - 5, 2.5, halfSize - 5, 0x7d4d4d);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –≤—Ä–∞–≥–æ–≤ –≤ –ª–∞–±–∏—Ä–∏–Ω—Ç–µ
            for (let i = 0; i < 8; i++) {
                let enemyPlaced = false;
                
                while (!enemyPlaced) {
                    const cellX = Math.floor(Math.random() * mazeSize);
                    const cellZ = Math.floor(Math.random() * mazeSize);
                    
                    if (maze[cellX][cellZ] === 0) {
                        const x = (cellX - Math.floor(mazeSize/2)) * cellSize;
                        const z = (cellZ - Math.floor(mazeSize/2)) * cellSize;
                        
                        // –ù–µ —Å–æ–∑–¥–∞–≤–∞—Ç—å –≤—Ä–∞–≥–æ–≤ —Ä—è–¥–æ–º —Å –∏–≥—Ä–æ–∫–æ–º
                        if (Math.abs(x) > 20 || Math.abs(z) > 20) {
                            createEnemy(x, 0, z, 'maze');
                            enemyPlaced = true;
                        }
                    }
                }
            }
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—ã—Ö —Ç–æ—á–µ–∫
            createCheckpoint(0, 0, 0);
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —à–∞–±–ª–æ–Ω–∞ –ª–∞–±–∏—Ä–∏–Ω—Ç–∞
        function createMazeLayout(size) {
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –≤—Å–µ —è—á–µ–π–∫–∏ –∫–∞–∫ —Å—Ç–µ–Ω—ã
            const maze = Array(size).fill().map(() => Array(size).fill(1));
            
            // –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ–µ –¥–µ–ª–µ–Ω–∏–µ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –ª–∞–±–∏—Ä–∏–Ω—Ç–∞
            function divide(x, y, width, height, orientation) {
                if (width < 2 || height < 2) return;
                
                // –í—ã–±–∏—Ä–∞–µ–º —Å–ª—É—á–∞–π–Ω—É—é —Ç–æ—á–∫—É –¥–ª—è —Å—Ç–µ–Ω—ã
                let wx = x + (orientation ? 0 : Math.floor(Math.random() * (width - 1)));
                let wy = y + (orientation ? Math.floor(Math.random() * (height - 1)) : 0);
                
                // –í—ã–±–∏—Ä–∞–µ–º —Å–ª—É—á–∞–π–Ω—É—é —Ç–æ—á–∫—É –¥–ª—è –ø—Ä–æ—Ö–æ–¥–∞
                let px = wx + (orientation ? Math.floor(Math.random() * width) : 0);
                let py = wy + (orientation ? 0 : Math.floor(Math.random() * height));
                
                // –†–∞–∑–º–µ—Ä —Å—Ç–µ–Ω—ã
                let wallWidth = orientation ? width : 1;
                let wallHeight = orientation ? 1 : height;
                
                // –°–æ–∑–¥–∞–µ–º –ø—Ä–æ—Ö–æ–¥—ã
                for (let i = 0; i < wallWidth; i++) {
                    for (let j = 0; j < wallHeight; j++) {
                        if ((wx + i !== px || wy + j !== py) && wx + i < size && wy + j < size) {
                            maze[wx + i][wy + j] = 0;
                        }
                    }
                }
                
                // –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –¥–µ–ª–∏–º –¥–∞–ª—å—à–µ
                const nx = orientation ? x : wx + 1;
                const ny = orientation ? wy + 1 : y;
                const nWidth = orientation ? width : x + width - nx;
                const nHeight = orientation ? y + height - ny : height;
                
                divide(x, y, orientation ? width : wx - x + 1, orientation ? wy - y + 1 : height, !orientation);
                divide(nx, ny, nWidth, nHeight, !orientation);
            }
            
            // –ù–∞—á–∏–Ω–∞–µ–º —Å –ø—Ä–æ—Ö–æ–¥–æ–≤
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    maze[i][j] = 0;
                }
            }
            
            // –°–æ–∑–¥–∞–µ–º –≤–Ω–µ—à–Ω–∏–µ —Å—Ç–µ–Ω—ã
            for (let i = 0; i < size; i++) {
                maze[0][i] = 1;
                maze[size-1][i] = 1;
                maze[i][0] = 1;
                maze[i][size-1] = 1;
            }
            
            // –°—Ç–∞—Ä—Ç—É–µ–º —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ–µ –¥–µ–ª–µ–Ω–∏–µ
            divide(1, 1, size-2, size-2, Math.random() < 0.5);
            
            // –°–æ–∑–¥–∞–µ–º –≤—Ö–æ–¥ –∏ –≤—ã—Ö–æ–¥
            maze[1][1] = 0; // –í—Ö–æ–¥
            maze[size-2][size-2] = 0; // –í—ã—Ö–æ–¥
            
            return maze;
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —É—Ä–æ–≤–Ω—è —Å –∫—Ä–µ–ø–æ—Å—Ç—å—é
        function createFortressLevel(size) {
            const halfSize = size / 2 - 10;
            const wallHeight = 8;
            const wallThickness = 3;
            
            // –ò–∑–º–µ–Ω–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç—É—Ä—ã –ø–æ–ª–∞
            floor.material.map = textures.grass;
            floor.material.needsUpdate = true;
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –∫—Ä–µ–ø–æ—Å—Ç–∏
            createFortress(0, 0, 50, wallHeight, wallThickness);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –≤–Ω–µ—à–Ω–∏—Ö —É–∫—Ä–µ–ø–ª–µ–Ω–∏–π
            createFortressWalls(0, 0, 80, wallHeight-2, wallThickness);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –æ—Ä—É–∂–∏—è –¥–ª—è —Å–±–æ—Ä–∞
            createWeaponPickup(20, 1, -20);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –æ—Ö—Ä–∞–Ω–Ω–∏–∫–æ–≤ –∫—Ä–µ–ø–æ—Å—Ç–∏
            for (let i = 0; i < 10; i++) {
                let x, z;
                
                if (i < 5) {
                    // –í–Ω—É—Ç—Ä–∏ –∫—Ä–µ–ø–æ—Å—Ç–∏
                    x = Math.random() * 30 - 15;
                    z = Math.random() * 30 - 15;
                } else {
                    // –í–æ–∫—Ä—É–≥ –∫—Ä–µ–ø–æ—Å—Ç–∏
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 60 + Math.random() * 15;
                    x = Math.cos(angle) * radius;
                    z = Math.sin(angle) * radius;
                }
                
                createEnemy(x, 0, z, 'guard');
            }
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –±–æ—Å—Å–∞ –∫—Ä–µ–ø–æ—Å—Ç–∏
            createBoss(0, 0, 0);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –±–æ–Ω—É—Å–æ–≤ –∑–¥–æ—Ä–æ–≤—å—è –∏ –ø–∞—Ç—Ä–æ–Ω–æ–≤
            createCollectible(-25, 1, 25, 'health');
            createCollectible(25, 1, 25, 'ammo');
            createCollectible(-25, 1, -25, 'health');
            createCollectible(25, 1, -25, 'ammo');
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—ã—Ö —Ç–æ—á–µ–∫
            createCheckpoint(0, 0, 70);
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ –∫—Ä–µ–ø–æ—Å—Ç–∏
        function createFortress(centerX, centerZ, size, height, thickness) {
            const halfSize = size / 2;
            
            // –ú–∞—Ç–µ—Ä–∏–∞–ª –∫—Ä–µ–ø–æ—Å—Ç–∏
            const fortressMaterial = new THREE.MeshStandardMaterial({ 
                map: textures.wall,
                roughness: 0.8,
                metalness: 0.2
            });
            
            // –°—Ç–µ–Ω—ã –∫—Ä–µ–ø–æ—Å—Ç–∏
            const walls = [
                // –°–µ–≤–µ—Ä–Ω–∞—è —Å—Ç–µ–Ω–∞ —Å –≤–æ—Ä–æ—Ç–∞–º–∏
                { x: centerX, z: centerZ - halfSize, width: size, depth: thickness, hasGate: true },
                // –Æ–∂–Ω–∞—è —Å—Ç–µ–Ω–∞
                { x: centerX, z: centerZ + halfSize, width: size, depth: thickness, hasGate: false },
                // –í–æ—Å—Ç–æ—á–Ω–∞—è —Å—Ç–µ–Ω–∞
                { x: centerX + halfSize, z: centerZ, width: thickness, depth: size, hasGate: false },
                // –ó–∞–ø–∞–¥–Ω–∞—è —Å—Ç–µ–Ω–∞
                { x: centerX - halfSize, z: centerZ, width: thickness, depth: size, hasGate: false }
            ];
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —Å—Ç–µ–Ω
            for (const wallData of walls) {
                if (wallData.hasGate) {
                    // –°—Ç–µ–Ω–∞ —Å –≤–æ—Ä–æ—Ç–∞–º–∏
                    const gateWidth = 10;
                    const sideWidth = (wallData.width - gateWidth) / 2;
                    
                    // –õ–µ–≤–∞—è —á–∞—Å—Ç—å —Å—Ç–µ–Ω—ã
                    const leftWallGeometry = new THREE.BoxGeometry(sideWidth, height, wallData.depth);
                    const leftWall = new THREE.Mesh(leftWallGeometry, fortressMaterial);
                    leftWall.position.set(
                        wallData.x - gateWidth/2 - sideWidth/2, 
                        height/2, 
                        wallData.z
                    );
                    leftWall.castShadow = true;
                    leftWall.receiveShadow = true;
                    scene.add(leftWall);
                    this.walls.push(leftWall);
                    
                    // –ü—Ä–∞–≤–∞—è —á–∞—Å—Ç—å —Å—Ç–µ–Ω—ã
                    const rightWallGeometry = new THREE.BoxGeometry(sideWidth, height, wallData.depth);
                    const rightWall = new THREE.Mesh(rightWallGeometry, fortressMaterial);
                    rightWall.position.set(
                        wallData.x + gateWidth/2 + sideWidth/2, 
                        height/2, 
                        wallData.z
                    );
                    rightWall.castShadow = true;
                    rightWall.receiveShadow = true;
                    scene.add(rightWall);
                    this.walls.push(rightWall);
                    
                    // –í–µ—Ä—Ö–Ω—è—è —á–∞—Å—Ç—å –≤–æ—Ä–æ—Ç
                    const gateTopGeometry = new THREE.BoxGeometry(gateWidth, height/3, wallData.depth);
                    const gateTop = new THREE.Mesh(gateTopGeometry, fortressMaterial);
                    gateTop.position.set(
                        wallData.x, 
                        height - height/6, 
                        wallData.z
                    );
                    gateTop.castShadow = true;
                    gateTop.receiveShadow = true;
                    scene.add(gateTop);
                    this.walls.push(gateTop);
                } else {
                    // –û–±—ã—á–Ω–∞—è —Å—Ç–µ–Ω–∞
                    const wallGeometry = new THREE.BoxGeometry(wallData.width, height, wallData.depth);
                    const wall = new THREE.Mesh(wallGeometry, fortressMaterial);
                    wall.position.set(
                        wallData.x, 
                        height/2, 
                        wallData.z
                    );
                    wall.castShadow = true;
                    wall.receiveShadow = true;
                    scene.add(wall);
                    this.walls.push(wall);
                }
            }
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –±–∞—à–µ–Ω –≤ —É–≥–ª–∞—Ö
            const towerRadius = thickness * 1.5;
            const towerHeight = height * 1.3;
            const towers = [
                { x: centerX - halfSize, z: centerZ - halfSize }, // –°–µ–≤–µ—Ä–æ-–∑–∞–ø–∞–¥–Ω–∞—è
                { x: centerX + halfSize, z: centerZ - halfSize }, // –°–µ–≤–µ—Ä–æ-–≤–æ—Å—Ç–æ—á–Ω–∞—è
                { x: centerX - halfSize, z: centerZ + halfSize }, // –Æ–≥–æ-–∑–∞–ø–∞–¥–Ω–∞—è
                { x: centerX + halfSize, z: centerZ + halfSize }  // –Æ–≥–æ-–≤–æ—Å—Ç–æ—á–Ω–∞—è
            ];
            
            for (const towerData of towers) {
                const towerGeometry = new THREE.CylinderGeometry(towerRadius, towerRadius, towerHeight, 16);
                const tower = new THREE.Mesh(towerGeometry, fortressMaterial);
                tower.position.set(
                    towerData.x, 
                    towerHeight/2, 
                    towerData.z
                );
                tower.castShadow = true;
                tower.receiveShadow = true;
                scene.add(tower);
                this.walls.push(tower);
                
                // –ö—Ä—ã—à–∞ –±–∞—à–Ω–∏
                const roofGeometry = new THREE.ConeGeometry(towerRadius*1.2, towerHeight/2, 16);
                const roofMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x882222,
                    roughness: 0.7,
                    metalness: 0.3
                });
                const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                roof.position.set(
                    towerData.x, 
                    towerHeight + towerHeight/4, 
                    towerData.z
                );
                roof.castShadow = true;
                scene.add(roof);
            }
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏—Ö –∑–¥–∞–Ω–∏–π
            const buildingCount = 3;
            const buildingSize = 10;
            
            for (let i = 0; i < buildingCount; i++) {
                const offsetX = (i - 1) * 15;
                
                const buildingGeometry = new THREE.BoxGeometry(buildingSize, height*0.7, buildingSize);
                const buildingMaterial = new THREE.MeshStandardMaterial({ 
                    map: textures.wood,
                    roughness: 0.7,
                    metalness: 0.2
                });
                const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                building.position.set(
                    centerX + offsetX, 
                    height*0.7/2, 
                    centerZ + 10
                );
                building.castShadow = true;
                building.receiveShadow = true;
                scene.add(building);
                this.walls.push(building);
                
                // –ö—Ä—ã—à–∞ –∑–¥–∞–Ω–∏—è
                const buildingRoofGeometry = new THREE.ConeGeometry(buildingSize*0.8, height*0.4, 4);
                const buildingRoofMaterial = new THREE.MeshStandardMaterial({ 
                                        color: 0x883333,
                    roughness: 0.7,
                    metalness: 0.2
                });
                const buildingRoof = new THREE.Mesh(buildingRoofGeometry, buildingRoofMaterial);
                buildingRoof.position.set(
                    centerX + offsetX, 
                    height*0.7 + height*0.2, 
                    centerZ + 10
                );
                buildingRoof.rotation.y = Math.PI / 4; // –ü–æ–≤–æ—Ä–æ—Ç –Ω–∞ 45 –≥—Ä–∞–¥—É—Å–æ–≤
                buildingRoof.castShadow = true;
                scene.add(buildingRoof);
            }
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ –≤–Ω–µ—à–Ω–∏—Ö —Å—Ç–µ–Ω –∫—Ä–µ–ø–æ—Å—Ç–∏
        function createFortressWalls(centerX, centerZ, size, height, thickness) {
            const halfSize = size / 2;
            
            // –ú–∞—Ç–µ—Ä–∏–∞–ª —Å—Ç–µ–Ω
            const wallMaterial = new THREE.MeshStandardMaterial({ 
                map: textures.wall,
                roughness: 0.8,
                metalness: 0.2
            });
            
            // –°—Ç–µ–Ω—ã
            const wallsData = [
                // –°–µ–≤–µ—Ä–Ω–∞—è —Å—Ç–µ–Ω–∞ —Å –≤–æ—Ä–æ—Ç–∞–º–∏
                { x: centerX, z: centerZ - halfSize, width: size, depth: thickness, hasGate: true },
                // –Æ–∂–Ω–∞—è —Å—Ç–µ–Ω–∞
                { x: centerX, z: centerZ + halfSize, width: size, depth: thickness, hasGate: false },
                // –í–æ—Å—Ç–æ—á–Ω–∞—è —Å—Ç–µ–Ω–∞
                { x: centerX + halfSize, z: centerZ, width: thickness, depth: size, hasGate: false },
                // –ó–∞–ø–∞–¥–Ω–∞—è —Å—Ç–µ–Ω–∞
                { x: centerX - halfSize, z: centerZ, width: thickness, depth: size, hasGate: false }
            ];
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —Å—Ç–µ–Ω
            for (const wallData of wallsData) {
                if (wallData.hasGate) {
                    // –°—Ç–µ–Ω–∞ —Å –≤–æ—Ä–æ—Ç–∞–º–∏
                    const gateWidth = 15;
                    const sideWidth = (wallData.width - gateWidth) / 2;
                    
                    // –õ–µ–≤–∞—è —á–∞—Å—Ç—å —Å—Ç–µ–Ω—ã
                    const leftWallGeometry = new THREE.BoxGeometry(sideWidth, height, wallData.depth);
                    const leftWall = new THREE.Mesh(leftWallGeometry, wallMaterial);
                    leftWall.position.set(
                        wallData.x - gateWidth/2 - sideWidth/2, 
                        height/2, 
                        wallData.z
                    );
                    leftWall.castShadow = true;
                    leftWall.receiveShadow = true;
                    scene.add(leftWall);
                    walls.push(leftWall);
                    
                    // –ü—Ä–∞–≤–∞—è —á–∞—Å—Ç—å —Å—Ç–µ–Ω—ã
                    const rightWallGeometry = new THREE.BoxGeometry(sideWidth, height, wallData.depth);
                    const rightWall = new THREE.Mesh(rightWallGeometry, wallMaterial);
                    rightWall.position.set(
                        wallData.x + gateWidth/2 + sideWidth/2, 
                        height/2, 
                        wallData.z
                    );
                    rightWall.castShadow = true;
                    rightWall.receiveShadow = true;
                    scene.add(rightWall);
                    walls.push(rightWall);
                    
                    // –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ–¥—ä–µ–º–Ω—ã—Ö –≤–æ—Ä–æ—Ç
                    createGate(wallData.x, height/2, wallData.z, gateWidth, height, wallData.depth);
                } else {
                    // –û–±—ã—á–Ω–∞—è —Å—Ç–µ–Ω–∞
                    const wallGeometry = new THREE.BoxGeometry(wallData.width, height, wallData.depth);
                    const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                    wall.position.set(
                        wallData.x, 
                        height/2, 
                        wallData.z
                    );
                    wall.castShadow = true;
                    wall.receiveShadow = true;
                    scene.add(wall);
                    walls.push(wall);
                }
            }
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ –≤–æ—Ä–æ—Ç
        function createGate(x, y, z, width, height, depth) {
            const gateMaterial = new THREE.MeshStandardMaterial({ 
                map: textures.wood,
                roughness: 0.7,
                metalness: 0.5
            });
            
            const gateGeometry = new THREE.BoxGeometry(width, height, depth*0.8);
            const gate = new THREE.Mesh(gateGeometry, gateMaterial);
            gate.position.set(x, y, z);
            gate.castShadow = true;
            gate.receiveShadow = true;
            
            // –ú–µ—Ç–∞–ª–ª–∏—á–µ—Å–∫–∏–µ –¥–µ—Ç–∞–ª–∏ –≤–æ—Ä–æ—Ç
            const detailMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x444444,
                roughness: 0.5,
                metalness: 0.8
            });
            
            // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ –ø–æ–ª–æ—Å—ã
            for (let i = 0; i < 3; i++) {
                const stripGeometry = new THREE.BoxGeometry(width+0.1, height/10, depth*0.9);
                const strip = new THREE.Mesh(stripGeometry, detailMaterial);
                strip.position.set(x, y - height/4 + i * height/4, z);
                gate.add(strip);
            }
            
            // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ –ø–æ–ª–æ—Å—ã
            for (let i = 0; i < 3; i++) {
                const stripGeometry = new THREE.BoxGeometry(width/10, height+0.1, depth*0.9);
                const strip = new THREE.Mesh(stripGeometry, detailMaterial);
                strip.position.set(x - width/4 + i * width/4, y, z);
                gate.add(strip);
            }
            
            scene.add(gate);
            secretDoors.push(gate);
            gate.isSecretDoor = true;
            gate.isOpen = false;
            walls.push(gate);
            
            return gate;
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ–¥–±–∏—Ä–∞–µ–º–æ–≥–æ –æ—Ä—É–∂–∏—è
        function createWeaponPickup(x, y, z) {
            const weaponGroup = new THREE.Group();
            
            // –û—Å–Ω–æ–≤–∞ –æ—Ä—É–∂–∏—è
            const baseGeometry = new THREE.BoxGeometry(1, 0.3, 3);
            const baseMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                roughness: 0.5,
                metalness: 0.7
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            weaponGroup.add(base);
            
            // –°—Ç–≤–æ–ª
            const barrelGeometry = new THREE.CylinderGeometry(0.1, 0.1, 3.5, 8);
            const barrelMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x222222,
                roughness: 0.3,
                metalness: 0.9
            });
            const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
            barrel.rotation.x = Math.PI / 2;
            barrel.position.set(0, 0, 1.5);
            weaponGroup.add(barrel);
            
            // –†—É–∫–æ—è—Ç–∫–∞
            const handleGeometry = new THREE.BoxGeometry(0.4, 1, 0.4);
            const handleMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.8,
                metalness: 0.2,
                map: textures.wood
            });
            const handle = new THREE.Mesh(handleGeometry, handleMaterial);
            handle.position.set(0, -0.6, -0.5);
            weaponGroup.add(handle);
            
            // –°–≤–µ—á–µ–Ω–∏–µ –≤–æ–∫—Ä—É–≥ –æ—Ä—É–∂–∏—è
            const glowGeometry = new THREE.SphereGeometry(1.5, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffaa00,
                transparent: true,
                opacity: 0.3
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            weaponGroup.add(glow);
            
            weaponGroup.position.set(x, y, z);
            weaponGroup.rotation.y = Math.PI / 4;
            
            // –ê–Ω–∏–º–∞—Ü–∏—è –æ—Ä—É–∂–∏—è (–ø–∞—Ä–µ–Ω–∏–µ –∏ –≤—Ä–∞—â–µ–Ω–∏–µ)
            weaponGroup.floatAnimation = {
                speed: 0.01,
                height: 0.5,
                direction: 1,
                progress: 0,
                originalY: y,
                rotation: 0.01
            };
            
            // –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –∫–æ–ª–ª–µ–∫—Ç–∏–±–ª–∞
            weaponGroup.isCollectible = true;
            weaponGroup.collectibleType = 'weapon';
            weaponGroup.weaponId = 2; // –ê–≤—Ç–æ–º–∞—Ç
            
            scene.add(weaponGroup);
            collectibles.push(weaponGroup);
            
            return weaponGroup;
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ –±–æ—Å—Å–∞ –∫—Ä–µ–ø–æ—Å—Ç–∏
        function createBoss(x, y, z) {
            const bossGroup = new THREE.Group();
            
            // –¢–µ–ª–æ –±–æ—Å—Å–∞ (–±–æ–ª—å—à–µ –æ–±—ã—á–Ω—ã—Ö –≤—Ä–∞–≥–æ–≤)
            const bodyGeometry = new THREE.BoxGeometry(3, 4, 2);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x880000,
                roughness: 0.7,
                metalness: 0.5
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 2;
            body.castShadow = true;
            body.receiveShadow = true;
            bossGroup.add(body);
            
            // –ì–æ–ª–æ–≤–∞ –±–æ—Å—Å–∞
            const headGeometry = new THREE.SphereGeometry(1.2, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xaa0000,
                roughness: 0.7,
                metalness: 0.5
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 4.6;
            head.castShadow = true;
            head.receiveShadow = true;
            bossGroup.add(head);
            
            // –®–∏–ø—ã –Ω–∞ –≥–æ–ª–æ–≤–µ
            for (let i = 0; i < 5; i++) {
                const angle = (i / 5) * Math.PI * 2;
                const spikeGeometry = new THREE.ConeGeometry(0.2, 0.8, 8);
                const spike = new THREE.Mesh(spikeGeometry, headMaterial);
                spike.position.set(
                    Math.sin(angle) * 0.8,
                    5.2,
                    Math.cos(angle) * 0.8
                );
                spike.rotation.x = Math.PI/2 - angle;
                bossGroup.add(spike);
            }
            
            // –†—É–∫–∏ –±–æ—Å—Å–∞ (–±–æ–ª–µ–µ –º–∞—Å—Å–∏–≤–Ω—ã–µ)
            const armGeometry = new THREE.CylinderGeometry(0.4, 0.3, 3, 8);
            const armMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x990000,
                roughness: 0.7,
                metalness: 0.5
            });
            
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-2, 2.5, 0);
            leftArm.rotation.z = Math.PI / 3;
            leftArm.castShadow = true;
            leftArm.receiveShadow = true;
            bossGroup.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(2, 2.5, 0);
            rightArm.rotation.z = -Math.PI / 3;
            rightArm.castShadow = true;
            rightArm.receiveShadow = true;
            bossGroup.add(rightArm);
            
            // –û—Ä—É–∂–∏–µ –≤ —Ä—É–∫–∞—Ö –±–æ—Å—Å–∞
            const weaponGeometry = new THREE.BoxGeometry(0.5, 0.5, 3);
            const weaponMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x444444,
                roughness: 0.5,
                metalness: 0.8
            });
            
            const leftWeapon = new THREE.Mesh(weaponGeometry, weaponMaterial);
            leftWeapon.position.set(-3, 1.5, 0);
            leftWeapon.rotation.z = Math.PI / 6;
            leftWeapon.castShadow = true;
            bossGroup.add(leftWeapon);
            
            const rightWeapon = new THREE.Mesh(weaponGeometry, weaponMaterial);
            rightWeapon.position.set(3, 1.5, 0);
            rightWeapon.rotation.z = -Math.PI / 6;
            rightWeapon.castShadow = true;
            bossGroup.add(rightWeapon);
            
            // –ù–æ–≥–∏ –±–æ—Å—Å–∞
            const legGeometry = new THREE.CylinderGeometry(0.5, 0.4, 2, 8);
            const legMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x990000,
                roughness: 0.7,
                metalness: 0.5
            });
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-1, 0, 0);
            leftLeg.castShadow = true;
            leftLeg.receiveShadow = true;
            bossGroup.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(1, 0, 0);
            rightLeg.castShadow = true;
            rightLeg.receiveShadow = true;
            bossGroup.add(rightLeg);
            
            // –≠—Ñ—Ñ–µ–∫—Ç —Å–≤–µ—á–µ–Ω–∏—è –¥–ª—è –±–æ—Å—Å–∞
            const glowGeometry = new THREE.SphereGeometry(3, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff0000,
                transparent: true,
                opacity: 0.2,
                side: THREE.BackSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.y = 2;
            bossGroup.add(glow);
            
            // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –±–æ—Å—Å–∞
            bossGroup.position.set(x, y, z);
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–≤–æ–π—Å—Ç–≤ –±–æ—Å—Å–∞
            bossGroup.health = 500;  // –ë–æ–ª—å—à–µ –∑–¥–æ—Ä–æ–≤—å—è
            bossGroup.speed = 0.08;  // –ú–µ–¥–ª–µ–Ω–Ω–µ–µ –æ–±—ã—á–Ω—ã—Ö –≤—Ä–∞–≥–æ–≤, –Ω–æ —Å –æ—Å–æ–±—ã–º–∏ –∞—Ç–∞–∫–∞–º–∏
            bossGroup.lastShot = 0;
            bossGroup.shootInterval = 1000;
            bossGroup.isBoss = true;
            bossGroup.attackMode = 'normal';  // –†–µ–∂–∏–º—ã –∞—Ç–∞–∫–∏: normal, rage, defensive
            bossGroup.attackTimer = 0;
            bossGroup.attackCooldown = 5000;
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∫–æ–ª–ª–∞–π–¥–µ—Ä–∞ –¥–ª—è –±–æ—Å—Å–∞
            bossGroup.collider = new THREE.Box3().setFromObject(bossGroup);
            
            // –ê–Ω–∏–º–∞—Ü–∏–∏ –±–æ—Å—Å–∞
            bossGroup.animations = {
                bobbing: { amplitude: 0.2, frequency: 0.5, offset: Math.random() * Math.PI * 2 },
                arms: { amplitude: 0.3, frequency: 1, offset: Math.random() * Math.PI * 2 }
            };
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –±–æ—Å—Å–∞ –Ω–∞ —Å—Ü–µ–Ω—É
            scene.add(bossGroup);
            bosses.push(bossGroup);
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–µ–≤–∏–¥–∏–º–æ–≥–æ —Ö–µ–ª–ø–µ—Ä–∞ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –ø–æ–ø–∞–¥–∞–Ω–∏–π
            const helperGeometry = new THREE.BoxGeometry(3, 4, 2);
            const helperMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff0000,
                transparent: true,
                opacity: 0.0 // –ù–µ–≤–∏–¥–∏–º—ã–π
            });
            const helper = new THREE.Mesh(helperGeometry, helperMaterial);
            helper.position.copy(bossGroup.position);
            helper.position.y = 2;
            helper.scale.set(1.2, 1.2, 1.2);  // –ë–æ–ª—å—à–∏–π —Ö–∏—Ç–±–æ–∫—Å –¥–ª—è –±–æ—Å—Å–∞
            helper.enemyRef = bossGroup; // –°—Å—ã–ª–∫–∞ –Ω–∞ –±–æ—Å—Å–∞
            scene.add(helper);
            enemyHelpers.push(helper);
            
            return bossGroup;
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —É—Ä–æ–≤–Ω—è —Å –ø–æ–¥–∑–µ–º–µ–ª—å–µ–º
        function createDungeonLevel(size) {
            const halfSize = size / 2 - 10;
            
            // –ò–∑–º–µ–Ω–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç—É—Ä—ã –ø–æ–ª–∞ –Ω–∞ –∫–∞–º–µ–Ω–Ω—ã–π –¥–ª—è –ø–æ–¥–∑–µ–º–µ–ª—å—è
            floor.material.map = textures.lava;
            floor.material.needsUpdate = true;
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –æ—Å–Ω–æ–≤–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –ø–æ–¥–∑–µ–º–µ–ª—å—è
            createDungeonRooms(0, 0, halfSize);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –ø–ª–∞—Ç—Ñ–æ—Ä–º –Ω–∞–¥ –ª–∞–≤–æ–π
            createLavaPlatforms(0, -25, 10);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –∞—Ä—Ç–µ—Ñ–∞–∫—Ç–æ–≤ –¥–ª—è —Å–±–æ—Ä–∞
            for (let i = 0; i < 5; i++) {
                const angle = (i / 5) * Math.PI * 2;
                const radius = 30;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                
                createCollectible(x, 1, z, 'artifact');
            }
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ –±–æ—Å—Å–∞
            createFinalBoss(0, 0, 0);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –≤—Ä–∞–≥–æ–≤ –ø–æ–¥–∑–µ–º–µ–ª—å—è
            for (let i = 0; i < 15; i++) {
                let x, z;
                
                // –†–∞—Å–ø—Ä–µ–¥–µ–ª—è–µ–º –≤—Ä–∞–≥–æ–≤ –ø–æ –ø–æ–¥–∑–µ–º–µ–ª—å—é
                const angle = Math.random() * Math.PI * 2;
                const radius = 10 + Math.random() * 40;
                x = Math.cos(angle) * radius;
                z = Math.sin(angle) * radius;
                
                createEnemy(x, 0, z, 'dungeon');
            }
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—ã—Ö —Ç–æ—á–µ–∫
            createCheckpoint(0, 0, 40);
            createCheckpoint(0, 2, -35); // –ö–æ–Ω—Ç—Ä–æ–ª—å–Ω–∞—è —Ç–æ—á–∫–∞ –ø–æ—Å–ª–µ –ø–ª–∞—Ç—Ñ–æ—Ä–º –Ω–∞–¥ –ª–∞–≤–æ–π
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ –∫–æ–º–Ω–∞—Ç –ø–æ–¥–∑–µ–º–µ–ª—å—è
        function createDungeonRooms(centerX, centerZ, size) {
            const roomCount = 5;
            const roomSize = 15;
            const wallHeight = 8;
            
            // –ú–∞—Ç–µ—Ä–∏–∞–ª —Å—Ç–µ–Ω –ø–æ–¥–∑–µ–º–µ–ª—å—è
            const dungeonMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                roughness: 0.9,
                metalness: 0.1,
                map: textures.wall
            });
            
            // –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –∫–æ–º–Ω–∞—Ç–∞
            createDungeonRoom(centerX, centerZ, roomSize*1.5, wallHeight, dungeonMaterial);
            
            // –û–∫—Ä—É–∂–∞—é—â–∏–µ –∫–æ–º–Ω–∞—Ç—ã
            for (let i = 0; i < roomCount; i++) {
                const angle = (i / roomCount) * Math.PI * 2;
                const distance = size * 0.6;
                
                const x = centerX + Math.cos(angle) * distance;
                const z = centerZ + Math.sin(angle) * distance;
                
                // –†–∞–∑–Ω—ã–µ —Ä–∞–∑–º–µ—Ä—ã –∫–æ–º–Ω–∞—Ç –¥–ª—è —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏—è
                const roomVariation = 0.7 + Math.random() * 0.6;
                createDungeonRoom(x, z, roomSize * roomVariation, wallHeight, dungeonMaterial);
                
                // –°–æ–∑–¥–∞–Ω–∏–µ –∫–æ—Ä–∏–¥–æ—Ä–∞, —Å–æ–µ–¥–∏–Ω—è—é—â–µ–≥–æ —Å —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω–æ–π –∫–æ–º–Ω–∞—Ç–æ–π
                createDungeonCorridor(
                    centerX, centerZ,
                    x, z,
                    3, wallHeight,
                    dungeonMaterial
                );
            }
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ –æ—Ç–¥–µ–ª—å–Ω–æ–π –∫–æ–º–Ω–∞—Ç—ã –ø–æ–¥–∑–µ–º–µ–ª—å—è
        function createDungeonRoom(x, z, size, height, material) {
            const halfSize = size / 2;
            
            // –°—Ç–µ–Ω—ã –∫–æ–º–Ω–∞—Ç—ã
            const walls = [
                // –°–µ–≤–µ—Ä–Ω–∞—è —Å—Ç–µ–Ω–∞
                { x: x, z: z - halfSize, width: size, depth: 1 },
                // –Æ–∂–Ω–∞—è —Å—Ç–µ–Ω–∞
                { x: x, z: z + halfSize, width: size, depth: 1 },
                // –í–æ—Å—Ç–æ—á–Ω–∞—è —Å—Ç–µ–Ω–∞
                { x: x + halfSize, z: z, width: 1, depth: size },
                // –ó–∞–ø–∞–¥–Ω–∞—è —Å—Ç–µ–Ω–∞
                { x: x - halfSize, z: z, width: 1, depth: size }
            ];
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —Å—Ç–µ–Ω –∫–æ–º–Ω–∞—Ç—ã
            for (const wallData of walls) {
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω—É–∂–µ–Ω –ª–∏ –ø—Ä–æ–µ–º –¥–ª—è –¥–≤–µ—Ä–∏
                const needsDoor = Math.random() > 0.7;
                
                if (needsDoor) {
                    // –°—Ç–µ–Ω–∞ —Å –¥–≤–µ—Ä–Ω—ã–º –ø—Ä–æ–µ–º–æ–º
                    const doorWidth = 3;
                    const sideWidth = (wallData.width - doorWidth) / 2;
                    
                    if (wallData.width > doorWidth*2) { // –¢–æ–ª—å–∫–æ –¥–ª—è –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —à–∏—Ä–æ–∫–∏—Ö —Å—Ç–µ–Ω
                        // –õ–µ–≤–∞—è —á–∞—Å—Ç—å —Å—Ç–µ–Ω—ã
                        const leftWallGeometry = new THREE.BoxGeometry(
                            wallData.width === 1 ? 1 : sideWidth, 
                            height, 
                            wallData.depth === 1 ? 1 : sideWidth
                        );
                        const leftWall = new THREE.Mesh(leftWallGeometry, material);
                        
                        if (wallData.width === 1) { // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞—è —Å—Ç–µ–Ω–∞
                            leftWall.position.set(
                                wallData.x, 
                                height/2, 
                                wallData.z - doorWidth - sideWidth/2
                            );
                        } else { // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–∞—è —Å—Ç–µ–Ω–∞
                            leftWall.position.set(
                                wallData.x - doorWidth/2 - sideWidth/2, 
                                height/2, 
                                wallData.z
                            );
                        }
                        
                        leftWall.castShadow = true;
                        leftWall.receiveShadow = true;
                        scene.add(leftWall);
                        this.walls.push(leftWall);
                        
                        // –ü—Ä–∞–≤–∞—è —á–∞—Å—Ç—å —Å—Ç–µ–Ω—ã
                        const rightWallGeometry = new THREE.BoxGeometry(
                            wallData.width === 1 ? 1 : sideWidth, 
                            height, 
                            wallData.depth === 1 ? 1 : sideWidth
                        );
                        const rightWall = new THREE.Mesh(rightWallGeometry, material);
                        
                        if (wallData.width === 1) { // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞—è —Å—Ç–µ–Ω–∞
                            rightWall.position.set(
                                wallData.x, 
                                height/2, 
                                wallData.z + doorWidth + sideWidth/2
                            );
                        } else { // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–∞—è —Å—Ç–µ–Ω–∞
                            rightWall.position.set(
                                wallData.x + doorWidth/2 + sideWidth/2, 
                                height/2, 
                                wallData.z
                            );
                        }
                        
                        rightWall.castShadow = true;
                        rightWall.receiveShadow = true;
                        scene.add(rightWall);
                        this.walls.push(rightWall);
                        
                        // –í–µ—Ä—Ö–Ω—è—è —á–∞—Å—Ç—å –¥–≤–µ—Ä–Ω–æ–≥–æ –ø—Ä–æ–µ–º–∞
                        const topDoorGeometry = new THREE.BoxGeometry(
                            wallData.width === 1 ? 1 : doorWidth, 
                            height/3, 
                            wallData.depth === 1 ? 1 : doorWidth
                        );
                        const topDoor = new THREE.Mesh(topDoorGeometry, material);
                        
                        topDoor.position.set(
                            wallData.x, 
                            height - height/6, 
                            wallData.z
                        );
                        
                        topDoor.castShadow = true;
                        topDoor.receiveShadow = true;
                        scene.add(topDoor);
                        this.walls.push(topDoor);
                    } else {
                        // –î–ª—è —É–∑–∫–∏—Ö —Å—Ç–µ–Ω –ø—Ä–æ—Å—Ç–æ —Å–æ–∑–¥–∞–µ–º –æ–±—ã—á–Ω—É—é —Å—Ç–µ–Ω—É
                        createRegularWall(wallData);
                    }
                } else {
                    // –û–±—ã—á–Ω–∞—è —Å—Ç–µ–Ω–∞ –±–µ–∑ –ø—Ä–æ–µ–º–∞
                    createRegularWall(wallData);
                }
            }
            
            // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –æ–±—ã—á–Ω–æ–π —Å—Ç–µ–Ω—ã
            function createRegularWall(wallData) {
                const wallGeometry = new THREE.BoxGeometry(wallData.width, height, wallData.depth);
                const wall = new THREE.Mesh(wallGeometry, material);
                wall.position.set(
                    wallData.x, 
                    height/2, 
                    wallData.z
                );
                wall.castShadow = true;
                wall.receiveShadow = true;
                scene.add(wall);
                this.walls.push(wall);
            }
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –¥–µ–∫–æ—Ä–∞—Ç–∏–≤–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
            addDungeonDecorations(x, z, size);
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ –∫–æ—Ä–∏–¥–æ—Ä–∞ –º–µ–∂–¥—É –∫–æ–º–Ω–∞—Ç–∞–º–∏
        function createDungeonCorridor(x1, z1, x2, z2, width, height, material) {
            const dx = x2 - x1;
            const dz = z2 - z1;
            const length = Math.sqrt(dx*dx + dz*dz);
            const angle = Math.atan2(dz, dx);
            
            // –ö–æ—Ä–∏–¥–æ—Ä (–ø–æ–ª –∏ —Å—Ç–µ–Ω—ã)
            const corridorGeometry = new THREE.BoxGeometry(length, 0.1, width);
            const corridorMaterial = new THREE.MeshStandardMaterial({
                color: 0x444444,
                roughness: 0.8,
                metalness: 0.2
            });
            const corridor = new THREE.Mesh(corridorGeometry, corridorMaterial);
            corridor.position.set(
                (x1 + x2) / 2,
                0.05,
                (z1 + z2) / 2
            );
            corridor.rotation.y = angle;
            corridor.receiveShadow = true;
            scene.add(corridor);
            
            // –°—Ç–µ–Ω—ã –∫–æ—Ä–∏–¥–æ—Ä–∞
            const wallGeometry = new THREE.BoxGeometry(length, height, 0.5);
            
            // –õ–µ–≤–∞—è —Å—Ç–µ–Ω–∞
            const leftWall = new THREE.Mesh(wallGeometry, material);
            leftWall.position.set(
                (x1 + x2) / 2,
                height/2,
                (z1 + z2) / 2 + (width/2 - 0.25) * Math.cos(angle + Math.PI/2)
            );
            leftWall.position.x += (width/2 - 0.25) * Math.sin(angle + Math.PI/2);
            leftWall.rotation.y = angle;
            leftWall.castShadow = true;
            leftWall.receiveShadow = true;
            scene.add(leftWall);
            walls.push(leftWall);
            
            // –ü—Ä–∞–≤–∞—è —Å—Ç–µ–Ω–∞
            const rightWall = new THREE.Mesh(wallGeometry, material);
            rightWall.position.set(
                (x1 + x2) / 2,
                height/2,
                (z1 + z2) / 2 + (width/2 - 0.25) * Math.cos(angle - Math.PI/2)
            );
            rightWall.position.x += (width/2 - 0.25) * Math.sin(angle - Math.PI/2);
            rightWall.rotation.y = angle;
            rightWall.castShadow = true;
            rightWall.receiveShadow = true;
            scene.add(rightWall);
            walls.push(rightWall);
            
            // –ü–æ—Ç–æ–ª–æ–∫ –∫–æ—Ä–∏–¥–æ—Ä–∞
            const ceilingGeometry = new THREE.BoxGeometry(length, 0.5, width);
            const ceiling = new THREE.Mesh(ceilingGeometry, material);
            ceiling.position.set(
                (x1 + x2) / 2,
                height,
                (z1 + z2) / 2
            );
            ceiling.rotation.y = angle;
            ceiling.castShadow = true;
            ceiling.receiveShadow = true;
            scene.add(ceiling);
            walls.push(ceiling);
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ñ–∞–∫–µ–ª–æ–≤ –≤–¥–æ–ª—å –∫–æ—Ä–∏–¥–æ—Ä–∞
            const torchCount = Math.floor(length / 5);
            for (let i = 0; i < torchCount; i++) {
                const t = (i + 1) / (torchCount + 1);
                const torchX = x1 + dx * t;
                const torchZ = z1 + dz * t;
                
                // –õ–µ–≤—ã–π —Ñ–∞–∫–µ–ª
                createTorch(
                    torchX + (width/2 - 0.3) * Math.sin(angle + Math.PI/2),
                    height - 1.5,
                    torchZ + (width/2 - 0.3) * Math.cos(angle + Math.PI/2),
                    angle + Math.PI/2
                );
                
                // –ü—Ä–∞–≤—ã–π —Ñ–∞–∫–µ–ª
                createTorch(
                    torchX + (width/2 - 0.3) * Math.sin(angle - Math.PI/2),
                    height - 1.5,
                    torchZ + (width/2 - 0.3) * Math.cos(angle - Math.PI/2),
                    angle - Math.PI/2
                );
            }
        }
        
                // –°–æ–∑–¥–∞–Ω–∏–µ —Ñ–∞–∫–µ–ª–∞
        function createTorch(x, y, z, angle) {
            const torchGroup = new THREE.Group();
            
            // –û—Å–Ω–æ–≤–∞–Ω–∏–µ —Ñ–∞–∫–µ–ª–∞
            const baseGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1, 8);
            const baseMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.8,
                metalness: 0.2,
                map: textures.wood
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = -0.2;
            torchGroup.add(base);
            
            // –û–≥–æ–Ω—å —Ñ–∞–∫–µ–ª–∞
            const fireGeometry = new THREE.ConeGeometry(0.2, 0.5, 8);
            const fireMaterial = new THREE.MeshBasicMaterial({
                color: 0xff4500,
                transparent: true,
                opacity: 0.9
            });
            const fire = new THREE.Mesh(fireGeometry, fireMaterial);
            fire.position.y = 0.45;
            torchGroup.add(fire);
            
            // –°–≤–µ—Ç –æ—Ç —Ñ–∞–∫–µ–ª–∞
            const light = new THREE.PointLight(0xff6a00, 1, 8);
            light.position.y = 0.45;
            torchGroup.add(light);
            
            // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ø–æ–∑–∏—Ü–∏–∏ –∏ –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏
            torchGroup.position.set(x, y, z);
            torchGroup.rotation.z = Math.PI / 2;
            torchGroup.rotation.y = angle;
            
            // –ê–Ω–∏–º–∞—Ü–∏—è –æ–≥–Ω—è
            torchGroup.fireAnimation = {
                intensity: { base: 1, variation: 0.3 },
                color: { hue: 0.05, saturation: 1, lightness: 0.6 },
                scale: { base: 1, variation: 0.2 },
                speed: 0.1,
                time: Math.random() * Math.PI * 2
            };
            
            scene.add(torchGroup);
            return torchGroup;
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ –¥–µ–∫–æ—Ä–∞—Ü–∏–π –¥–ª—è –ø–æ–¥–∑–µ–º–µ–ª—å—è
        function addDungeonDecorations(x, z, size) {
            const halfSize = size / 2 - 2;
            
            // –†–∞—Å—Å—Ç–∞–≤–ª—è–µ–º –±–æ—á–∫–∏
            for (let i = 0; i < 3; i++) {
                const barrelX = x + Math.random() * halfSize * (Math.random() > 0.5 ? 1 : -1);
                const barrelZ = z + Math.random() * halfSize * (Math.random() > 0.5 ? 1 : -1);
                
                createBarrel(barrelX, 0, barrelZ);
            }
            
            // –†–∞—Å—Å—Ç–∞–≤–ª—è–µ–º —è—â–∏–∫–∏
            for (let i = 0; i < 2; i++) {
                const crateX = x + Math.random() * halfSize * (Math.random() > 0.5 ? 1 : -1);
                const crateZ = z + Math.random() * halfSize * (Math.random() > 0.5 ? 1 : -1);
                
                createCrate(crateX, 0, crateZ);
            }
            
            // –†–∞—Å—Å—Ç–∞–≤–ª—è–µ–º –∫–æ–ª–æ–Ω–Ω—ã –ø–æ —É–≥–ª–∞–º
            const columnPositions = [
                { x: x - halfSize * 0.7, z: z - halfSize * 0.7 },
                { x: x + halfSize * 0.7, z: z - halfSize * 0.7 },
                { x: x - halfSize * 0.7, z: z + halfSize * 0.7 },
                { x: x + halfSize * 0.7, z: z + halfSize * 0.7 }
            ];
            
            columnPositions.forEach(pos => {
                createDungeonColumn(pos.x, 0, pos.z);
            });
            
            // –î–æ–±–∞–≤–ª—è–µ–º —Ñ–∞–∫–µ–ª—ã –Ω–∞ —Å—Ç–µ–Ω—ã
            createTorch(x - halfSize + 0.3, 3, z, 0);
            createTorch(x + halfSize - 0.3, 3, z, Math.PI);
            createTorch(x, 3, z - halfSize + 0.3, Math.PI / 2);
            createTorch(x, 3, z + halfSize - 0.3, -Math.PI / 2);
            
            // –°–æ–∑–¥–∞–µ–º —Å—Ç–æ–ª –≤ —Ü–µ–Ω—Ç—Ä–µ –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –∫–æ–º–Ω–∞—Ç
            if (Math.random() > 0.5) {
                createDungeonTable(x, 0, z);
            }
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ –±–æ—á–∫–∏
        function createBarrel(x, y, z) {
            const barrelGeometry = new THREE.CylinderGeometry(0.8, 0.8, 1.5, 16);
            const barrelMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.8,
                metalness: 0.2,
                map: textures.wood
            });
            const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
            
            // –û–±—Ä—É—á–∏ –±–æ—á–∫–∏
            const hoopGeometry = new THREE.TorusGeometry(0.82, 0.05, 8, 16);
            const hoopMaterial = new THREE.MeshStandardMaterial({
                color: 0x444444,
                roughness: 0.6,
                metalness: 0.8
            });
            
            const hoop1 = new THREE.Mesh(hoopGeometry, hoopMaterial);
            hoop1.rotation.x = Math.PI / 2;
            hoop1.position.y = 0.4;
            barrel.add(hoop1);
            
            const hoop2 = new THREE.Mesh(hoopGeometry, hoopMaterial);
            hoop2.rotation.x = Math.PI / 2;
            hoop2.position.y = 0;
            barrel.add(hoop2);
            
            const hoop3 = new THREE.Mesh(hoopGeometry, hoopMaterial);
            hoop3.rotation.x = Math.PI / 2;
            hoop3.position.y = -0.4;
            barrel.add(hoop3);
            
            barrel.position.set(x, y + 0.75, z);
            barrel.rotation.y = Math.random() * Math.PI * 2;
            barrel.castShadow = true;
            barrel.receiveShadow = true;
            
            scene.add(barrel);
            walls.push(barrel);
            
            return barrel;
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —è—â–∏–∫–∞
        function createCrate(x, y, z) {
            const size = 0.8 + Math.random() * 0.4;
            const crateGeometry = new THREE.BoxGeometry(size, size, size);
            const crateMaterial = new THREE.MeshStandardMaterial({
                map: textures.crate,
                roughness: 0.8,
                metalness: 0.2
            });
            const crate = new THREE.Mesh(crateGeometry, crateMaterial);
            
            crate.position.set(x, y + size/2, z);
            crate.rotation.y = Math.random() * Math.PI / 2;
            crate.castShadow = true;
            crate.receiveShadow = true;
            
            scene.add(crate);
            walls.push(crate);
            
            return crate;
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ –∫–æ–ª–æ–Ω–Ω—ã –ø–æ–¥–∑–µ–º–µ–ª—å—è
        function createDungeonColumn(x, y, z) {
            const columnGroup = new THREE.Group();
            
            // –û—Å–Ω–æ–≤–∞–Ω–∏–µ –∫–æ–ª–æ–Ω–Ω—ã
            const baseGeometry = new THREE.CylinderGeometry(1, 1.2, 0.5, 8);
            const baseMaterial = new THREE.MeshStandardMaterial({
                color: 0x666666,
                roughness: 0.9,
                metalness: 0.1
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 0.25;
            columnGroup.add(base);
            
            // –°—Ç–≤–æ–ª –∫–æ–ª–æ–Ω–Ω—ã
            const shaftGeometry = new THREE.CylinderGeometry(0.8, 0.8, 6, 8);
            const shaftMaterial = new THREE.MeshStandardMaterial({
                color: 0x888888,
                roughness: 0.7,
                metalness: 0.2
            });
            const shaft = new THREE.Mesh(shaftGeometry, shaftMaterial);
            shaft.position.y = 3.5;
            columnGroup.add(shaft);
            
            // –ö–∞–ø–∏—Ç–µ–ª—å –∫–æ–ª–æ–Ω–Ω—ã
            const capitalGeometry = new THREE.CylinderGeometry(1.2, 0.8, 0.5, 8);
            const capital = new THREE.Mesh(capitalGeometry, baseMaterial);
            capital.position.y = 6.75;
            columnGroup.add(capital);
            
            // –û—Ä–Ω–∞–º–µ–Ω—Ç –Ω–∞ –∫–∞–ø–∏—Ç–µ–ª–∏
            const ornamentGeometry = new THREE.BoxGeometry(2.5, 0.3, 2.5);
            const ornament = new THREE.Mesh(ornamentGeometry, baseMaterial);
            ornament.position.y = 7.15;
            columnGroup.add(ornament);
            
            columnGroup.position.set(x, y, z);
            columnGroup.castShadow = true;
            columnGroup.receiveShadow = true;
            
            scene.add(columnGroup);
            walls.push(columnGroup);
            
            return columnGroup;
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —Å—Ç–æ–ª–∞ –ø–æ–¥–∑–µ–º–µ–ª—å—è
        function createDungeonTable(x, y, z) {
            const tableGroup = new THREE.Group();
            
            // –°—Ç–æ–ª–µ—à–Ω–∏—Ü–∞
            const topGeometry = new THREE.BoxGeometry(4, 0.2, 2);
            const topMaterial = new THREE.MeshStandardMaterial({
                color: 0x5D4037,
                roughness: 0.8,
                metalness: 0.2,
                map: textures.wood
            });
            const top = new THREE.Mesh(topGeometry, topMaterial);
            top.position.y = 1.5;
            tableGroup.add(top);
            
            // –ù–æ–∂–∫–∏ —Å—Ç–æ–ª–∞
            const legGeometry = new THREE.BoxGeometry(0.3, 1.5, 0.3);
            const legMaterial = new THREE.MeshStandardMaterial({
                color: 0x4E342E,
                roughness: 0.8,
                metalness: 0.2,
                map: textures.wood
            });
            
            // –ß–µ—Ç—ã—Ä–µ –Ω–æ–∂–∫–∏ –ø–æ —É–≥–ª–∞–º
            const legPositions = [
                { x: -1.8, z: -0.8 },
                { x: 1.8, z: -0.8 },
                { x: -1.8, z: 0.8 },
                { x: 1.8, z: 0.8 }
            ];
            
            legPositions.forEach(pos => {
                const leg = new THREE.Mesh(legGeometry, legMaterial);
                leg.position.set(pos.x, 0.75, pos.z);
                tableGroup.add(leg);
            });
            
            // –ü—Ä–µ–¥–º–µ—Ç—ã –Ω–∞ —Å—Ç–æ–ª–µ
            // –ö–Ω–∏–≥–∞
            const bookGeometry = new THREE.BoxGeometry(0.6, 0.1, 0.8);
            const bookMaterial = new THREE.MeshStandardMaterial({
                color: 0xA1887F,
                roughness: 0.9,
                metalness: 0.1
            });
            const book = new THREE.Mesh(bookGeometry, bookMaterial);
            book.position.set(-1, 1.65, -0.5);
            book.rotation.y = Math.PI / 6;
            tableGroup.add(book);
            
            // –°–≤–µ—á–∞
            const candleGeometry = new THREE.CylinderGeometry(0.05, 0.07, 0.3, 8);
            const candleMaterial = new THREE.MeshStandardMaterial({
                color: 0xEEEEEE,
                roughness: 0.8,
                metalness: 0.2
            });
            const candle = new THREE.Mesh(candleGeometry, candleMaterial);
            candle.position.set(0.8, 1.65, 0);
            tableGroup.add(candle);
            
            // –ü–ª–∞–º—è —Å–≤–µ—á–∏
            const flameGeometry = new THREE.ConeGeometry(0.04, 0.15, 8);
            const flameMaterial = new THREE.MeshBasicMaterial({
                color: 0xFF9800,
                transparent: true,
                opacity: 0.9
            });
            const flame = new THREE.Mesh(flameGeometry, flameMaterial);
            flame.position.set(0, 0.225, 0);
            candle.add(flame);
            
            // –°–≤–µ—Ç –æ—Ç —Å–≤–µ—á–∏
            const candleLight = new THREE.PointLight(0xFF9800, 0.8, 5);
            candleLight.position.set(0, 0.225, 0);
            candle.add(candleLight);
            
            // –ß–∞—à–∞
            const bowlGeometry = new THREE.CylinderGeometry(0.3, 0.2, 0.2, 16);
            const bowlMaterial = new THREE.MeshStandardMaterial({
                color: 0xB0BEC5,
                roughness: 0.5,
                metalness: 0.8
            });
            const bowl = new THREE.Mesh(bowlGeometry, bowlMaterial);
            bowl.position.set(0, 1.6, 0.5);
            tableGroup.add(bowl);
            
            tableGroup.position.set(x, y, z);
            tableGroup.castShadow = true;
            tableGroup.receiveShadow = true;
            
            scene.add(tableGroup);
            walls.push(tableGroup);
            
            return tableGroup;
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ –ø–ª–∞—Ç—Ñ–æ—Ä–º –Ω–∞–¥ –ª–∞–≤–æ–π
        function createLavaPlatforms(centerX, centerZ, count) {
            // –õ–∞–≤–∞ –Ω–∞ –ø–æ–ª—É
            const lavaSize = 40;
            const lavaGeometry = new THREE.PlaneGeometry(lavaSize, lavaSize);
            const lavaMaterial = new THREE.MeshStandardMaterial({
                map: textures.lava,
                emissive: 0xff5500,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.8
            });
            const lava = new THREE.Mesh(lavaGeometry, lavaMaterial);
            lava.rotation.x = -Math.PI / 2;
            lava.position.set(centerX, 0.1, centerZ);
            scene.add(lava);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –ø–ª–∞—Ç—Ñ–æ—Ä–º
            const platforms = [];
            
            // –°—Ç–∞—Ä—Ç–æ–≤–∞—è –ø–ª–∞—Ç—Ñ–æ—Ä–º–∞
            const startPlatform = createPlatform(5, 1, 5, centerX, 0, centerZ + 15, 0x555555);
            platforms.push(startPlatform);
            
            // –ö–æ–Ω–µ—á–Ω–∞—è –ø–ª–∞—Ç—Ñ–æ—Ä–º–∞
            const endPlatform = createPlatform(5, 1, 5, centerX, 0, centerZ - 15, 0x555555);
            platforms.push(endPlatform);
            
            // –ü—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–µ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã
            const distanceBetweenPlatforms = 30 / (count + 1);
            
            for (let i = 0; i < count; i++) {
                const t = (i + 1) / (count + 1);
                const x = centerX + (Math.random() - 0.5) * 10;
                const z = centerZ + 15 - t * 30;
                
                const size = 1.5 + Math.random();
                const platform = createPlatform(size, 1, size, x, 0, z, 0x555555);
                
                // –î–µ–ª–∞–µ–º –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã –¥–≤–∏–∂—É—â–∏–º–∏—Å—è
                if (i % 3 === 1) {
                    platform.isMoving = true;
                    platform.startPosition = new THREE.Vector3(x, 0, z);
                    platform.rangeX = 5;
                    platform.rangeY = 0;
                    platform.rangeZ = 0;
                    platform.movementSpeed = 0.02;
                    platform.movementDirection = 1;
                    platform.movementProgress = 0;
                } else if (i % 3 === 2) {
                    platform.isMoving = true;
                    platform.startPosition = new THREE.Vector3(x, 0, z);
                    platform.rangeX = 0;
                    platform.rangeY = 0;
                    platform.rangeZ = 5;
                    platform.movementSpeed = 0.02;
                    platform.movementDirection = 1;
                    platform.movementProgress = 0;
                }
                
                platforms.push(platform);
            }
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —Ç–æ—á–µ—á–Ω—ã—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤ —Å–≤–µ—Ç–∞ –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∞ –ª–∞–≤—ã
            for (let i = 0; i < 5; i++) {
                const lightX = centerX + (Math.random() - 0.5) * lavaSize * 0.8;
                const lightZ = centerZ + (Math.random() - 0.5) * lavaSize * 0.8;
                
                const lavaLight = new THREE.PointLight(0xff3300, 1, 10);
                lavaLight.position.set(lightX, 0.5, lightZ);
                lavaLight.intensity = 0.5 + Math.random() * 0.5;
                scene.add(lavaLight);
                
                // –ê–Ω–∏–º–∞—Ü–∏—è —Å–≤–µ—Ç–∞
                lavaLight.animation = {
                    intensity: { min: 0.5, max: 1.0 },
                    speed: 0.01 + Math.random() * 0.02,
                    phase: Math.random() * Math.PI * 2
                };
            }
            
            return platforms;
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ –±–æ—Å—Å–∞
        function createFinalBoss(x, y, z) {
            const bossGroup = new THREE.Group();
            
            // –¢–µ–ª–æ –±–æ—Å—Å–∞ (–±–æ–ª–µ–µ —Å–ª–æ–∂–Ω–∞—è –≥–µ–æ–º–µ—Ç—Ä–∏—è)
            const bodyGeometry = new THREE.DodecahedronGeometry(2.5, 1);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x660066,
                roughness: 0.5,
                metalness: 0.8,
                emissive: 0x330033,
                emissiveIntensity: 0.3
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 3;
            body.castShadow = true;
            body.receiveShadow = true;
            bossGroup.add(body);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ "–∫–æ—Ä–æ–Ω—ã" –Ω–∞ –≥–æ–ª–æ–≤–µ –±–æ—Å—Å–∞
            const spikes = 8;
            for (let i = 0; i < spikes; i++) {
                const angle = (i / spikes) * Math.PI * 2;
                const spikeGeometry = new THREE.ConeGeometry(0.3, 1.5, 6);
                const spikeMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x990099,
                    roughness: 0.5,
                    metalness: 0.8,
                    emissive: 0x550055,
                    emissiveIntensity: 0.3
                });
                const spike = new THREE.Mesh(spikeGeometry, spikeMaterial);
                spike.position.set(
                    Math.sin(angle) * 2.5,
                    5,
                    Math.cos(angle) * 2.5
                );
                spike.rotation.x = Math.PI/2;
                spike.rotation.z = -angle;
                bossGroup.add(spike);
            }
            
            // –≠—Ñ—Ñ–µ–∫—Ç –≥–ª–∞–∑
            const createEye = (posX) => {
                const eyeGroup = new THREE.Group();
                
                // –ì–ª–∞–∑–Ω–æ–µ —è–±–ª–æ–∫–æ
                const eyeGeometry = new THREE.SphereGeometry(0.4, 16, 16);
                const eyeMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x000000,
                    roughness: 0.1,
                    metalness: 1.0,
                    emissive: 0x330000,
                    emissiveIntensity: 0.8
                });
                const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                eyeGroup.add(eye);
                
                // –ó—Ä–∞—á–æ–∫
                const pupilGeometry = new THREE.SphereGeometry(0.2, 16, 16);
                const pupilMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff0000
                });
                const pupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                pupil.position.z = 0.25;
                eyeGroup.add(pupil);
                
                // –°–≤–µ—Ç –∏–∑ –≥–ª–∞–∑
                const eyeLight = new THREE.PointLight(0xff0000, 1, 10);
                eyeLight.position.z = 0.5;
                eyeGroup.add(eyeLight);
                
                eyeGroup.position.set(posX, 3.5, 1.8);
                
                return eyeGroup;
            };
            
            bossGroup.add(createEye(-0.8));
            bossGroup.add(createEye(0.8));
            
            // –©—É–ø–∞–ª—å—Ü–∞ –±–æ—Å—Å–∞
            const tentacleCount = 6;
            const segments = 8;
            
            for (let i = 0; i < tentacleCount; i++) {
                const angle = (i / tentacleCount) * Math.PI * 2;
                const tentacleGroup = new THREE.Group();
                
                for (let j = 0; j < segments; j++) {
                    const segmentGeometry = new THREE.SphereGeometry(0.4 - j * 0.03, 8, 8);
                    const segmentMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x990099,
                        roughness: 0.7,
                        metalness: 0.5
                    });
                    const segment = new THREE.Mesh(segmentGeometry, segmentMaterial);
                    segment.position.y = -j * 0.8;
                    tentacleGroup.add(segment);
                }
                
                tentacleGroup.rotation.x = Math.PI/4;
                tentacleGroup.rotation.y = angle;
                tentacleGroup.position.set(
                    Math.sin(angle) * 2,
                    1,
                    Math.cos(angle) * 2
                );
                
                // –ê–Ω–∏–º–∞—Ü–∏—è —â—É–ø–∞–ª—å—Ü–∞
                tentacleGroup.animation = {
                    waveAmplitude: 0.2,
                    waveFrequency: 1 + Math.random() * 0.5,
                    waveOffset: Math.random() * Math.PI * 2
                };
                
                bossGroup.add(tentacleGroup);
            }
            
            // –≠—Ñ—Ñ–µ–∫—Ç —Å–≤–µ—á–µ–Ω–∏—è –≤–æ–∫—Ä—É–≥ –±–æ—Å—Å–∞
            const glowGeometry = new THREE.SphereGeometry(4, 32, 32);
            const glowMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff00ff,
                transparent: true,
                opacity: 0.1,
                side: THREE.BackSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.y = 3;
            bossGroup.add(glow);
            
            // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –±–æ—Å—Å–∞
            bossGroup.position.set(x, y, z);
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–≤–æ–π—Å—Ç–≤ –±–æ—Å—Å–∞
            bossGroup.health = 1000;  // –û—á–µ–Ω—å –º–Ω–æ–≥–æ –∑–¥–æ—Ä–æ–≤—å—è
            bossGroup.speed = 0.04;   // –ú–µ–¥–ª–µ–Ω–Ω—ã–π, –Ω–æ —Å–∏–ª—å–Ω—ã–π
            bossGroup.lastShot = 0;
            bossGroup.shootInterval = 800;
            bossGroup.attackMode = 'normal';  // –†–µ–∂–∏–º—ã –∞—Ç–∞–∫–∏: normal, rage, shield
            bossGroup.isBoss = true;
            bossGroup.isFinalBoss = true;
            bossGroup.attackPhase = 0;
            bossGroup.attackTimer = 0;
            bossGroup.phaseTimer = 0;
            
            // –ê–Ω–∏–º–∞—Ü–∏–∏ –±–æ—Å—Å–∞
            bossGroup.animations = {
                bobbing: { amplitude: 0.5, frequency: 0.3, offset: 0 },
                rotation: { speed: 0.005, axis: new THREE.Vector3(0, 1, 0) }
            };
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –±–æ—Å—Å–∞ –Ω–∞ —Å—Ü–µ–Ω—É
            scene.add(bossGroup);
            bosses.push(bossGroup);
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–µ–≤–∏–¥–∏–º–æ–≥–æ —Ö–µ–ª–ø–µ—Ä–∞ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –ø–æ–ø–∞–¥–∞–Ω–∏–π
            const helperGeometry = new THREE.SphereGeometry(2.5, 16, 16);
            const helperMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff0000,
                transparent: true,
                opacity: 0.0 // –ù–µ–≤–∏–¥–∏–º—ã–π
            });
            const helper = new THREE.Mesh(helperGeometry, helperMaterial);
            helper.position.copy(bossGroup.position);
            helper.position.y = 3;
            helper.enemyRef = bossGroup; // –°—Å—ã–ª–∫–∞ –Ω–∞ –±–æ—Å—Å–∞
            scene.add(helper);
            enemyHelpers.push(helper);
            
            return bossGroup;
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–æ–¥–≤–∏–Ω—É—Ç–æ–≥–æ —É—Ä–æ–≤–Ω—è –¥–ª—è –≤—ã—Å–æ–∫–∏—Ö —É—Ä–æ–≤–Ω–µ–π
        function createAdvancedLevel(size) {
            const halfSize = size / 2 - 10;
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –º–Ω–æ–≥–æ—É—Ä–æ–≤–Ω–µ–≤—ã—Ö –ø–ª–∞—Ç—Ñ–æ—Ä–º
            for (let i = 0; i < 5; i++) {
                createPlatform(10 - i, 1, 10 - i, 0, i * 3, -20 - i * 5, 0x4d4dff + i * 0x001100);
            }
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –¥–≤–∏–∂—É—â–∏—Ö—Å—è –ø–ª–∞—Ç—Ñ–æ—Ä–º
            createMovingPlatform(5, 1, 5, 20, 5, 0, 20, 0, 20, 0x4dffbd);
            createMovingPlatform(5, 1, 5, -20, 10, -20, 20, 0, 0, 0x4dffda);
            createMovingPlatform(5, 1, 5, 0, 15, 20, 0, 5, 0, 0x4deeff);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —Å–ª–æ–∂–Ω—ã—Ö –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π –∏ –±–∞—Ä—å–µ—Ä–æ–≤
            createObstacle(2, 10, 30, -30, 5, 0, 0x8c8c8c);
            createObstacle(30, 10, 2, 0, 5, 30, 0x8c8c8c);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –≤—Ä–∞—â–∞—é—â–∏—Ö—Å—è –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π
            createRotatingObstacle(2, 10, 2, 0, 5, 0, 0x8c8c8c);
            createRotatingObstacle(20, 1, 1, 0, 10, 0, 0xff4d4d);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –∫–æ–ª–ª–µ–∫—Ç–∏–±–ª–æ–≤
            createCollectible(0, 15, -40, 'key');
            createCollectible(20, 6, 0, 'ammo');
            createCollectible(-20, 11, -20, 'health');
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —Å–µ–∫—Ä–µ—Ç–Ω—ã—Ö –¥–≤–µ—Ä–µ–π
            createSecretDoor(10, 5, 2, halfSize - 5, 2.5, 0, 0x7d4d4d);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—ã—Ö —Ç–æ—á–µ–∫
            createCheckpoint(0, 0, 0);
            createCheckpoint(0, 15, -40);
            createCheckpoint(0, 13, 20);
        }
        
        // –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã
        function createPlatform(width, height, depth, x, y, z, color) {
            const platformGeometry = new THREE.BoxGeometry(width, height, depth);
            const platformMaterial = new THREE.MeshStandardMaterial({ 
                color: color || 0x4d4dff,
                map: textures.metal,
                roughness: 0.4,
                metalness: 0.6
            });
            const platform = new THREE.Mesh(platformGeometry, platformMaterial);
            platform.position.set(x, y, z);
            platform.castShadow = true;
            platform.receiveShadow = true;
            scene.add(platform);
            walls.push(platform);
            platforms.push(platform);
            return platform;
        }
        
        // –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è –¥–≤–∏–∂—É—â–µ–π—Å—è –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã
        function createMovingPlatform(width, height, depth, x, y, z, rangeX, rangeY, rangeZ, color) {
            const platform = createPlatform(width, height, depth, x, y, z, color);
            platform.isMoving = true;
            platform.startPosition = new THREE.Vector3(x, y, z);
            platform.rangeX = rangeX;
            platform.rangeY = rangeY;
            platform.rangeZ = rangeZ;
            platform.movementSpeed = 0.02;
            platform.movementDirection = 1;
            platform.movementProgress = 0;
            return platform;
        }
        
        // –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è –≤—Ä–∞—â–∞—é—â–µ–≥–æ—Å—è –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è
        function createRotatingObstacle(width, height, depth, x, y, z, color) {
            const obstacleGeometry = new THREE.BoxGeometry(width, height, depth);
            const obstacleMaterial = new THREE.MeshStandardMaterial({ 
                color: color || 0x8c8c8c,
                map: textures.metal,
                roughness: 0.6,
                metalness: 0.4
            });
                        const obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
            obstacle.position.set(x, y, z);
            obstacle.castShadow = true;
            obstacle.receiveShadow = true;
            scene.add(obstacle);
            walls.push(obstacle);
            
            obstacle.isRotating = true;
            obstacle.rotationSpeed = 0.02;
            obstacle.rotationAxis = new THREE.Vector3(0, 1, 0);
            
            return obstacle;
        }
        
        // –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è
        function createObstacle(width, height, depth, x, y, z, color) {
            const obstacleGeometry = new THREE.BoxGeometry(width, height, depth);
            const obstacleMaterial = new THREE.MeshStandardMaterial({ 
                color: color || 0x8c8c8c,
                map: textures.wall,
                roughness: 0.8,
                metalness: 0.2
            });
            const obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
            obstacle.position.set(x, y, z);
            obstacle.castShadow = true;
            obstacle.receiveShadow = true;
            scene.add(obstacle);
            walls.push(obstacle);
            return obstacle;
        }
        
        // –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è –∫–æ–ª–ª–µ–∫—Ç–∏–±–ª–∞
        function createCollectible(x, y, z, type) {
            let collectibleGeometry, collectibleMaterial;
            
            switch(type) {
                case 'key':
                    collectibleGeometry = new THREE.TorusGeometry(0.5, 0.2, 16, 32);
                    collectibleMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0xffcc00,
                        metalness: 0.8,
                        roughness: 0.2,
                        emissive: 0xffcc00,
                        emissiveIntensity: 0.5
                    });
                    break;
                case 'health':
                    collectibleGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
                    collectibleMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x00ff00,
                        metalness: 0.5,
                        roughness: 0.5,
                        emissive: 0x00ff00,
                        emissiveIntensity: 0.5
                    });
                    break;
                case 'ammo':
                    collectibleGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.8, 8);
                    collectibleMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0xffff00,
                        metalness: 0.7,
                        roughness: 0.3,
                        emissive: 0xffff00,
                        emissiveIntensity: 0.5
                    });
                    break;
                case 'artifact':
                    collectibleGeometry = new THREE.OctahedronGeometry(0.6, 0);
                    collectibleMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x00ffff,
                        metalness: 0.9,
                        roughness: 0.1,
                        emissive: 0x00ffff,
                        emissiveIntensity: 0.7
                    });
                    break;
                default:
                    collectibleGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                    collectibleMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x00ffff,
                        metalness: 0.6,
                        roughness: 0.4,
                        emissive: 0x00ffff,
                        emissiveIntensity: 0.5
                    });
            }
            
            const collectible = new THREE.Mesh(collectibleGeometry, collectibleMaterial);
            collectible.position.set(x, y, z);
            collectible.castShadow = true;
            collectible.receiveShadow = true;
            collectible.collectibleType = type;
            collectible.rotation.x = Math.PI / 2;
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∞–Ω–∏–º–∞—Ü–∏–∏ –≤—Ä–∞—â–µ–Ω–∏—è –∏ –ø–æ–¥–ø—Ä—ã–≥–∏–≤–∞–Ω–∏—è
            collectible.isCollectible = true;
            collectible.rotationSpeed = 0.02;
            collectible.floatSpeed = 0.01;
            collectible.floatHeight = 0.5;
            collectible.floatDirection = 1;
            collectible.floatProgress = 0;
            collectible.originalY = y;
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–≤–µ—Ç–∞ –≤–æ–∫—Ä—É–≥ –ø—Ä–µ–¥–º–µ—Ç–∞
            const light = new THREE.PointLight(collectibleMaterial.color, 0.8, 3);
            collectible.add(light);
            
            scene.add(collectible);
            collectibles.push(collectible);
            return collectible;
        }
        
        // –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è —Å–µ–∫—Ä–µ—Ç–Ω–æ–π –¥–≤–µ—Ä–∏
        function createSecretDoor(width, height, depth, x, y, z, color) {
            const doorGeometry = new THREE.BoxGeometry(width, height, depth);
            const doorMaterial = new THREE.MeshStandardMaterial({ 
                color: color || 0x7d4d4d,
                map: textures.wood,
                roughness: 0.7,
                metalness: 0.3
            });
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.set(x, y, z);
            door.castShadow = true;
            door.receiveShadow = true;
            door.isSecretDoor = true;
            door.isOpen = false;
            scene.add(door);
            walls.push(door);
            secretDoors.push(door);
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∑–∞–º–æ—á–Ω–æ–π —Å–∫–≤–∞–∂–∏–Ω—ã
            const keyholeCutout = new THREE.Mesh(
                new THREE.BoxGeometry(0.3, 0.5, depth * 0.6),
                new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            keyholeCutout.position.set(0, 0, -depth * 0.3);
            door.add(keyholeCutout);
            
            return door;
        }
        
        // –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω–æ–π —Ç–æ—á–∫–∏
        function createCheckpoint(x, y, z) {
            const checkpointGeometry = new THREE.CylinderGeometry(1, 1, 0.2, 16);
            const checkpointMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x00ffff,
                transparent: true,
                opacity: 0.5,
                emissive: 0x00ffff,
                emissiveIntensity: 0.5
            });
            const checkpoint = new THREE.Mesh(checkpointGeometry, checkpointMaterial);
            checkpoint.position.set(x, y + 0.1, z);
            checkpoint.rotation.x = Math.PI / 2;
            checkpoint.receiveShadow = true;
            checkpoint.isCheckpoint = true;
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ —Å–≤–µ—á–µ–Ω–∏—è
            const glowGeometry = new THREE.CylinderGeometry(1.2, 1.2, 0.1, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ffff,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            checkpoint.add(glow);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —Å—Ç–æ–ª–±–∞ —Å–≤–µ—Ç–∞
            const lightBeamGeometry = new THREE.CylinderGeometry(0.1, 0.1, 10, 8);
            const lightBeamMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ffff,
                transparent: true,
                opacity: 0.2
            });
            const lightBeam = new THREE.Mesh(lightBeamGeometry, lightBeamMaterial);
            lightBeam.position.y = 5;
            checkpoint.add(lightBeam);
            
            // –°–≤–µ—Ç –æ—Ç –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω–æ–π —Ç–æ—á–∫–∏
            const checkpointLight = new THREE.PointLight(0x00ffff, 1, 10);
            checkpointLight.position.y = 0.5;
            checkpoint.add(checkpointLight);
            
            scene.add(checkpoint);
            return checkpoint;
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ –≤—Ä–∞–≥–∞
        function createEnemy(x, y, z, type = 'basic') {
            const enemyGroup = new THREE.Group();
            let enemyColor, enemyHealth, enemySpeed, enemyShootInterval;
            
            // –†–∞–∑–ª–∏—á–Ω—ã–µ —Ç–∏–ø—ã –≤—Ä–∞–≥–æ–≤
            switch(type) {
                case 'basic': // –û–±—ã—á–Ω—ã–π –≤—Ä–∞–≥
                    enemyColor = 0xff0000;
                    enemyHealth = 100;
                    enemySpeed = 0.05;
                    enemyShootInterval = 2000;
                    break;
                case 'maze': // –í—Ä–∞–≥ –≤ –ª–∞–±–∏—Ä–∏–Ω—Ç–µ, –±—ã—Å—Ç—Ä–µ–µ
                    enemyColor = 0xff3300;
                    enemyHealth = 120;
                    enemySpeed = 0.08;
                    enemyShootInterval = 1800;
                    break;
                case 'guard': // –û—Ö—Ä–∞–Ω–Ω–∏–∫ –∫—Ä–µ–ø–æ—Å—Ç–∏, —Å–∏–ª—å–Ω–µ–µ
                    enemyColor = 0x990000;
                    enemyHealth = 150;
                    enemySpeed = 0.06;
                    enemyShootInterval = 1500;
                    break;
                case 'dungeon': // –í—Ä–∞–≥ –ø–æ–¥–∑–µ–º–µ–ª—å—è, –µ—â–µ —Å–∏–ª—å–Ω–µ–µ
                    enemyColor = 0x660000;
                    enemyHealth = 200;
                    enemySpeed = 0.04;
                    enemyShootInterval = 1200;
                    break;
                default:
                    enemyColor = 0xff0000;
                    enemyHealth = 100;
                    enemySpeed = 0.05;
                    enemyShootInterval = 2000;
            }
            
            // –¢–µ–ª–æ –≤—Ä–∞–≥–∞
            const bodyGeometry = new THREE.BoxGeometry(1.5, 2, 1);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: enemyColor,
                roughness: 0.7,
                metalness: 0.3,
                map: textures.enemy
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1;
            body.castShadow = true;
            body.receiveShadow = true;
            enemyGroup.add(body);
            
            // –ì–æ–ª–æ–≤–∞ –≤—Ä–∞–≥–∞
            const headGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({ 
                color: enemyColor,
                roughness: 0.7,
                metalness: 0.3
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 2.5;
            head.castShadow = true;
            head.receiveShadow = true;
            enemyGroup.add(head);
            
            // –†—É–∫–∏ –≤—Ä–∞–≥–∞
            const armGeometry = new THREE.CylinderGeometry(0.2, 0.2, 1.5, 8);
            const armMaterial = new THREE.MeshStandardMaterial({ 
                color: enemyColor,
                roughness: 0.7,
                metalness: 0.3
            });
            
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.9, 1, 0);
            leftArm.rotation.z = Math.PI / 2;
            leftArm.castShadow = true;
            leftArm.receiveShadow = true;
            enemyGroup.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.9, 1, 0);
            rightArm.rotation.z = -Math.PI / 2;
            rightArm.castShadow = true;
            rightArm.receiveShadow = true;
            enemyGroup.add(rightArm);
            
            // –ù–æ–≥–∏ –≤—Ä–∞–≥–∞
            const legGeometry = new THREE.CylinderGeometry(0.25, 0.25, 1, 8);
            const legMaterial = new THREE.MeshStandardMaterial({ 
                color: enemyColor,
                roughness: 0.7,
                metalness: 0.3
            });
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.5, -0.5, 0);
            leftLeg.castShadow = true;
            leftLeg.receiveShadow = true;
            enemyGroup.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.5, -0.5, 0);
            rightLeg.castShadow = true;
            rightLeg.receiveShadow = true;
            enemyGroup.add(rightLeg);
            
            // –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ –¥–µ—Ç–∞–ª–∏ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤ –≤—Ä–∞–≥–æ–≤
            if (type === 'guard') {
                // –®–ª–µ–º –¥–ª—è –æ—Ö—Ä–∞–Ω–Ω–∏–∫–∞
                const helmetGeometry = new THREE.ConeGeometry(0.6, 0.8, 8);
                const helmetMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x444444,
                    roughness: 0.5,
                    metalness: 0.8
                });
                const helmet = new THREE.Mesh(helmetGeometry, helmetMaterial);
                helmet.position.y = 3;
                helmet.castShadow = true;
                enemyGroup.add(helmet);
                
                // –û—Ä—É–∂–∏–µ –¥–ª—è –æ—Ö—Ä–∞–Ω–Ω–∏–∫–∞
                const weaponGeometry = new THREE.BoxGeometry(0.3, 0.3, 2);
                const weaponMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x222222,
                    roughness: 0.5,
                    metalness: 0.8
                });
                const weapon = new THREE.Mesh(weaponGeometry, weaponMaterial);
                weapon.position.set(1.5, 1, 0);
                weapon.rotation.y = Math.PI / 2;
                enemyGroup.add(weapon);
            } else if (type === 'dungeon') {
                // –ü–ª–∞—â –¥–ª—è –≤—Ä–∞–≥–∞ –ø–æ–¥–∑–µ–º–µ–ª—å—è
                const cloakGeometry = new THREE.CylinderGeometry(1, 1.5, 3, 8, 1, true);
                const cloakMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x330000,
                    roughness: 0.9,
                    metalness: 0.1,
                    side: THREE.DoubleSide
                });
                const cloak = new THREE.Mesh(cloakGeometry, cloakMaterial);
                cloak.position.y = 0.5;
                cloak.castShadow = true;
                enemyGroup.add(cloak);
                
                // –°–≤–µ—á–µ–Ω–∏–µ –≥–ª–∞–∑
                const eyeGlowGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeGlowMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff0000,
                    transparent: true,
                    opacity: 0.8
                });
                
                const leftEyeGlow = new THREE.Mesh(eyeGlowGeometry, eyeGlowMaterial);
                leftEyeGlow.position.set(-0.2, 2.5, 0.4);
                enemyGroup.add(leftEyeGlow);
                
                const rightEyeGlow = new THREE.Mesh(eyeGlowGeometry, eyeGlowMaterial);
                rightEyeGlow.position.set(0.2, 2.5, 0.4);
                enemyGroup.add(rightEyeGlow);
                
                // –°–≤–µ—Ç –æ—Ç –≥–ª–∞–∑
                const eyeLight = new THREE.PointLight(0xff0000, 0.5, 3);
                eyeLight.position.set(0, 2.5, 0.5);
                enemyGroup.add(eyeLight);
            }
            
            // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Ä–∞–≥–∞
            enemyGroup.position.set(x, y, z);
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–≤–æ–π—Å—Ç–≤ –≤—Ä–∞–≥–∞
            enemyGroup.health = enemyHealth;
            enemyGroup.speed = enemySpeed * (1 + level * 0.1);
            enemyGroup.lastShot = 0;
            enemyGroup.shootInterval = enemyShootInterval - level * 100;
            if (enemyGroup.shootInterval < 500) enemyGroup.shootInterval = 500;
            enemyGroup.type = type;
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∫–æ–ª–ª–∞–π–¥–µ—Ä–∞ –¥–ª—è –≤—Ä–∞–≥–∞
            enemyGroup.collider = new THREE.Box3().setFromObject(enemyGroup);
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤—Ä–∞–≥–∞ –Ω–∞ —Å—Ü–µ–Ω—É
            scene.add(enemyGroup);
            enemies.push(enemyGroup);
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–µ–≤–∏–¥–∏–º–æ–≥–æ —Ö–µ–ª–ø–µ—Ä–∞ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –ø–æ–ø–∞–¥–∞–Ω–∏–π
            const helperGeometry = new THREE.BoxGeometry(1.5, 3, 1.5);
            const helperMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff0000,
                transparent: true,
                opacity: 0.0 // –ù–µ–≤–∏–¥–∏–º—ã–π
            });
            const helper = new THREE.Mesh(helperGeometry, helperMaterial);
            helper.position.copy(enemyGroup.position);
            helper.position.y = 1.5;
            helper.enemyRef = enemyGroup; // –°—Å—ã–ª–∫–∞ –Ω–∞ –≤—Ä–∞–≥–∞
            scene.add(helper);
            enemyHelpers.push(helper);
            
            return enemyGroup;
        }
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞–∂–∞—Ç–∏—è –∫–ª–∞–≤–∏—à
        function onKeyDown(event) {
            if (gameOver || levelCompleted) return;
            
            switch (event.code) {
                case 'KeyW':
                case 'ArrowUp':
                    moveForward = true;
                    isPlayerMoving = true;
                    break;
                case 'KeyS':
                case 'ArrowDown':
                    moveBackward = true;
                    isPlayerMoving = true;
                    break;
                case 'KeyA':
                case 'ArrowLeft':
                    moveLeft = true;
                    isPlayerMoving = true;
                    break;
                case 'KeyD':
                case 'ArrowRight':
                    moveRight = true;
                    isPlayerMoving = true;
                    break;
                case 'Space':
                    if (canJump) {
                        player.velocity.y = JUMP_FORCE;
                        canJump = false;
                    }
                    break;
                case 'ShiftLeft':
                case 'ShiftRight':
                    isRunning = true;
                    break;
                case 'KeyC':
                    isCrouching = !isCrouching;
                    if (isCrouching) {
                        player.position.y = 1;
                        camera.position.y = 0;
                    } else {
                        player.position.y = 2;
                        camera.position.y = 0;
                    }
                    break;
                case 'KeyR':
                    reload();
                    break;
                case 'KeyE':
                    interact();
                    break;
            }
        }
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç–ø—É—Å–∫–∞–Ω–∏—è –∫–ª–∞–≤–∏—à
        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW':
                case 'ArrowUp':
                    moveForward = false;
                    isPlayerMoving = moveBackward || moveLeft || moveRight;
                    break;
                case 'KeyS':
                case 'ArrowDown':
                    moveBackward = false;
                    isPlayerMoving = moveForward || moveLeft || moveRight;
                    break;
                case 'KeyA':
                case 'ArrowLeft':
                    moveLeft = false;
                    isPlayerMoving = moveForward || moveBackward || moveRight;
                    break;
                case 'KeyD':
                case 'ArrowRight':
                    moveRight = false;
                    isPlayerMoving = moveForward || moveBackward || moveLeft;
                    break;
                case 'ShiftLeft':
                case 'ShiftRight':
                    isRunning = false;
                    break;
            }
        }
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞–∂–∞—Ç–∏—è –∫–Ω–æ–ø–∫–∏ –º—ã—à–∏
        function onMouseDown(event) {
            if (gameOver || levelCompleted) return;
            
            if (event.button === 0) { // –õ–µ–≤–∞—è –∫–Ω–æ–ø–∫–∞ –º—ã—à–∏
                isShooting = true;
                shoot();
                
                // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è —Å—Ç—Ä–µ–ª—å–±–∞ –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏—Ö –æ—Ä—É–∂–∏–π
                if (weapons[currentWeapon - 1].automatic) {
                    touchShootId = setInterval(shoot, weapons[currentWeapon - 1].shootInterval);
                }
            }
        }
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç–ø—É—Å–∫–∞–Ω–∏—è –∫–Ω–æ–ø–∫–∏ –º—ã—à–∏
        function onMouseUp(event) {
            if (event.button === 0) {
                isShooting = false;
                if (touchShootId !== null) {
                    clearInterval(touchShootId);
                    touchShootId = null;
                }
            }
        }
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ —É–∫–∞–∑–∞—Ç–µ–ª—è –º—ã—à–∏
        function lockChangeAlert() {
            if (document.pointerLockElement === renderer.domElement) {
                document.addEventListener('mousemove', updateCamera, false);
            } else {
                document.removeEventListener('mousemove', updateCamera, false);
            }
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–∞–º–µ—Ä—ã –ø—Ä–∏ –¥–≤–∏–∂–µ–Ω–∏–∏ –º—ã—à–∏
        function updateCamera(event) {
            if (gameOver || levelCompleted) return;
            
            const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
            const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
            
            player.rotation.y -= movementX * 0.002;
            
            // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ–≥–æ –≤—Ä–∞—â–µ–Ω–∏—è –∫–∞–º–µ—Ä—ã
            camera.rotation.x -= movementY * 0.002;
            camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
        }
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞ –æ–∫–Ω–∞
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // –°–∏—Å—Ç–µ–º–∞ –∞–≤—Ç–æ–ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏—è
        function findTargetEnemy() {
            // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≤–∑–≥–ª—è–¥–∞
            const lookDirection = new THREE.Vector3();
            camera.getWorldDirection(lookDirection);
            
            let closestEnemy = null;
            let closestAngle = AUTO_AIM_ANGLE;
            
            for (const helper of enemyHelpers) {
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≤—Ä–∞–≥ –µ—â–µ –∂–∏–≤
                if (!helper.enemyRef || !scene.getObjectById(helper.enemyRef.id)) continue;
                
                // –í–µ–∫—Ç–æ—Ä –æ—Ç –∏–≥—Ä–æ–∫–∞ –∫ –≤—Ä–∞–≥—É
                const enemyDirection = new THREE.Vector3();
                enemyDirection.subVectors(helper.position, player.position).normalize();
                
                // –£–≥–æ–ª –º–µ–∂–¥—É –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º –≤–∑–≥–ª—è–¥–∞ –∏ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º –∫ –≤—Ä–∞–≥—É
                const angle = lookDirection.angleTo(enemyDirection);
                
                // –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ –≤—Ä–∞–≥–∞
                const distance = player.position.distanceTo(helper.position);
                
                // –ï—Å–ª–∏ –≤—Ä–∞–≥ –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö —É–≥–ª–∞ –∞–≤—Ç–æ–ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏—è –∏ –Ω–µ —Å–ª–∏—à–∫–æ–º –¥–∞–ª–µ–∫–æ
                if (angle < closestAngle && distance < AUTO_AIM_DISTANCE) {
                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–∏–¥–∏–º–æ—Å—Ç–∏ (–Ω–µ—Ç –ª–∏ —Å—Ç–µ–Ω –º–µ–∂–¥—É –∏–≥—Ä–æ–∫–æ–º –∏ –≤—Ä–∞–≥–æ–º)
                    raycaster.set(player.position, enemyDirection);
                    const intersects = raycaster.intersectObjects(walls);
                    
                    if (intersects.length === 0 || 
                        intersects[0].distance > distance) {
                        closestEnemy = helper;
                        closestAngle = angle;
                    }
                }
            }
            
            return closestEnemy;
        }
        
        // –°—Ç—Ä–µ–ª—å–±–∞
        function shoot() {
            if (reloading || ammo <= 0) {
                if (ammo <= 0) reload();
                return;
            }
            
            // –ù–∞–π—Ç–∏ —Ü–µ–ª—å –¥–ª—è –∞–≤—Ç–æ–ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏—è
            targetEnemy = findTargetEnemy();
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –ø—É–ª–∏
            const bulletGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
            
            // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—É–ª–∏ –ø–µ—Ä–µ–¥ –∏–≥—Ä–æ–∫–æ–º
            bullet.position.copy(player.position);
            bullet.position.y = camera.position.y;
            
            // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—É–ª–∏
            let direction = new THREE.Vector3();
            
            if (targetEnemy) {
                // –ï—Å–ª–∏ –µ—Å—Ç—å —Ü–µ–ª—å, —Å—Ç—Ä–µ–ª—è–µ–º –≤ –Ω–µ–µ
                direction.subVectors(targetEnemy.position, player.position).normalize();
                
                // –î–æ–±–∞–≤–ª—è–µ–º –Ω–µ–±–æ–ª—å—à–æ–π —Ä–∞–∑–±—Ä–æ—Å –¥–ª—è —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω–æ—Å—Ç–∏
                direction.x += (Math.random() - 0.5) * 0.02;
                direction.y += (Math.random() - 0.5) * 0.02;
                direction.z += (Math.random() - 0.5) * 0.02;
                direction.normalize();
                
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –º–∞—Ä–∫–µ—Ä –ø–æ–ø–∞–¥–∞–Ω–∏—è
                showHitMarker();
            } else {
                // –ò–Ω–∞—á–µ —Å—Ç—Ä–µ–ª—è–µ–º –≤ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏ –∫–∞–º–µ—Ä—ã
                camera.getWorldDirection(direction);
            }
            
            bullet.velocity = direction.multiplyScalar(1);
            
            // –£—Å—Ç–∞–Ω–æ–≤–∫–∞ —É—Ä–æ–Ω–∞ –ø—É–ª–∏ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –æ—Ä—É–∂–∏—è
            bullet.damage = weapons[currentWeapon - 1].damage;
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –ø—É–ª–∏ –Ω–∞ —Å—Ü–µ–Ω—É
            scene.add(bullet);
            bullets.push(bullet);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –≤—Å–ø—ã—à–∫–∏ –≤—ã—Å—Ç—Ä–µ–ª–∞
            createMuzzleFlash();
            
            // –£–º–µ–Ω—å—à–µ–Ω–∏–µ –ø–∞—Ç—Ä–æ–Ω–æ–≤
            ammo--;
            document.getElementById('ammo-count').textContent = ammo;
            
            // –ó–≤—É–∫–æ–≤–æ–π —ç—Ñ—Ñ–µ–∫—Ç (–≤ —Ä–µ–∞–ª—å–Ω–æ–º –ø—Ä–æ–µ–∫—Ç–µ –¥–æ–±–∞–≤—å—Ç–µ –∑–≤—É–∫)
            // playSound('shoot');
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –æ—Ç–¥–∞—á–∏
            if (!isMobile) {
                camera.rotation.x += 0.01;
                player.rotation.y += (Math.random() - 0.5) * 0.005;
            }
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –≤—Å–ø—ã—à–∫–∏ –≤—ã—Å—Ç—Ä–µ–ª–∞
        function createMuzzleFlash() {
            // –ü–æ–∑–∏—Ü–∏—è –≤—Å–ø—ã—à–∫–∏
            const muzzlePosition = new THREE.Vector3(0, 0, -1);
            muzzlePosition.applyQuaternion(camera.quaternion);
            muzzlePosition.add(camera.position);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —á–∞—Å—Ç–∏—Ü –¥–ª—è –≤—Å–ø—ã—à–∫–∏
            const particleCount = 20;
            const particleGeometry = new THREE.BufferGeometry();
            const particleMaterial = new THREE.PointsMaterial({
                color: 0xffff00,
                size: 0.1,
                transparent: true,
                opacity: 0.8
            });
            
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];
            
            for (let i = 0; i < particleCount; i++) {
                // –°–ª—É—á–∞–π–Ω–æ–µ –ø–æ–ª–æ–∂–µ–Ω–∏–µ –≤–æ–∫—Ä—É–≥ —Ç–æ—á–∫–∏ –≤—Å–ø—ã—à–∫–∏
                const x = muzzlePosition.x + (Math.random() - 0.5) * 0.2;
                const y = muzzlePosition.y + (Math.random() - 0.5) * 0.2;
                const z = muzzlePosition.z + (Math.random() - 0.5) * 0.2;
                
                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;
                
                // –°–ª—É—á–∞–π–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å
                velocities.push(new THREE.Vector3(
                    (Math.random() - 0.5) * 0.1,
                    (Math.random() - 0.5) * 0.1,
                    (Math.random() - 0.5) * 0.1
                ));
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã —á–∞—Å—Ç–∏—Ü –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
            particleSystems.push({
                particles: particles,
                velocities: velocities,
                life: 10 // –í—Ä–µ–º—è –∂–∏–∑–Ω–∏ —ç—Ñ—Ñ–µ–∫—Ç–∞ –≤ –∫–∞–¥—Ä–∞—Ö
            });
        }
        
        // –ü–æ–∫–∞–∑–∞—Ç—å –º–∞—Ä–∫–µ—Ä –ø–æ–ø–∞–¥–∞–Ω–∏—è
        function showHitMarker() {
            const hitMarker = document.getElementById('hit-marker');
            hitMarker.style.opacity = '1';
            
            setTimeout(() => {
                hitMarker.style.opacity = '0';
            }, 100);
        }
        
        // –ü–µ—Ä–µ–∑–∞—Ä—è–¥–∫–∞
        function reload() {
            const weapon = weapons[currentWeapon - 1];
            if (reloading || ammo === weapon.maxAmmo) return;
            
                        reloading = true;
            
            // –ü–æ–∫–∞–∑–∞—Ç—å –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –ø–µ—Ä–µ–∑–∞—Ä—è–¥–∫–∏
            document.getElementById('reload-indicator').style.display = 'block';
            
            setTimeout(() => {
                ammo = weapon.maxAmmo;
                document.getElementById('ammo-count').textContent = ammo;
                reloading = false;
                document.getElementById('reload-indicator').style.display = 'none';
            }, 2000);
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–ª–æ—Å—ã –∑–¥–æ—Ä–æ–≤—å—è
        function updateHealthBar() {
            const healthFill = document.getElementById('health-fill');
            healthFill.style.width = health + '%';
            
            // –ò–∑–º–µ–Ω–µ–Ω–∏–µ —Ü–≤–µ—Ç–∞ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –∑–¥–æ—Ä–æ–≤—å—è
            if (health > 60) {
                healthFill.style.backgroundColor = '#0f0';
            } else if (health > 30) {
                healthFill.style.backgroundColor = '#ff0';
            } else {
                healthFill.style.backgroundColor = '#f00';
            }
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –ø–æ–ø–∞–¥–∞–Ω–∏—è
        function createHitEffect(position) {
            // –°–æ–∑–¥–∞–Ω–∏–µ —á–∞—Å—Ç–∏—Ü –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∞ –ø–æ–ø–∞–¥–∞–Ω–∏—è
            const particleCount = 30;
            const particleGeometry = new THREE.BufferGeometry();
            const particleMaterial = new THREE.PointsMaterial({
                color: 0xff0000,
                size: 0.1,
                transparent: true,
                opacity: 0.8
            });
            
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];
            
            for (let i = 0; i < particleCount; i++) {
                // –ù–∞—á–∞–ª—å–Ω–æ–µ –ø–æ–ª–æ–∂–µ–Ω–∏–µ –≤ —Ç–æ—á–∫–µ –ø–æ–ø–∞–¥–∞–Ω–∏—è
                positions[i * 3] = position.x;
                positions[i * 3 + 1] = position.y;
                positions[i * 3 + 2] = position.z;
                
                // –°–ª—É—á–∞–π–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å –≤–æ –≤—Å–µ —Å—Ç–æ—Ä–æ–Ω—ã
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.2,
                    (Math.random() - 0.5) * 0.2,
                    (Math.random() - 0.5) * 0.2
                );
                velocity.normalize().multiplyScalar(0.1 + Math.random() * 0.1);
                velocities.push(velocity);
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã —á–∞—Å—Ç–∏—Ü –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
            particleSystems.push({
                particles: particles,
                velocities: velocities,
                life: 20 // –í—Ä–µ–º—è –∂–∏–∑–Ω–∏ —ç—Ñ—Ñ–µ–∫—Ç–∞ –≤ –∫–∞–¥—Ä–∞—Ö
            });
        }
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–ø–∞–¥–∞–Ω–∏—è –ø—É–ª–∏ –≤–æ –≤—Ä–∞–≥–∞
        function hitEnemy(enemy, bulletIndex) {
            const bulletDamage = bullets[bulletIndex].damage || 25;
            enemy.health -= bulletDamage;
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –ø–æ–ø–∞–¥–∞–Ω–∏—è
            createHitEffect(bullets[bulletIndex].position.clone());
            
            if (enemy.health <= 0) {
                // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ —É–Ω–∏—á—Ç–æ–∂–µ–Ω–∏—è
                createExplosion(enemy.position.clone());
                
                // –£–¥–∞–ª–µ–Ω–∏–µ –≤—Ä–∞–≥–∞ —Å–æ —Å—Ü–µ–Ω—ã
                scene.remove(enemy);
                enemies.splice(enemies.indexOf(enemy), 1);
                
                // –£–¥–∞–ª–µ–Ω–∏–µ —Ö–µ–ª–ø–µ—Ä–∞
                for (let i = 0; i < enemyHelpers.length; i++) {
                    if (enemyHelpers[i].enemyRef === enemy) {
                        scene.remove(enemyHelpers[i]);
                        enemyHelpers.splice(i, 1);
                        break;
                    }
                }
                
                // –£–≤–µ–ª–∏—á–µ–Ω–∏–µ —Å—á–µ—Ç–∞
                score += enemy.isBoss ? 500 : 100;
                document.getElementById('score').textContent = score;
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–µ–∫—É—â–µ–≥–æ –∑–∞–¥–∞–Ω–∏—è
                if (currentObjective && currentObjective.type === 'kill') {
                    // –ï—Å–ª–∏ –∑–∞–¥–∞–Ω–∏–µ –Ω–∞ —É–±–∏–π—Å—Ç–≤–æ –≤—Ä–∞–≥–æ–≤
                    if (currentObjective.count) {
                        currentObjective.currentCount = (currentObjective.currentCount || 0) + 1;
                        
                        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞ –∑–∞–¥–∞–Ω–∏—è
                        if (currentObjective.currentCount < currentObjective.count) {
                            document.getElementById('objective-indicator').textContent = 
                                `–ó–∞–¥–∞—á–∞: ${currentObjective.description} (${currentObjective.currentCount}/${currentObjective.count})`;
                        } else {
                            completeObjective();
                        }
                    }
                }
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —É–±–∏–π—Å—Ç–≤–æ –±–æ—Å—Å–∞
                if (enemy.isBoss) {
                    if (enemy.isFinalBoss) {
                        // –ü–æ–±–µ–¥–∞ –Ω–∞–¥ —Ñ–∏–Ω–∞–ª—å–Ω—ã–º –±–æ—Å—Å–æ–º
                        showVictory();
                    } else if (currentObjective && currentObjective.type === 'boss') {
                        completeObjective();
                    }
                }
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ —É—Ä–æ–≤–Ω—è
                if (enemies.length === 0 && bosses.length === 0) {
                    // –ï—Å–ª–∏ –Ω–µ—Ç –∑–∞–¥–∞–Ω–∏—è –Ω–∞ —É–±–∏–π—Å—Ç–≤–æ, –º–æ–∂–Ω–æ –∑–∞–≤–µ—Ä—à–∏—Ç—å —É—Ä–æ–≤–µ–Ω—å
                    if (!(currentObjective && currentObjective.type === 'kill')) {
                        levelComplete();
                    }
                }
                
                // –°–ª—É—á–∞–π–Ω—ã–π –¥—Ä–æ–ø –ø—Ä–µ–¥–º–µ—Ç–æ–≤
                const dropChance = enemy.isBoss ? 1.0 : 0.3;
                if (Math.random() < dropChance) {
                    const dropType = Math.random() < 0.5 ? 'health' : 'ammo';
                    createCollectible(enemy.position.x, 1, enemy.position.z, dropType);
                }
            }
            
            // –£–¥–∞–ª–µ–Ω–∏–µ –ø—É–ª–∏
            scene.remove(bullets[bulletIndex]);
            bullets.splice(bulletIndex, 1);
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –≤–∑—Ä—ã–≤–∞
        function createExplosion(position) {
            // –°–æ–∑–¥–∞–Ω–∏–µ —á–∞—Å—Ç–∏—Ü –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∞ –≤–∑—Ä—ã–≤–∞
            const particleCount = 100;
            const particleGeometry = new THREE.BufferGeometry();
            const particleMaterial = new THREE.PointsMaterial({
                color: 0xff5500,
                size: 0.2,
                transparent: true,
                opacity: 0.8
            });
            
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];
            const colors = [];
            
            for (let i = 0; i < particleCount; i++) {
                // –ù–∞—á–∞–ª—å–Ω–æ–µ –ø–æ–ª–æ–∂–µ–Ω–∏–µ –≤ —Ç–æ—á–∫–µ –≤–∑—Ä—ã–≤–∞
                positions[i * 3] = position.x;
                positions[i * 3 + 1] = position.y;
                positions[i * 3 + 2] = position.z;
                
                // –°–ª—É—á–∞–π–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å –≤–æ –≤—Å–µ —Å—Ç–æ—Ä–æ–Ω—ã
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2
                );
                velocity.normalize().multiplyScalar(0.1 + Math.random() * 0.2);
                velocities.push(velocity);
                
                // –°–ª—É—á–∞–π–Ω—ã–π —Ü–≤–µ—Ç –æ—Ç –∫—Ä–∞—Å–Ω–æ–≥–æ –¥–æ –∂–µ–ª—Ç–æ–≥–æ
                const color = new THREE.Color();
                color.setHSL(0.05 + Math.random() * 0.05, 1, 0.5 + Math.random() * 0.5);
                colors.push(color);
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã —á–∞—Å—Ç–∏—Ü –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
            particleSystems.push({
                particles: particles,
                velocities: velocities,
                colors: colors,
                life: 40 // –í—Ä–µ–º—è –∂–∏–∑–Ω–∏ —ç—Ñ—Ñ–µ–∫—Ç–∞ –≤ –∫–∞–¥—Ä–∞—Ö
            });
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —Ç–æ—á–µ—á–Ω–æ–≥–æ —Å–≤–µ—Ç–∞ –ø—Ä–∏ –≤–∑—Ä—ã–≤–µ
            const explosionLight = new THREE.PointLight(0xff5500, 2, 10);
            explosionLight.position.copy(position);
            scene.add(explosionLight);
            
            // –£–≥–∞—Å–∞–Ω–∏–µ —Å–≤–µ—Ç–∞
            setTimeout(() => {
                scene.remove(explosionLight);
            }, 500);
        }
        
        // –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ —ç–∫—Ä–∞–Ω–∞ –ø–æ–±–µ–¥—ã
        function showVictory() {
            const notification = document.getElementById('level-up');
            notification.querySelector('h2').textContent = "–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º!";
            notification.querySelector('p').textContent = "–í—ã –ø–æ–±–µ–¥–∏–ª–∏ –≤—Å–µ—Ö –±–æ—Å—Å–æ–≤ –∏ –ø—Ä–æ—à–ª–∏ –∏–≥—Ä—É!";
            notification.querySelector('#level-description').textContent = `–í–∞—à —Ñ–∏–Ω–∞–ª—å–Ω—ã–π —Å—á–µ—Ç: ${score}`;
            notification.querySelector('#next-level-button').textContent = "–ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ";
            notification.style.display = 'block';
            
            document.getElementById('next-level-button').addEventListener('click', function() {
                notification.style.display = 'none';
                level = 1;
                score = 0;
                health = 100;
                createLevel();
            }, { once: true });
        }
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–ø–∞–¥–∞–Ω–∏—è –ø—É–ª–∏ –≤ –∏–≥—Ä–æ–∫–∞
        function hitPlayer(bulletIndex) {
            health -= 10;
            updateHealthBar();
            
            // –≠—Ñ—Ñ–µ–∫—Ç —Ç—Ä—è—Å–∫–∏ –∫–∞–º–µ—Ä—ã –ø—Ä–∏ –ø–æ–ø–∞–¥–∞–Ω–∏–∏
            camera.rotation.z = (Math.random() - 0.5) * 0.05;
            setTimeout(() => {
                camera.rotation.z = 0;
            }, 300);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –ø–æ–ø–∞–¥–∞–Ω–∏—è
            createHitEffect(enemyBullets[bulletIndex].position.clone());
            
            // –£–¥–∞–ª–µ–Ω–∏–µ –ø—É–ª–∏
            scene.remove(enemyBullets[bulletIndex]);
            enemyBullets.splice(bulletIndex, 1);
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∫–æ–Ω–µ—Ü –∏–≥—Ä—ã
            if (health <= 0) {
                endGame();
            }
        }
        
        // –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —É—Ä–æ–≤–Ω—è
        function levelComplete() {
            levelCompleted = true;
            
            const levelUp = document.getElementById('level-up');
            const newLevelSpan = document.getElementById('new-level');
            const levelDescription = document.getElementById('level-description');
            
            newLevelSpan.textContent = level + 1;
            
            // –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –æ–ø–∏—Å–∞–Ω–∏—è —Å–ª–µ–¥—É—é—â–µ–≥–æ —É—Ä–æ–≤–Ω—è
            if (level < LEVELS.length) {
                levelDescription.textContent = LEVELS[level].description;
            } else {
                levelDescription.textContent = "–°—Ä–∞–∂–∞–π—Ç–µ—Å—å —Å –±–æ–ª–µ–µ —Å–∏–ª—å–Ω—ã–º–∏ –≤—Ä–∞–≥–∞–º–∏ –≤ –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω–æ-—Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —É—Ä–æ–≤–Ω—è—Ö!";
            }
            
            levelUp.style.display = 'block';
            
            document.getElementById('next-level-button').addEventListener('click', function() {
                level++;
                levelUp.style.display = 'none';
                levelCompleted = false;
                createLevel();
            }, { once: true });
        }
        
        // –ö–æ–Ω–µ—Ü –∏–≥—Ä—ã
        function endGame() {
            gameOver = true;
            document.getElementById('final-score').textContent = score;
            document.getElementById('game-over').style.display = 'block';
            
            if (!isMobile) {
                document.exitPointerLock();
            }
            
            document.getElementById('restart-button').addEventListener('click', function() {
                document.getElementById('game-over').style.display = 'none';
                gameOver = false;
                health = 100;
                score = 0;
                level = 1;
                createLevel();
            }, { once: true });
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–∏—Å—Ç–µ–º —á–∞—Å—Ç–∏—Ü
        function updateParticleSystems() {
            for (let i = particleSystems.length - 1; i >= 0; i--) {
                const system = particleSystems[i];
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–π —á–∞—Å—Ç–∏—Ü
                const positions = system.particles.geometry.attributes.position.array;
                
                for (let j = 0; j < positions.length / 3; j++) {
                    positions[j * 3] += system.velocities[j].x;
                    positions[j * 3 + 1] += system.velocities[j].y;
                    positions[j * 3 + 2] += system.velocities[j].z;
                    
                    // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏–∏ –¥–ª—è –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö —ç—Ñ—Ñ–µ–∫—Ç–æ–≤
                    system.velocities[j].y -= 0.001;
                }
                
                system.particles.geometry.attributes.position.needsUpdate = true;
                
                // –£–º–µ–Ω—å—à–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏
                system.life--;
                
                // –£–º–µ–Ω—å—à–µ–Ω–∏–µ –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏ —Å–æ –≤—Ä–µ–º–µ–Ω–µ–º
                system.particles.material.opacity = system.life / 40;
                
                // –£–¥–∞–ª–µ–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã –ø–æ—Å–ª–µ –æ–∫–æ–Ω—á–∞–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏ –∂–∏–∑–Ω–∏
                if (system.life <= 0) {
                    scene.remove(system.particles);
                    particleSystems.splice(i, 1);
                }
            }
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ–ª–ª–µ–∫—Ç–∏–±–ª–æ–≤
        function updateCollectibles() {
            for (let i = collectibles.length - 1; i >= 0; i--) {
                const collectible = collectibles[i];
                
                // –í—Ä–∞—â–µ–Ω–∏–µ –∫–æ–ª–ª–µ–∫—Ç–∏–±–ª–∞
                collectible.rotation.y += collectible.rotationSpeed;
                
                // –ü–æ–¥–ø—Ä—ã–≥–∏–≤–∞–Ω–∏–µ –∫–æ–ª–ª–µ–∫—Ç–∏–±–ª–∞
                collectible.floatProgress += collectible.floatDirection * collectible.floatSpeed;
                
                // –ò–∑–º–µ–Ω–µ–Ω–∏–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –¥–≤–∏–∂–µ–Ω–∏—è –ø—Ä–∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–∏ –≥—Ä–∞–Ω–∏—Ü
                if (Math.abs(collectible.floatProgress) >= collectible.floatHeight) {
                    collectible.floatDirection *= -1;
                }
                
                // –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ Y
                collectible.position.y = collectible.originalY + collectible.floatProgress;
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–ª–∏–∑–∏–∏ —Å –∏–≥—Ä–æ–∫–æ–º
                const collectibleBox = new THREE.Box3().setFromObject(collectible);
                const playerBox = new THREE.Box3();
                
                playerBox.min.set(
                    player.position.x - 0.5,
                    player.position.y - (isCrouching ? 0.5 : 1),
                    player.position.z - 0.5
                );
                playerBox.max.set(
                    player.position.x + 0.5,
                    player.position.y + (isCrouching ? 0.5 : 1),
                    player.position.z + 0.5
                );
                
                if (collectibleBox.intersectsBox(playerBox)) {
                    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–¥–±–æ—Ä–∞ –∫–æ–ª–ª–µ–∫—Ç–∏–±–ª–∞
                    collectItem(collectible);
                    
                    // –£–¥–∞–ª–µ–Ω–∏–µ –∫–æ–ª–ª–µ–∫—Ç–∏–±–ª–∞ —Å–æ —Å—Ü–µ–Ω—ã
                    scene.remove(collectible);
                    collectibles.splice(i, 1);
                }
            }
        }
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–¥–±–æ—Ä–∞ –∫–æ–ª–ª–µ–∫—Ç–∏–±–ª–∞
        function collectItem(collectible) {
            switch (collectible.collectibleType) {
                case 'key':
                    hasCollectibleKey = true;
                    showItemPickupNotification("–ü–æ–ª—É—á–µ–Ω –∫–ª—é—á!");
                    // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∫–ª—é—á–∞
                    createCollectEffect(collectible.position.clone(), 0xffcc00);
                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ –∑–∞–¥–∞–Ω–∏—è
                    if (currentObjective && currentObjective.type === 'key') {
                        completeObjective();
                    }
                    break;
                case 'health':
                    health = Math.min(health + 25, 100);
                    updateHealthBar();
                    showItemPickupNotification("–ó–¥–æ—Ä–æ–≤—å–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ");
                    // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∑–¥–æ—Ä–æ–≤—å—è
                    createCollectEffect(collectible.position.clone(), 0x00ff00);
                    break;
                case 'ammo':
                    // –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–∞—Ç—Ä–æ–Ω–æ–≤ –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ –æ—Ä—É–∂–∏—è
                    weapons[currentWeapon - 1].ammo = weapons[currentWeapon - 1].maxAmmo;
                    ammo = weapons[currentWeapon - 1].ammo;
                    document.getElementById('ammo-count').textContent = ammo;
                    showItemPickupNotification("–ü–∞—Ç—Ä–æ–Ω—ã –ø–æ–ø–æ–ª–Ω–µ–Ω—ã");
                    // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø–∞—Ç—Ä–æ–Ω–æ–≤
                    createCollectEffect(collectible.position.clone(), 0xffff00);
                    break;
                case 'weapon':
                    // –ü–æ–ª—É—á–µ–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –æ—Ä—É–∂–∏—è
                    const weaponId = collectible.weaponId || 2;
                    switchWeapon(weaponId);
                    showItemPickupNotification(`–ü–æ–ª—É—á–µ–Ω–æ: ${weapons[weaponId - 1].name}`);
                    // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –æ—Ä—É–∂–∏—è
                    createCollectEffect(collectible.position.clone(), 0xff7700);
                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ –∑–∞–¥–∞–Ω–∏—è
                    if (currentObjective && currentObjective.type === 'weapon') {
                        completeObjective();
                    }
                    break;
                case 'artifact':
                    score += 100;
                    document.getElementById('score').textContent = score;
                    showItemPickupNotification("–ê—Ä—Ç–µ—Ñ–∞–∫—Ç –Ω–∞–π–¥–µ–Ω! +100 –æ—á–∫–æ–≤");
                    // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∞—Ä—Ç–µ—Ñ–∞–∫—Ç–∞
                    createCollectEffect(collectible.position.clone(), 0x00ffff);
                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ –∑–∞–¥–∞–Ω–∏—è
                    if (currentObjective && currentObjective.type === 'collect') {
                        currentObjective.currentCount = (currentObjective.currentCount || 0) + 1;
                        
                        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞ –∑–∞–¥–∞–Ω–∏—è
                        if (currentObjective.currentCount < currentObjective.count) {
                            document.getElementById('objective-indicator').textContent = 
                                `–ó–∞–¥–∞—á–∞: ${currentObjective.description} (${currentObjective.currentCount}/${currentObjective.count})`;
                        } else {
                            completeObjective();
                        }
                    }
                    break;
                default:
                    score += 50;
                    document.getElementById('score').textContent = score;
                    showItemPickupNotification("–ü—Ä–µ–¥–º–µ—Ç —Å–æ–±—Ä–∞–Ω");
                    // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –æ—á–∫–æ–≤
                    createCollectEffect(collectible.position.clone(), 0x00ffff);
            }
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ —Å–±–æ—Ä–∞ –ø—Ä–µ–¥–º–µ—Ç–∞
        function createCollectEffect(position, color) {
            // –°–æ–∑–¥–∞–Ω–∏–µ —á–∞—Å—Ç–∏—Ü –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∞ —Å–±–æ—Ä–∞
            const particleCount = 30;
            const particleGeometry = new THREE.BufferGeometry();
            const particleMaterial = new THREE.PointsMaterial({
                color: color,
                size: 0.2,
                transparent: true,
                opacity: 0.8
            });
            
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];
            
            for (let i = 0; i < particleCount; i++) {
                // –ù–∞—á–∞–ª—å–Ω–æ–µ –ø–æ–ª–æ–∂–µ–Ω–∏–µ –≤ —Ç–æ—á–∫–µ —Å–±–æ—Ä–∞
                positions[i * 3] = position.x;
                positions[i * 3 + 1] = position.y;
                positions[i * 3 + 2] = position.z;
                
                // –°–ª—É—á–∞–π–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å –≤–≤–µ—Ä—Ö –∏ –≤ —Å—Ç–æ—Ä–æ–Ω—ã
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.1,
                    Math.random() * 0.2,
                    (Math.random() - 0.5) * 0.1
                );
                velocities.push(velocity);
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã —á–∞—Å—Ç–∏—Ü –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
            particleSystems.push({
                particles: particles,
                velocities: velocities,
                life: 30 // –í—Ä–µ–º—è –∂–∏–∑–Ω–∏ —ç—Ñ—Ñ–µ–∫—Ç–∞ –≤ –∫–∞–¥—Ä–∞—Ö
            });
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–µ–∫—Ä–µ—Ç–Ω—ã—Ö –¥–≤–µ—Ä–µ–π
        function updateSecretDoors() {
            if (hasCollectibleKey) {
                for (const door of secretDoors) {
                    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∞–Ω–∏–º–∞—Ü–∏–∏ –æ—Ç–∫—Ä—ã—Ç–∏—è, –µ—Å–ª–∏ –æ–Ω–∞ –µ—Å—Ç—å
                    if (door.animation && door.animation.progress < 1) {
                        door.animation.progress += door.animation.speed;
                        if (door.animation.progress > 1) door.animation.progress = 1;
                        
                        const newY = door.animation.startY + (door.animation.targetY - door.animation.startY) * door.animation.progress;
                        door.position.y = newY;
                    }
                }
            }
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–≤–∏–∂—É—â–∏—Ö—Å—è –ø–ª–∞—Ç—Ñ–æ—Ä–º
        function updatePlatforms() {
            for (const platform of platforms) {
                if (platform.isMoving) {
                    platform.movementProgress += platform.movementDirection * platform.movementSpeed;
                    
                    if (Math.abs(platform.movementProgress) >= 1) {
                        platform.movementDirection *= -1;
                    }
                    
                    const newX = platform.startPosition.x + platform.rangeX * platform.movementProgress;
                    const newY = platform.startPosition.y + platform.rangeY * platform.movementProgress;
                    const newZ = platform.startPosition.z + platform.rangeZ * platform.movementProgress;
                    
                    const deltaX = newX - platform.position.x;
                    const deltaY = newY - platform.position.y;
                    const deltaZ = newZ - platform.position.z;
                    
                    platform.position.set(newX, newY, newZ);
                    
                    // –ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–∞ –≤–º–µ—Å—Ç–µ —Å –ø–ª–∞—Ç—Ñ–æ—Ä–º–æ–π, –µ—Å–ª–∏ –æ–Ω –Ω–∞ –Ω–µ–π
                    const playerBox = new THREE.Box3();
                    playerBox.min.set(
                        player.position.x - 0.5,
                        player.position.y - 0.1,
                        player.position.z - 0.5
                    );
                    playerBox.max.set(
                        player.position.x + 0.5,
                        player.position.y,
                        player.position.z + 0.5
                    );
                    
                    const platformBox = new THREE.Box3().setFromObject(platform);
                    platformBox.max.y += 0.1; // –ß—É—Ç—å —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º –≤—ã—Å–æ—Ç—É –¥–ª—è –ª—É—á—à–µ–π –ø—Ä–æ–≤–µ—Ä–∫–∏
                    
                    if (playerBox.intersectsBox(platformBox) && player.position.y >= platform.position.y) {
                        player.position.x += deltaX;
                        player.position.y += deltaY;
                        player.position.z += deltaZ;
                    }
                }
                
                if (platform.isRotating) {
                    platform.rotation.y += platform.rotationSpeed;
                }
            }
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤—Ä–∞—â–∞—é—â–∏—Ö—Å—è –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π
            for (const wall of walls) {
                if (wall.isRotating) {
                    wall.rotation.y += wall.rotationSpeed;
                }
            }
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—ã—Ö —Ç–æ—á–µ–∫
        function updateCheckpoints() {
            for (let i = 0; i < scene.children.length; i++) {
                const object = scene.children[i];
                
                if (object.isCheckpoint) {
                    object.rotation.y += 0.01;
                    
                    // –ü—Ä–æ–≤–µ—Ä–∫–∞, –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ –∏–≥—Ä–æ–∫ –Ω–∞ —ç—Ç–æ–π –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω–æ–π —Ç–æ—á–∫–µ
                    const distance = player.position.distanceTo(object.position);
                    
                    if (distance < 1.5 && currentCheckpoint !== object) {
                        currentCheckpoint = object;
                        
                        // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω–æ–π —Ç–æ—á–∫–∏
                        createCheckpointEffect(object.position.clone());
                        
                        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—á—ë—Ç–∞
                        score += 25;
                        document.getElementById('score').textContent = score;
                        
                        // –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
                        showItemPickupNotification("–ö–æ–Ω—Ç—Ä–æ–ª—å–Ω–∞—è —Ç–æ—á–∫–∞ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞");
                    }
                }
            }
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω–æ–π —Ç–æ—á–∫–∏
        function createCheckpointEffect(position) {
            // –°–æ–∑–¥–∞–Ω–∏–µ —á–∞—Å—Ç–∏—Ü –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∞ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏
            const particleCount = 50;
            const particleGeometry = new THREE.BufferGeometry();
            const particleMaterial = new THREE.PointsMaterial({
                color: 0x00ffff,
                size: 0.2,
                transparent: true,
                opacity: 0.8
            });
            
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];
            
            for (let i = 0; i < particleCount; i++) {
                // –ù–∞—á–∞–ª—å–Ω–æ–µ –ø–æ–ª–æ–∂–µ–Ω–∏–µ –≤ —Ç–æ—á–∫–µ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏
                positions[i * 3] = position.x;
                positions[i * 3 + 1] = position.y;
                positions[i * 3 + 2] = position.z;
                
                // –°–ª—É—á–∞–π–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å –≤–æ –≤—Å–µ —Å—Ç–æ—Ä–æ–Ω—ã
                const angle = (i / particleCount) * Math.PI * 2;
                const speed = 0.1;
                
                velocities.push(new THREE.Vector3(
                    Math.cos(angle) * speed,
                    0.05 + Math.random() * 0.1,
                    Math.sin(angle) * speed
                ));
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã —á–∞—Å—Ç–∏—Ü –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
            particleSystems.push({
                particles: particles,
                velocities: velocities,
                life: 40 // –í—Ä–µ–º—è –∂–∏–∑–Ω–∏ —ç—Ñ—Ñ–µ–∫—Ç–∞ –≤ –∫–∞–¥—Ä–∞—Ö
            });
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –±–æ—Å—Å–æ–≤
        function updateBosses() {
            for (let i = 0; i < bosses.length; i++) {
                const boss = bosses[i];
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∞–Ω–∏–º–∞—Ü–∏–π –±–æ—Å—Å–∞
                if (boss.animations) {
                    // –ü–æ–∫–∞—á–∏–≤–∞–Ω–∏–µ
                    if (boss.animations.bobbing) {
                        const bobbing = boss.animations.bobbing;
                        boss.position.y += Math.sin(Date.now() * 0.001 * bobbing.frequency + bobbing.offset) * bobbing.amplitude * 0.01;
                    }
                    
                    // –í—Ä–∞—â–µ–Ω–∏–µ
                    if (boss.animations.rotation) {
                        const rotation = boss.animations.rotation;
                        boss.rotation[rotation.axis.x ? 'x' : rotation.axis.y ? 'y' : 'z'] += rotation.speed;
                    }
                }
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ª–æ–≥–∏–∫–∏ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ñ–∞–∑—ã –∞—Ç–∞–∫–∏
                if (boss.isFinalBoss) {
                    boss.phaseTimer += deltaTime * 1000;
                    
                    // –°–º–µ–Ω–∞ —Ñ–∞–∑—ã –∫–∞–∂–¥—ã–µ 10 —Å–µ–∫—É–Ω–¥
                    if (boss.phaseTimer > 10000) {
                        boss.phaseTimer = 0;
                        boss.attackPhase = (boss.attackPhase + 1) % 3;
                        
                        switch(boss.attackPhase) {
                            case 0: // –û–±—ã—á–Ω–∞—è —Ñ–∞–∑–∞
                                boss.attackMode = 'normal';
                                break;
                            case 1: // –ó–∞—â–∏—Ç–Ω–∞—è —Ñ–∞–∑–∞
                                boss.attackMode = 'shield';
                                // –°–æ–∑–¥–∞–Ω–∏–µ –∑–∞—â–∏—Ç–Ω–æ–≥–æ —â–∏—Ç–∞
                                createBossShield(boss);
                                break;
                            case 2: // –§–∞–∑–∞ —è—Ä–æ—Å—Ç–∏
                                boss.attackMode = 'rage';
                                boss.shootInterval = 500; // –ë–æ–ª–µ–µ —á–∞—Å—Ç—ã–µ –≤—ã—Å—Ç—Ä–µ–ª—ã
                                break;
                        }
                    }
                }
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∞—Ç–∞–∫ –±–æ—Å—Å–∞
                const now = Date.now();
                const direction = new THREE.Vector3();
                direction.subVectors(player.position, boss.position).normalize();
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–∏–¥–∏–º–æ—Å—Ç–∏ –∏–≥—Ä–æ–∫–∞
                raycaster.set(boss.position, direction);
                const intersects = raycaster.intersectObjects(walls);
                
                // –ï—Å–ª–∏ –Ω–µ—Ç –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π –º–µ–∂–¥—É –±–æ—Å—Å–æ–º –∏ –∏–≥—Ä–æ–∫–æ–º –∏–ª–∏ –±–æ—Å—Å –≤ —Ä–µ–∂–∏–º–µ —è—Ä–æ—Å—Ç–∏
                if (intersects.length === 0 || 
                    intersects[0].distance > boss.position.distanceTo(player.position) ||
                    boss.attackMode === 'rage') {
                    
                    // –î–≤–∏–∂–µ–Ω–∏–µ –∫ –∏–≥—Ä–æ–∫—É
                    if (boss.attackMode !== 'shield') {
                        const newPosition = boss.position.clone();
                        newPosition.x += direction.x * boss.speed;
                        newPosition.z += direction.z * boss.speed;
                        
                        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–ª–∏–∑–∏–π
                        let canMove = true;
                        
                        for (const wall of walls) {
                            const bossBox = new THREE.Box3().setFromObject(boss);
                            bossBox.min.set(
                                newPosition.x - (boss.isFinalBoss ? 2.5 : 1.5),
                                newPosition.y,
                                newPosition.z - (boss.isFinalBoss ? 2.5 : 1.5)
                            );
                            bossBox.max.set(
                                newPosition.x + (boss.isFinalBoss ? 2.5 : 1.5),
                                newPosition.y + (boss.isFinalBoss ? 5 : 3),
                                newPosition.z + (boss.isFinalBoss ? 2.5 : 1.5)
                            );
                            
                                                        const wallBox = new THREE.Box3().setFromObject(wall);
                            
                            if (bossBox.intersectsBox(wallBox)) {
                                canMove = false;
                                break;
                            }
                        }
                        
                        // –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –¥–≤–∏–∂–µ–Ω–∏—è, –µ—Å–ª–∏ –Ω–µ—Ç –∫–æ–ª–ª–∏–∑–∏–π
                        if (canMove) {
                            boss.position.copy(newPosition);
                        }
                    }
                    
                    // –ü–æ–≤–æ—Ä–æ—Ç –±–æ—Å—Å–∞ –∫ –∏–≥—Ä–æ–∫—É
                    boss.lookAt(player.position);
                    
                    // –ê—Ç–∞–∫–∏ –±–æ—Å—Å–∞
                    if (now - boss.lastShot > boss.shootInterval) {
                        // –†–∞–∑–Ω—ã–µ –∞—Ç–∞–∫–∏ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ä–µ–∂–∏–º–∞
                        if (boss.attackMode === 'rage') {
                            // –ó–∞–ª–ø –∏–∑ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –≤—ã—Å—Ç—Ä–µ–ª–æ–≤
                            for (let j = 0; j < 3; j++) {
                                setTimeout(() => {
                                    if (boss.parent) bossShoot(boss, 'rage');
                                }, j * 200);
                            }
                        } else if (boss.attackMode === 'shield') {
                            // –ö—Ä—É–≥–æ–≤–∞—è –∞—Ç–∞–∫–∞
                            for (let j = 0; j < 8; j++) {
                                const angle = (j / 8) * Math.PI * 2;
                                const direction = new THREE.Vector3(
                                    Math.cos(angle),
                                    0,
                                    Math.sin(angle)
                                );
                                setTimeout(() => {
                                    if (boss.parent) bossShoot(boss, 'shield', direction);
                                }, j * 100);
                            }
                        } else {
                            // –û–±—ã—á–Ω–∞—è –∞—Ç–∞–∫–∞
                            bossShoot(boss, 'normal');
                        }
                        
                        boss.lastShot = now;
                    }
                }
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ö–µ–ª–ø–µ—Ä–∞
                for (const helper of enemyHelpers) {
                    if (helper.enemyRef === boss) {
                        helper.position.copy(boss.position);
                        if (boss.isFinalBoss) {
                            helper.position.y = 3;
                        } else {
                            helper.position.y = 1.5;
                        }
                        break;
                    }
                }
            }
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —â–∏—Ç–∞ –±–æ—Å—Å–∞
        function createBossShield(boss) {
            const shieldGeometry = new THREE.SphereGeometry(4, 32, 32);
            const shieldMaterial = new THREE.MeshBasicMaterial({
                color: 0x4444ff,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            
            const shield = new THREE.Mesh(shieldGeometry, shieldMaterial);
            shield.position.y = boss.isFinalBoss ? 3 : 1.5;
            boss.add(shield);
            
            // –©–∏—Ç –≤—Ä–∞—â–∞–µ—Ç—Å—è
            shield.isRotating = true;
            shield.rotationSpeed = 0.02;
            
            // –©–∏—Ç –∏—Å—á–µ–∑–∞–µ—Ç —á–µ—Ä–µ–∑ –Ω–µ–∫–æ—Ç–æ—Ä–æ–µ –≤—Ä–µ–º—è
            setTimeout(() => {
                if (boss.parent) boss.remove(shield);
            }, 5000);
            
            return shield;
        }
        
        // –í—ã—Å—Ç—Ä–µ–ª –±–æ—Å—Å–∞
        function bossShoot(boss, mode, customDirection) {
            // –°–æ–∑–¥–∞–Ω–∏–µ –ø—É–ª–∏
            const bulletGeometry = new THREE.SphereGeometry(0.2, 8, 8);
            let bulletMaterial;
            
            switch(mode) {
                case 'rage':
                    bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                    break;
                case 'shield':
                    bulletMaterial = new THREE.MeshBasicMaterial({ color: 0x4444ff });
                    break;
                default:
                    bulletMaterial = new THREE.MeshBasicMaterial({ 
                        color: boss.isFinalBoss ? 0xff00ff : 0xff0000 
                    });
            }
            
            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
            
            // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—É–ª–∏
            bullet.position.copy(boss.position);
            bullet.position.y = boss.isFinalBoss ? 3 : 1.5;
            
            // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—É–ª–∏
            let direction;
            
            if (customDirection) {
                direction = customDirection;
            } else {
                direction = new THREE.Vector3();
                direction.subVectors(player.position, boss.position).normalize();
                
                // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ä–∞–∑–±—Ä–æ—Å–∞ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ä–µ–∂–∏–º–∞
                const spread = mode === 'rage' ? 0.2 : 0.1;
                direction.x += (Math.random() - 0.5) * spread;
                direction.y += (Math.random() - 0.5) * spread;
                direction.z += (Math.random() - 0.5) * spread;
                direction.normalize();
            }
            
            // –°–∫–æ—Ä–æ—Å—Ç—å –ø—É–ª–∏ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ä–µ–∂–∏–º–∞
            const speed = mode === 'rage' ? 1.2 : 0.8;
            bullet.velocity = direction.multiplyScalar(speed);
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —É—Ä–æ–Ω–∞ –ø—É–ª–µ
            bullet.damage = mode === 'rage' ? 20 : 10;
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –≤—Å–ø—ã—à–∫–∏ –≤—ã—Å—Ç—Ä–µ–ª–∞
            createMuzzleFlash();
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –ø—É–ª–∏ –Ω–∞ —Å—Ü–µ–Ω—É
            scene.add(bullet);
            enemyBullets.push(bullet);
            
            return bullet;
        }
        
        // –ì–ª–∞–≤–Ω—ã–π –∏–≥—Ä–æ–≤–æ–π —Ü–∏–∫–ª
        function animate() {
            requestAnimationFrame(animate);
            
            // –†–∞—Å—á–µ—Ç –≤—Ä–µ–º–µ–Ω–∏ –º–µ–∂–¥—É –∫–∞–¥—Ä–∞–º–∏ –¥–ª—è –ø–ª–∞–≤–Ω–æ–≥–æ –¥–≤–∏–∂–µ–Ω–∏—è
            deltaTime = clock.getDelta();
            
            if (!gameOver && !levelCompleted) {
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –∏–≥—Ä–æ–∫–∞
                updatePlayer();
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤—Ä–∞–≥–æ–≤
                updateEnemies();
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –±–æ—Å—Å–æ–≤
                updateBosses();
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—É–ª—å
                updateBullets();
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—É–ª—å –≤—Ä–∞–≥–æ–≤
                updateEnemyBullets();
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–∏—Å—Ç–µ–º —á–∞—Å—Ç–∏—Ü
                updateParticleSystems();
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ–ª–ª–µ–∫—Ç–∏–±–ª–æ–≤
                updateCollectibles();
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–µ–∫—Ä–µ—Ç–Ω—ã—Ö –¥–≤–µ—Ä–µ–π
                updateSecretDoors();
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–≤–∏–∂—É—â–∏—Ö—Å—è –ø–ª–∞—Ç—Ñ–æ—Ä–º
                updatePlatforms();
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—ã—Ö —Ç–æ—á–µ–∫
                updateCheckpoints();
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∞–Ω–∏–º–∞—Ü–∏–∏ –ø–æ–∫–∞—á–∏–≤–∞–Ω–∏—è –ø—Ä–∏ —Ö–æ–¥—å–±–µ
                updateHeadbob();
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–∞–º–µ—Ä—ã –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤
                if (isMobile) {
                    updateMobileCamera();
                }
                
                // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è —Å—Ç—Ä–µ–ª—å–±–∞ –ø—Ä–∏ –∑–∞–∂–∞—Ç–æ–π –∫–Ω–æ–ø–∫–µ
                if (isShooting && !reloading && ammo > 0 && weapons[currentWeapon - 1].automatic) {
                    // –î–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –æ—Ä—É–∂–∏—è –≤—ã—Å—Ç—Ä–µ–ª—ã —É–∂–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é—Ç—Å—è —á–µ—Ä–µ–∑ setInterval
                }
            }
            
            // –†–µ–Ω–¥–µ—Ä–∏–Ω–≥ —Å—Ü–µ–Ω—ã
            renderer.render(scene, camera);
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∫–∞—á–∏–≤–∞–Ω–∏—è –∫–∞–º–µ—Ä—ã –ø—Ä–∏ —Ö–æ–¥—å–±–µ
        function updateHeadbob() {
            if (isPlayerMoving && canJump) {
                headbobTimer += deltaTime * headbobSpeed * (isRunning ? 1.5 : 1.0);
                const bobOffset = Math.sin(headbobTimer) * headbobAmount;
                camera.position.y = bobOffset;
            } else {
                camera.position.y = 0;
            }
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–∞–º–µ—Ä—ã –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤
        function updateMobileCamera() {
            if (lookJoystickPosition.x !== 0 || lookJoystickPosition.y !== 0) {
                player.rotation.y -= lookJoystickPosition.x * 0.1;
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x - lookJoystickPosition.y * 0.05));
            }
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –∏–≥—Ä–æ–∫–∞
        function updatePlayer() {
            // –ì—Ä–∞–≤–∏—Ç–∞—Ü–∏—è
            player.velocity.y -= GRAVITY;
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è —Å –ø–æ–ª–æ–º
            if (player.position.y < (isCrouching ? 1 : 2)) {
                player.position.y = isCrouching ? 1 : 2;
                player.velocity.y = 0;
                canJump = true;
            }
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –ø–æ –≤–µ—Ä—Ç–∏–∫–∞–ª–∏
            player.position.y += player.velocity.y;
            
            // –†–∞—Å—á–µ—Ç –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –¥–≤–∏–∂–µ–Ω–∏—è
            const speed = isRunning ? RUNNING_SPEED : PLAYER_SPEED;
            
            if (isMobile) {
                // –î–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤ –∏—Å–ø–æ–ª—å–∑—É–µ–º –∑–Ω–∞—á–µ–Ω–∏—è –¥–∂–æ–π—Å—Ç–∏–∫–∞
                player.direction.z = -joystickPosition.y; // –ò–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –æ—Å—å Y –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ –¥–≤–∏–∂–µ–Ω–∏—è
                player.direction.x = joystickPosition.x;
                isPlayerMoving = Math.abs(joystickPosition.x) > 0.1 || Math.abs(joystickPosition.y) > 0.1;
            } else {
                // –î–ª—è –ü–ö –∏—Å–ø–æ–ª—å–∑—É–µ–º –∫–ª–∞–≤–∏—à–∏
                player.direction.z = Number(moveForward) - Number(moveBackward);
                player.direction.x = Number(moveRight) - Number(moveLeft);
            }
            
            player.direction.normalize();
            
            // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–∏ —Å –ø–æ–≤–æ—Ä–æ—Ç–æ–º –∏–≥—Ä–æ–∫–∞
            if (player.direction.z !== 0) {
                player.velocity.z = player.direction.z * speed;
            }
            if (player.direction.x !== 0) {
                player.velocity.x = player.direction.x * speed;
            }
            
            // –ï—Å–ª–∏ –Ω–µ—Ç –¥–≤–∏–∂–µ–Ω–∏—è, –ø–æ—Å—Ç–µ–ø–µ–Ω–Ω–æ –∑–∞–º–µ–¥–ª—è–µ–º
            if (player.direction.z === 0) {
                player.velocity.z *= 0.9;
            }
            if (player.direction.x === 0) {
                player.velocity.x *= 0.9;
            }
            
            // –í—Ä–∞—â–µ–Ω–∏–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–∏ —Å –ø–æ–≤–æ—Ä–æ—Ç–æ–º –∏–≥—Ä–æ–∫–∞
            const rotatedVelocity = player.velocity.clone();
            rotatedVelocity.applyAxisAngle(new THREE.Vector3(0, 1, 0), player.rotation.y);
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–ª–∏–∑–∏–π –ø–µ—Ä–µ–¥ –¥–≤–∏–∂–µ–Ω–∏–µ–º
            const nextPosition = player.position.clone();
            nextPosition.x += rotatedVelocity.x;
            nextPosition.z += rotatedVelocity.z;
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π —Å–æ —Å—Ç–µ–Ω–∞–º–∏
            let canMove = true;
            
            for (const wall of walls) {
                const playerBox = new THREE.Box3().setFromObject(
                    new THREE.Mesh(
                        new THREE.BoxGeometry(1, isCrouching ? 1 : 2, 1),
                        new THREE.MeshBasicMaterial()
                    )
                );
                playerBox.min.set(
                    nextPosition.x - 0.5,
                    nextPosition.y - (isCrouching ? 0.5 : 1),
                    nextPosition.z - 0.5
                );
                playerBox.max.set(
                    nextPosition.x + 0.5,
                    nextPosition.y + (isCrouching ? 0.5 : 1),
                    nextPosition.z + 0.5
                );
                
                const wallBox = new THREE.Box3().setFromObject(wall);
                
                if (playerBox.intersectsBox(wallBox)) {
                    canMove = false;
                    break;
                }
            }
            
            // –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –¥–≤–∏–∂–µ–Ω–∏—è, –µ—Å–ª–∏ –Ω–µ—Ç –∫–æ–ª–ª–∏–∑–∏–π
            if (canMove) {
                player.position.x += rotatedVelocity.x;
                player.position.z += rotatedVelocity.z;
            }
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–∞–¥–µ–Ω–∏—è –≤ –ø—Ä–æ–ø–∞—Å—Ç—å
            if (player.position.y < -10) {
                // –í–æ–∑–≤—Ä–∞—Ç –Ω–∞ –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—É—é —Ç–æ—á–∫—É –∏–ª–∏ –Ω–∞—á–∞–ª—å–Ω—É—é –ø–æ–∑–∏—Ü–∏—é
                if (currentCheckpoint) {
                    player.position.set(
                        currentCheckpoint.position.x,
                        currentCheckpoint.position.y + 2,
                        currentCheckpoint.position.z
                    );
                } else {
                    player.position.set(0, 2, 0);
                }
                player.velocity.set(0, 0, 0);
                
                // –£–º–µ–Ω—å—à–µ–Ω–∏–µ –∑–¥–æ—Ä–æ–≤—å—è –∑–∞ –ø–∞–¥–µ–Ω–∏–µ
                health -= 20;
                updateHealthBar();
                
                if (health <= 0) {
                    endGame();
                }
            }
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤—Ä–∞–≥–æ–≤
        function updateEnemies() {
            const now = Date.now();
            
            for (let i = 0; i < enemies.length; i++) {
                const enemy = enemies[i];
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ö–µ–ª–ø–µ—Ä–∞
                for (const helper of enemyHelpers) {
                    if (helper.enemyRef === enemy) {
                        helper.position.copy(enemy.position);
                        helper.position.y = 1.5;
                        break;
                    }
                }
                
                // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫ –∏–≥—Ä–æ–∫—É
                const direction = new THREE.Vector3();
                direction.subVectors(player.position, enemy.position).normalize();
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–∏–¥–∏–º–æ—Å—Ç–∏ –∏–≥—Ä–æ–∫–∞
                raycaster.set(enemy.position, direction);
                const intersects = raycaster.intersectObjects(walls);
                
                // –ï—Å–ª–∏ –º–µ–∂–¥—É –≤—Ä–∞–≥–æ–º –∏ –∏–≥—Ä–æ–∫–æ–º –Ω–µ—Ç —Å—Ç–µ–Ω
                if (intersects.length === 0 || 
                    intersects[0].distance > enemy.position.distanceTo(player.position)) {
                    
                    // –î–≤–∏–∂–µ–Ω–∏–µ –∫ –∏–≥—Ä–æ–∫—É
                    const newPosition = enemy.position.clone();
                    newPosition.x += direction.x * enemy.speed;
                    newPosition.z += direction.z * enemy.speed;
                    
                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–ª–∏–∑–∏–π
                    let canMove = true;
                    
                    for (const wall of walls) {
                        const enemyBox = new THREE.Box3().setFromObject(
                            new THREE.Mesh(
                                new THREE.BoxGeometry(1.5, 3, 1.5),
                                new THREE.MeshBasicMaterial()
                            )
                        );
                        enemyBox.min.set(
                            newPosition.x - 0.75,
                            newPosition.y - 1.5,
                            newPosition.z - 0.75
                        );
                        enemyBox.max.set(
                            newPosition.x + 0.75,
                            newPosition.y + 1.5,
                            newPosition.z + 0.75
                        );
                        
                        const wallBox = new THREE.Box3().setFromObject(wall);
                        
                        if (enemyBox.intersectsBox(wallBox)) {
                            canMove = false;
                            break;
                        }
                    }
                    
                    // –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –¥–≤–∏–∂–µ–Ω–∏—è, –µ—Å–ª–∏ –Ω–µ—Ç –∫–æ–ª–ª–∏–∑–∏–π
                    if (canMove) {
                        enemy.position.copy(newPosition);
                    }
                    
                    // –ü–æ–≤–æ—Ä–æ—Ç –≤—Ä–∞–≥–∞ –∫ –∏–≥—Ä–æ–∫—É
                    enemy.lookAt(player.position);
                    
                    // –°—Ç—Ä–µ–ª—å–±–∞ –≤ –∏–≥—Ä–æ–∫–∞
                    if (now - enemy.lastShot > enemy.shootInterval) {
                        enemyShoot(enemy);
                        enemy.lastShot = now;
                    }
                }
                
                // –ê–Ω–∏–º–∞—Ü–∏—è –≤—Ä–∞–≥–∞ (–ø–æ–∫–∞—á–∏–≤–∞–Ω–∏–µ)
                enemy.position.y = Math.sin(now * 0.003 + i) * 0.1;
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ–ª–ª–∞–π–¥–µ—Ä–∞
                enemy.collider = new THREE.Box3().setFromObject(enemy);
            }
        }
        
        // –°—Ç—Ä–µ–ª—å–±–∞ –≤—Ä–∞–≥–∞
        function enemyShoot(enemy) {
            // –°–æ–∑–¥–∞–Ω–∏–µ –ø—É–ª–∏
            const bulletGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
            
            // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—É–ª–∏
            bullet.position.copy(enemy.position);
            bullet.position.y = 1.5;
            
            // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—É–ª–∏ –≤ –∏–≥—Ä–æ–∫–∞
            const direction = new THREE.Vector3();
            direction.subVectors(player.position, enemy.position).normalize();
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–µ–±–æ–ª—å—à–æ–≥–æ —Ä–∞–∑–±—Ä–æ—Å–∞
            direction.x += (Math.random() - 0.5) * 0.1;
            direction.y += (Math.random() - 0.5) * 0.1;
            direction.z += (Math.random() - 0.5) * 0.1;
            direction.normalize();
            
            bullet.velocity = direction.multiplyScalar(0.7);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –≤—Å–ø—ã—à–∫–∏ –≤—ã—Å—Ç—Ä–µ–ª–∞
            const muzzlePosition = enemy.position.clone();
            muzzlePosition.y = 1.5;
            muzzlePosition.add(direction.clone().multiplyScalar(1));
            createEnemyMuzzleFlash(muzzlePosition);
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –ø—É–ª–∏ –Ω–∞ —Å—Ü–µ–Ω—É
            scene.add(bullet);
            enemyBullets.push(bullet);
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –≤—Å–ø—ã—à–∫–∏ –≤—ã—Å—Ç—Ä–µ–ª–∞ –≤—Ä–∞–≥–∞
        function createEnemyMuzzleFlash(position) {
            // –°–æ–∑–¥–∞–Ω–∏–µ —á–∞—Å—Ç–∏—Ü –¥–ª—è –≤—Å–ø—ã—à–∫–∏
            const particleCount = 15;
            const particleGeometry = new THREE.BufferGeometry();
            const particleMaterial = new THREE.PointsMaterial({
                color: 0xff3300,
                size: 0.1,
                transparent: true,
                opacity: 0.8
            });
            
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];
            
            for (let i = 0; i < particleCount; i++) {
                // –°–ª—É—á–∞–π–Ω–æ–µ –ø–æ–ª–æ–∂–µ–Ω–∏–µ –≤–æ–∫—Ä—É–≥ —Ç–æ—á–∫–∏ –≤—Å–ø—ã—à–∫–∏
                const x = position.x + (Math.random() - 0.5) * 0.2;
                const y = position.y + (Math.random() - 0.5) * 0.2;
                const z = position.z + (Math.random() - 0.5) * 0.2;
                
                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;
                
                // –°–ª—É—á–∞–π–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å
                velocities.push(new THREE.Vector3(
                    (Math.random() - 0.5) * 0.1,
                    (Math.random() - 0.5) * 0.1,
                    (Math.random() - 0.5) * 0.1
                ));
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
            
            // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã —á–∞—Å—Ç–∏—Ü –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
            particleSystems.push({
                particles: particles,
                velocities: velocities,
                life: 8 // –í—Ä–µ–º—è –∂–∏–∑–Ω–∏ —ç—Ñ—Ñ–µ–∫—Ç–∞ –≤ –∫–∞–¥—Ä–∞—Ö
            });
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —Å–≤–µ—Ç–∞ –≤—Å–ø—ã—à–∫–∏
            const flashLight = new THREE.PointLight(0xff5500, 1, 3);
            flashLight.position.copy(position);
            scene.add(flashLight);
            
            // –£–¥–∞–ª–µ–Ω–∏–µ —Å–≤–µ—Ç–∞ —á–µ—Ä–µ–∑ –∫–æ—Ä–æ—Ç–∫–æ–µ –≤—Ä–µ–º—è
            setTimeout(() => {
                scene.remove(flashLight);
            }, 100);
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—É–ª—å
        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                
                // –ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ –ø—É–ª–∏
                bullet.position.add(bullet.velocity);
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–ª–∏–∑–∏–π —Å –≤—Ä–∞–≥–∞–º–∏
                for (let j = 0; j < enemyHelpers.length; j++) {
                    const helper = enemyHelpers[j];
                    
                    const bulletBox = new THREE.Box3().setFromObject(bullet);
                    const enemyBox = new THREE.Box3().setFromObject(helper);
                    
                    if (bulletBox.intersectsBox(enemyBox)) {
                        hitEnemy(helper.enemyRef, i);
                        // –í—ã—Ö–æ–¥ –∏–∑ —Ü–∏–∫–ª–∞, —Ç–∞–∫ –∫–∞–∫ –ø—É–ª—è —É–∂–µ —É–¥–∞–ª–µ–Ω–∞
                        break;
                    }
                }
                
                // –ï—Å–ª–∏ –ø—É–ª—è –≤—Å–µ –µ—â–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –ø—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–ª–ª–∏–∑–∏–∏ —Å–æ —Å—Ç–µ–Ω–∞–º–∏
                if (i < bullets.length) {
                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–ª–∏–∑–∏–π —Å–æ —Å—Ç–µ–Ω–∞–º–∏
                    for (const wall of walls) {
                        const bulletBox = new THREE.Box3().setFromObject(bullet);
                        const wallBox = new THREE.Box3().setFromObject(wall);
                        
                        if (bulletBox.intersectsBox(wallBox)) {
                            // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –ø–æ–ø–∞–¥–∞–Ω–∏—è –≤ —Å—Ç–µ–Ω—É
                            createHitEffect(bullet.position.clone());
                            
                            scene.remove(bullet);
                            bullets.splice(i, 1);
                            break;
                        }
                    }
                }
                
                // –£–¥–∞–ª–µ–Ω–∏–µ –ø—É–ª—å, –∫–æ—Ç–æ—Ä—ã–µ —É–ª–µ—Ç–µ–ª–∏ —Å–ª–∏—à–∫–æ–º –¥–∞–ª–µ–∫–æ
                if (i < bullets.length && bullet.position.distanceTo(player.position) > 100) {
                    scene.remove(bullet);
                    bullets.splice(i, 1);
                }
            }
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—É–ª—å –≤—Ä–∞–≥–æ–≤
        function updateEnemyBullets() {
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const bullet = enemyBullets[i];
                
                // –ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ –ø—É–ª–∏
                bullet.position.add(bullet.velocity);
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–ª–∏–∑–∏–π —Å –∏–≥—Ä–æ–∫–æ–º
                const bulletBox = new THREE.Box3().setFromObject(bullet);
                const playerBox = new THREE.Box3();
                
                playerBox.min.set(
                    player.position.x - 0.5,
                    player.position.y - (isCrouching ? 0.5 : 1),
                    player.position.z - 0.5
                );
                playerBox.max.set(
                    player.position.x + 0.5,
                    player.position.y + (isCrouching ? 0.5 : 1),
                    player.position.z + 0.5
                );
                
                if (bulletBox.intersectsBox(playerBox)) {
                    hitPlayer(i);
                    continue;
                }
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–ª–∏–∑–∏–π —Å–æ —Å—Ç–µ–Ω–∞–º–∏
                for (const wall of walls) {
                    const wallBox = new THREE.Box3().setFromObject(wall);
                    
                    if (bulletBox.intersectsBox(wallBox)) {
                        // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –ø–æ–ø–∞–¥–∞–Ω–∏—è –≤ —Å—Ç–µ–Ω—É
                        createHitEffect(bullet.position.clone());
                        
                        scene.remove(bullet);
                        enemyBullets.splice(i, 1);
                        break;
                    }
                }
                
                // –£–¥–∞–ª–µ–Ω–∏–µ –ø—É–ª—å, –∫–æ—Ç–æ—Ä—ã–µ —É–ª–µ—Ç–µ–ª–∏ —Å–ª–∏—à–∫–æ–º –¥–∞–ª–µ–∫–æ
                if (i < enemyBullets.length && bullet.position.distanceTo(player.position) > 100) {
                    scene.remove(bullet);
                    enemyBullets.splice(i, 1);
                }
            }
        }
    </script>
</body>
</html>
